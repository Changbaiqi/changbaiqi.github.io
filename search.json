[{"title":"C++复习特性关键点快速总结","url":"/2023/02/24/learnnote/c-xue-xi/c-cao-fu-xi-te-xing-guan-jian-dian-kuai-su-zong-jie/","content":"C++复习特性关键点快速总结\nC++类的定义\n\n\n\n访问数据成员\n类的对象的公共数据成员可以使用直接成员访问运算符==.==来访问。\n为了更好地理解这些概念，可以尝试下面的实例：\n#include &lt;iostream&gt; using namespace std; class Box{   public:      double length;   // 长度      double breadth;  // 宽度      double height;   // 高度      // 成员函数声明      double get(void);      void set( double len, double bre, double hei );};// 成员函数定义double Box::get(void){    return length * breadth * height;} void Box::set( double len, double bre, double hei){    length = len;    breadth = bre;    height = hei;}int main( ){   Box Box1;        // 声明 Box1，类型为 Box   Box Box2;        // 声明 Box2，类型为 Box   Box Box3;        // 声明 Box3，类型为 Box   double volume = 0.0;     // 用于存储体积    // box 1 详述   Box1.height = 5.0;    Box1.length = 6.0;    Box1.breadth = 7.0;    // box 2 详述   Box2.height = 10.0;   Box2.length = 12.0;   Box2.breadth = 13.0;    // box 1 的体积   volume = Box1.height * Box1.length * Box1.breadth;   cout &lt;&lt; \"Box1 的体积：\" &lt;&lt; volume &lt;&lt;endl;    // box 2 的体积   volume = Box2.height * Box2.length * Box2.breadth;   cout &lt;&lt; \"Box2 的体积：\" &lt;&lt; volume &lt;&lt;endl;     // box 3 详述   Box3.set(16.0, 8.0, 12.0);    volume = Box3.get();    cout &lt;&lt; \"Box3 的体积：\" &lt;&lt; volume &lt;&lt;endl;   return 0;}\n\n当上面的代码被编译和执行时，它会产生下列结果：\nBox1 的体积：210Box2 的体积：1560Box3 的体积：1536\n\nC++继承\n面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为==基类==，新建的类称为==派生类==。\n继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。\n\n代码如下：\n// 基类class Animal {    // eat() 函数    // sleep() 函数};//派生类class Dog : public Animal {    // bark() 函数};\n\n基类&amp;派生类\n一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：\n&gt;class derived-class: access-specifier base-class\n\n其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：\n&gt;#include &lt;iostream&gt;&gt;using namespace std;&gt;// 基类&gt;class Shape &gt;{  public:     void setWidth(int w)     {        width = w;     }     void setHeight(int h)     {        height = h;     }  protected:     int width;     int height;&gt;};&gt;// 派生类&gt;class Rectangle: public Shape&gt;{  public:     int getArea()     {         return (width * height);      }&gt;};&gt;int main(void)&gt;{  Rectangle Rect;  Rect.setWidth(5);  Rect.setHeight(7);  // 输出对象的面积  cout &lt;&lt; \"Total area: \" &lt;&lt; Rect.getArea() &lt;&lt; endl;  return 0;&gt;}\n\n当上面的代码被编译和执行时，它会产生下列结果：\n&gt;Total area: 35\n\n访问控制和继承\n派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n\n\n\n访问\npublic\nprotected\nprivate\n\n\n\n同一个类\nyes\nyes\nyes\n\n\n派生类\nyes\nyes\nno\n\n\n外部的类\nyes\nno\nno\n\n\n\n\n继承类型\n当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。\n我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：\n\n公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。\n保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。\n私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。\n\n\n多继承\n多继承即一个子类可以有多个父类，它继承了多个父类的特性。\nC++ 类可以从多个类继承成员，语法如下：\n&gt;class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&gt;{&gt;&lt;派生类类体&gt;&gt;};\n\n其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：\n&gt;#include &lt;iostream&gt;&gt;using namespace std;&gt;// 基类 Shape&gt;class Shape &gt;{  public:     void setWidth(int w)     {        width = w;     }     void setHeight(int h)     {        height = h;     }  protected:     int width;     int height;&gt;};&gt;// 基类 PaintCost&gt;class PaintCost &gt;{  public:     int getCost(int area)     {        return area * 70;     }&gt;};&gt;// 派生类&gt;class Rectangle: public Shape, public PaintCost&gt;{  public:     int getArea()     {         return (width * height);      }&gt;};&gt;int main(void)&gt;{  Rectangle Rect;  int area;  Rect.setWidth(5);  Rect.setHeight(7);  area = Rect.getArea();    // 输出对象的面积  cout &lt;&lt; \"Total area: \" &lt;&lt; Rect.getArea() &lt;&lt; endl;  // 输出总花费  cout &lt;&lt; \"Total paint cost: $\" &lt;&lt; Rect.getCost(area) &lt;&lt; endl;  return 0;&gt;}\n\n当上面的代码被编译和执行时，它会产生下列结果：\n&gt;Total area: 35&gt;Total paint cost: $2450\n\nC++重载运算符和重载函数\nC++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。\n重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。\n当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。\n\n\nC++ 中的函数重载\n在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。\n下面的实例中，同名函数 print() 被用于输出不同的数据类型：\n#include &lt;iostream&gt;using namespace std; class printData{   public:      void print(int i) {        cout &lt;&lt; \"整数为: \" &lt;&lt; i &lt;&lt; endl;      }       void print(double  f) {        cout &lt;&lt; \"浮点数为: \" &lt;&lt; f &lt;&lt; endl;      }       void print(char c[]) {        cout &lt;&lt; \"字符串为: \" &lt;&lt; c &lt;&lt; endl;      }}; int main(void){   printData pd;    // 输出整数   pd.print(5);   // 输出浮点数   pd.print(500.263);   // 输出字符串   char c[] = \"Hello C++\";   pd.print(c);    return 0;}\n\n当上面的代码被编译和执行时，它会产生下列结果：\n整数为: 5浮点数为: 500.263字符串为: Hello C++\nC++中的运算符重载\n您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\nBox operator+(const Box&amp;);\n\n下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示：\n#include &lt;iostream&gt;using namespace std; class Box{   public:       double getVolume(void)      {         return length * breadth * height;      }      void setLength( double len )      {          length = len;      }       void setBreadth( double bre )      {          breadth = bre;      }       void setHeight( double hei )      {          height = hei;      }      // 重载 + 运算符，用于把两个 Box 对象相加      Box operator+(const Box&amp; b)      {         Box box;         box.length = this-&gt;length + b.length;         box.breadth = this-&gt;breadth + b.breadth;         box.height = this-&gt;height + b.height;         return box;      }   private:      double length;      // 长度      double breadth;     // 宽度      double height;      // 高度};// 程序的主函数int main( ){   Box Box1;                // 声明 Box1，类型为 Box   Box Box2;                // 声明 Box2，类型为 Box   Box Box3;                // 声明 Box3，类型为 Box   double volume = 0.0;     // 把体积存储在该变量中    // Box1 详述   Box1.setLength(6.0);    Box1.setBreadth(7.0);    Box1.setHeight(5.0);    // Box2 详述   Box2.setLength(12.0);    Box2.setBreadth(13.0);    Box2.setHeight(10.0);    // Box1 的体积   volume = Box1.getVolume();   cout &lt;&lt; \"Volume of Box1 : \" &lt;&lt; volume &lt;&lt;endl;    // Box2 的体积   volume = Box2.getVolume();   cout &lt;&lt; \"Volume of Box2 : \" &lt;&lt; volume &lt;&lt;endl;    // 把两个对象相加，得到 Box3   Box3 = Box1 + Box2;    // Box3 的体积   volume = Box3.getVolume();   cout &lt;&lt; \"Volume of Box3 : \" &lt;&lt; volume &lt;&lt;endl;    return 0;}\n\n当上面的代码被编译和执行时，它会产生下列结果：\nVolume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400\n\n可重载运算符/不可重载运算符\n下面是可重载运算符/不可重载运算符下面是可重载的运算符列表：\n\n\n\n双目算术运算符\n+ (加)，-(减)，*(乘)，/(除)，% (取模)\n\n\n\n关系运算符\n==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)\n\n\n逻辑运算符\n||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)\n\n\n单目运算符\n+ (正)，-(负)，*(指针)，&amp;(取地址)\n\n\n自增自减运算符\n++(自增)，–(自减)\n\n\n位运算符\n| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)\n\n\n赋值运算符\n=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=\n\n\n空间申请与释放\nnew, delete, new[ ] , delete[]\n\n\n其他运算符\n()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)\n\n\n下面是不可重载的运算符列表：\n\n.：成员访问运算符\n.*, -&gt;*：成员指针访问运算符\n::：域运算符\nsizeof：长度运算符\n?:：条件运算符\n#： 预处理符号\n\n\n\n运算符重载实例\n下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。\n\n\n\n序号\n运算符和实例\n\n\n\n1\n一元运算符重载\n\n\n2\n二元运算符重载\n\n\n3\n关系运算符重载\n\n\n4\n输入/输出运算符重载\n\n\n5\n++ 和 – 运算符重载\n\n\n6\n赋值运算符重载\n\n\n7\n函数调用运算符 () 重载\n\n\n8\n[下标运算符 ] 重载\n\n\n9\n类成员访问运算符 -&gt; 重载\n\n\n\n","categories":["C++"],"tags":["C++"]},{"title":"如何配置Docker镜像","url":"/2024/07/02/learnnote/docker/ru-he-pei-zhi-docker-jing-xiang/","content":"如何配置Docker镜像\nDockerd 代理在执行docker pull时，是由守护进程dockerd来执行。因此，代理需要配在dockerd的环境中。而这个环境，则是受systemd所管控，因此实际是systemd的配置。\n1、创建dockerd相关的systemd目录，这个目录下的配置将覆盖dockerd的默认配置\n$ sudo mkdir -p /etc/systemd/system/docker.service.d\n新建配置文件/etc/systemd/system/docker.service.d/proxy.conf\nsudo mkdir -p /etc/systemd/system/docker.service.dsudo touch /etc/systemd/system/docker.service.d/proxy.conf\n\n在这个proxy.conf文件（可以是任意*.conf的形式）中，添加以下内容：\n[Service]Environment=\"HTTP_PROXY=http://proxy.example.com:8080/\"Environment=\"HTTPS_PROXY=http://proxy.example.com:8080/\"Environment=\"NO_PROXY=localhost,127.0.0.1,.example.com\"\n\n其中，http://proxy.example.com:8080要换成可用的免密代理。通常使用 cntlm 在本机自建免密代理，去对接公司的代理。可参考《Linux下安装配置Cntlm 代理》。\nContainer 代理在容器运行阶段，如果需要代理上网，则需要配置 ~/.docker/config.json。以下配置，只在Docker 17.07及以上版本生效。\n{ \"proxies\": {   \"default\":   {     \"httpProxy\": \"http://proxy.example.com:8080\",     \"httpsProxy\": \"http://proxy.example.com:8080\",     \"noProxy\": \"localhost,127.0.0.1,.example.com\"   } }}\n\n这个是用户级的配置，除了 proxies，docker login 等相关信息也会在其中。而且还可以配置信息展示的格式、插件参数等。\n此外，容器的网络代理，也可以直接在其运行时通过 -e 注入 http_proxy 等环境变量。这两种方法分别适合不同场景。config.json 非常方便，默认在所有配置修改后启动的容器生效，适合个人开发环境。在CI/CD的自动构建环境、或者实际上线运行的环境中，这种方法就不太合适，用 -e 注入这种显式配置会更好，减轻对构建、部署环境的依赖。当然，在这些环境中，最好用良好的设计避免配置代理上网。\nDocker Build 代理虽然 docker build 的本质，也是启动一个容器，但是环境会略有不同，用户级配置无效。在构建时，需要注入 http_proxy 等参数。\ndocker build . \\    --build-arg \"HTTP_PROXY=http://proxy.example.com:8080/\" \\    --build-arg \"HTTPS_PROXY=http://proxy.example.com:8080/\" \\    --build-arg \"NO_PROXY=localhost,127.0.0.1,.example.com\" \\    -t your/image:tag\n\n注意：无论是 docker run 还是 docker build，默认是网络隔绝的。如果代理使用的是 localhost:3128 这类，则会无效。这类仅限本地的代理，必须加上 –network host 才能正常使用。而一般则需要配置代理的外部IP，而且代理本身要开启 Gateway 模式。\n重启生效代理配置完成后，reboot 重启当然可以生效，但不重启也行。\ndocker build 代理是在执行前设置的，所以修改后，下次执行立即生效。Container 代理的修改也是立即生效的，但是只针对以后启动的 Container，对已经启动的 Container 无效。\ndockerd 代理的修改比较特殊，它实际上是改 systemd 的配置，因此需要重载 systemd 并重启 dockerd 才能生效。\nsudo systemctl daemon-reloadsudo systemctl restart docker\n\n","categories":["Docker"],"tags":["Docker"]},{"title":"Flutter基础学习笔记","url":"/2023/02/24/learnnote/flutter-xue-xi-bi-ji/flutter-ji-chu-xue-xi/","content":"Flutter基础学习目录结构\n\nandroid：用于android软件的相关\nios：用于ios相关\nlib：Flutter代码存放地\ntest：测试用例代码存放地\n\nDart以main函数为入口，软件以runApp实体类为软件绘制入口。\n\nimport 'package:flutter/material.dart';void main(){    runApp(    \tCenter(        child: Text('XXX'),        )    );}\n可以单独将Center抽离成一个组件：\n\nimport 'package:flutter/material.dart';void main(){ runApp(MyApp());}class MyApp extends StatelessWidget{        @override    Widget build(BuildContext context){                   return MaterialApp(      home: Scaffold(        appBar: AppBar(        title: Text('Flutter Demo')        ),        body: HomeContext(),      ),      theme: ThemeData(        primarySwatch: Colors.deepOrange      ),    );    }}\n\n\nClipOval类：\n\nchild: Image.asset(“images/b.webp”) 加载本地图片\nwidth: 设置宽\nheight: 设置高\n\n静态组件更新：\n```GridView网格布局：动态组件用这个：```dart@overrideWidget build(BuildContext context){\treturn GridView.builder(\t)}\n\n\n\n静态组件用这个：\n@overrideWidget build(BuildContext context){\treturn GridView.count(\t)}\n\n\n\n\n\nRow：\n\nmainAxisAlignment\ncrossAxisAlignment\nchildren\n\n","categories":["前端"],"tags":["Android","Flutter"]},{"title":"关于如何解决Flutter打包一直停留在Build阶段分析与解决","url":"/2025/01/18/learnnote/flutter-xue-xi-bi-ji/guan-yu-ru-he-jie-jue-flutter-da-bao-yi-zhi-ting-liu-zai-build-jie-duan-fen-xi-yu-jie-jue/","content":"关于如何解决Flutter打包一直停留在Build阶段分析与解决\n\n情况：\n若一直出现Build ..一直没有任何打包成功的动静很可能是android对应的Gradle依赖未下载好缘故，一直在下载。而在国内有些依赖是使用的是google的下载渠道，所以网速可能很慢也可能根本就连不上（原因你们也懂的）\n\n解决方法：\n首先先进入Flutter先对应的android目录，之后再输入\n./gradlew clean\n\n这样他就会下载对应依赖的同时显示下载进度等，这个时候你就可以分析是下载速度慢的问题还是其他问题导致，如果是下载速度慢建议是挂梯子（并且设置proxy代理到对应梯子端口），或者采用国内镜像代理。\n\n\n","categories":["Flutter"],"tags":["Flutter","问题解决"]},{"title":"Git相关操作","url":"/2023/10/30/learnnote/git-xue-xi/git-xiang-guan-cao-zuo/","content":"理解工作区和暂存区的区别？工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。\n使用Git提交文件到版本库有两步：\n第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。\n第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。\n常用指令设置git用户名和邮箱标识git config --global user.name \"用户名\"\n\ngit config --global user.email \"你所想绑定的邮箱\"\n\n\n\n查看当前git用户信息git config user.name  #查看用户名称 git config user.email #查看用户邮箱\n\n\n\n\n\n初始化仓库git init\n\n增加文件到暂存区git add 文件.后缀\n\ngit add .  #指的当前目前下所有文件\n\n\n\n把文件提交到本地仓库git commit -m \"这里填写本次提交的注释\"\n\n\n\n\n\n查看是否还有文件未提交git status\n\n\n\n\n\n查看文件对比上次提交修改了什么内容git diff 文件\n\n\n\n\n\n查看commit日志git log\n\n\ngit log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：\n\ncommit版本回退回退前几个版本git reset --hard HEAD^\n\n如果是退回到上上个版本那么只需要多加个^即可,其他也依次类推，比如：\ngit reset --hard HEAD^^\n\n当然，如果回退的版本太多的话，可以这么写：\ngit reset --hard HEAD~100  #这里表示回退到前100个版本\n\n\n\n按照版本号回退git reset --hard 版本号 #注意这里版本号可以不用写全，可以只写前面7个或以上，反正不会和其他版本产生歧义就行\n\n有2种情况，如下：\n1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。\n撤销修改和删除文件操作git checkout -- 文件名称\n\n\n\n绑定远程仓库第一步：\nssh-keygen -t rsa -C \"对应你的账号邮箱\"\n\n创建好之后可以去C盘下的User目录对应用户账号的.ssh里面看到相应创建\n其中\n\nid_ras是私钥，这玩意不泄露出去\nid_ras.pub是公钥，可以放心告诉其他任何人\n\n第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。\n取消绑定远程仓库git remote remove origin #这个origin是绑定时候的仓库标签别名\n\n\n\n创建分支并进入git checkout -b dev #这里指的是创建一个名为dev的分支\n\n\ngit checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令\ngit branch dev\ngit checkout dev\n\n查看当前分支git branch\n\n\n\n\n\n\n\n合并分支第一步：\n比如这里切换到master分支\ngit branch master\n\n第二步:\ngit merge dev\n\n\ngit merge命令用于合并指定分支到当前分支上\n合并之后，我们可以看到，和dev分支最新提交的是完全一样的。\n合并完成之后，我们可以接着删除dev分支了，操作如下：\ngit branch -d dev #删除dev分支git branch #查看当前分支\n\n\n修改分支名称（重命名分支名称）git branch -m oldName newName\n\n\n\n\n\n删除分支1、删除本地分支\ngit branch -d &lt;localBranchName&gt; #localBranchName就是本地分支的名称\n\n\n\n2、删除远程分支\ngit push -u origin -d &lt;branchName&gt;  #&lt;branchName&gt;就是分支的名称\n\n\n其中==-d==是==-delete==的缩写\n\nGit 拉取远程分支代码并合并到本地分支步骤git remote -v #查看远程#获取远程指定分支到本地临时新建的分支#获取远程master的分支的代码到临时新建的tempgit fetch origin master:temp#查看版本差异#查看temp分支与当前分支的差异git diff temp#将临时分支temp合并到当前分支git merge temp#删除本地临时分支git branch -d temp\n\n不在本地新建分支版本：#查看远程git remote -v#获取远程分支到本地#获取远程的master分支git fetch origin master#查看版本差异#查看远程master分支与本地master分支的差别git log -p master..origin/master#合并到本地分支git merge origin/master\n\n他奶奶的直接拉取合并（不推荐用，万一出岔子自己负责）#查看远程分支git remtoe -v#拉取合并到本地分支,因为pull实际上就是fetch和merge的结合体#拉取远程master分支合并到当前分支git pull origin master\n\n\n\n\n\n\n\n如果遇到大文件想要删除，或者想删除所有commit中的指定文件Git无法上传删除 Commit里面有大文件_git 删除commit的大文件-CSDN博客\n","categories":["Git"],"tags":["Git"]},{"title":"Hexo+Butterfly 自定义右键菜单","url":"/2024/01/24/learnnote/hexo-bo-ke-da-jian-jiao-cheng/hexo-butterfly-zi-ding-yi-you-jian-cai-dan/","content":"Hexo+Butterfly 自定义右键菜单\n效果展示：\n步骤1.创建布局文件在[博客根目录]/themes/butterfly/layout/includes文件夹下新建一个right-menu的文件夹，在此文件夹下新建一个index.pug文件。\n\n将以下代码复制到文件中：\n#rightMenu    .rightMenu-group.rightMenu-small        .rightMenu-item#menu-backward            i.fa-solid.fa-arrow-left        .rightMenu-item#menu-forward            i.fa-solid.fa-arrow-right        .rightMenu-item#menu-refresh            i.fa-solid.fa-arrow-rotate-right        .rightMenu-item#menu-home            i.fa-solid.fa-house    .rightMenu-group.rightMenu-line.rightMenuOther        a.rightMenu-item.menu-link(href='/archives/')            i.fa-solid.fa-archive            span='文章归档'        a.rightMenu-item.menu-link(href='/categories/')            i.fa-solid.fa-folder-open            span='文章分类'        a.rightMenu-item.menu-link(href='/tags/')            i.fa-solid.fa-tags            span='文章标签'    .rightMenu-group.rightMenu-line.rightMenuNormal        a.rightMenu-item.menu-link#menu-radompage(href='/random/index.html')            i.fa-solid.fa-shoe-prints            span='随便逛逛'        .rightMenu-item#menu-translate            i.fa-solid.fa-earth-asia            span='繁简切换'        .rightMenu-item#menu-darkmode            i.fa-solid.fa-moon            span='切换模式'#rightmenu-mask\n\n\n\n2. 引入布局在[博客根目录]/themes/butterfly/layout/includes/layout.pug中引入上一步中创建的index.pug文件。具体位置如下图：\n\n3. 创建js在[博客根目录]/themes/butterfly/source/js文件夹下新建一个rightMenu.js，将以下代码复制到文件中。\nvar rm = {};rm.showRightMenu = function (isTrue, x = 0, y = 0) {    let $rightMenu = $('#rightMenu');    $rightMenu.css('top', x + 'px').css('left', y + 'px');    if (isTrue) {        stopMaskScroll()        $rightMenu.show();    } else {        $rightMenu.hide();    }};let rmWidth = $('#rightMenu').width();let rmHeight = $('#rightMenu').height();rm.reloadrmSize = function () {    rmWidth = $(\"#rightMenu\").width();    rmHeight = $(\"#rightMenu\").height()};window.oncontextmenu = function (event) {    if (document.body.clientWidth &gt; 768) {        let pageX = event.clientX + 10;\t        let pageY = event.clientY;        let $rightMenuNormal = $(\".rightMenuNormal\");        let $rightMenuOther = $(\".rightMenuOther\");        let $rightMenuReadmode = $(\"#menu-readmode\");        $rightMenuNormal.show();        $rightMenuOther.show();        rm.reloadrmSize();        if (pageX + rmWidth &gt; window.innerWidth) {            pageX -= rmWidth;        }        if (pageY + rmHeight &gt; window.innerHeight) {            pageY -= rmHeight;        }        rm.showRightMenu(true, pageY, pageX);        $('#rightmenu-mask').attr('style', 'display: flex');        return false;    }};function removeRightMenu() {    rm.showRightMenu(false);    $('#rightmenu-mask').attr('style', 'display: none');}function stopMaskScroll() {    if (document.getElementById(\"rightmenu-mask\")) {        let xscroll = document.getElementById(\"rightmenu-mask\");        xscroll.addEventListener(\"mousewheel\", function (e) {            removeRightMenu();        }, false);    };    if (document.getElementById(\"rightMenu\")) {        let xscroll = document.getElementById(\"rightMenu\");        xscroll.addEventListener(\"mousewheel\", function (e) {            removeRightMenu();        }, false);    }}/** * @name:  切換模式 */function switchDarkMode() {    removeRightMenu();    const nowMode = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'    if (nowMode === 'light') {        activateDarkMode();        saveToLocal.set('theme', 'dark', 2);        GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night);    } else {        activateLightMode();        saveToLocal.set('theme', 'light', 2);        GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day);    }    typeof utterancesTheme === 'function' &amp;&amp; utterancesTheme();    typeof FB === 'object' &amp;&amp; window.loadFBComment();    window.DISQUS &amp;&amp; document.getElementById('disqus_thread').children.length &amp;&amp; setTimeout(() =&gt; window.disqusReset(), 200);};/* eslint-disable no-undef */document.addEventListener('DOMContentLoaded', function () {    translateInitialization();    document.addEventListener('pjax:complete', translateInitialization);});const translate = GLOBAL_CONFIG.translate;const snackbarData = GLOBAL_CONFIG.Snackbar;const defaultEncoding = translate.defaultEncoding; /* 網站默認語言，1: 繁體中文, 2: 簡體中文 */const translateDelay = translate.translateDelay; /* 延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0 */const msgToTraditionalChinese = translate.msgToTraditionalChinese; /* 此處可以更改為你想要顯示的文字 */const msgToSimplifiedChinese = translate.msgToSimplifiedChinese; /* 同上，但兩處均不建議更改 */let currentEncoding = defaultEncoding;const targetEncodingCookie = 'translate-chn-cht';let targetEncoding =    saveToLocal.get(targetEncodingCookie) === undefined        ? defaultEncoding        : Number(saveToLocal.get('translate-chn-cht'));let translateButtonObjectconst isSnackbar = GLOBAL_CONFIG.Snackbar !== undefined;function translateText(txt) {    if (txt === '' || txt == null) return '';    if (currentEncoding === 1 &amp;&amp; targetEncoding === 2) return Simplized(txt);    else if (currentEncoding === 2 &amp;&amp; targetEncoding === 1) { return Traditionalized(txt) } else return txt;}function translateBody(fobj) {    let objs;    if (typeof fobj === 'object') objs = fobj.childNodes;    else objs = document.body.childNodes;    for (let i = 0; i &lt; objs.length; i++) {        const obj = objs.item(i);        if (            '||BR|HR|'.indexOf('|' + obj.tagName + '|') &gt; 0 ||            obj === translateButtonObject        ) { continue }        if (obj.title !== '' &amp;&amp; obj.title != null) { obj.title = translateText(obj.title) };        if (obj.alt !== '' &amp;&amp; obj.alt != null) obj.alt = translateText(obj.alt);        if (obj.placeholder !== '' &amp;&amp; obj.placeholder != null) obj.placeholder = translateText(obj.placeholder);        if (            obj.tagName === 'INPUT' &amp;&amp;            obj.value !== '' &amp;&amp;            obj.type !== 'text' &amp;&amp;            obj.type !== 'hidden'        ) { obj.value = translateText(obj.value) }        if (obj.nodeType === 3) obj.data = translateText(obj.data);        else translateBody(obj);    }}function translatePage() {    if (targetEncoding === 1) {        currentEncoding = 1;        targetEncoding = 2;        saveToLocal.set(targetEncodingCookie, targetEncoding, 2);        translateBody();        if (isSnackbar) btf.snackbarShow(snackbarData.cht_to_chs);    } else if (targetEncoding === 2) {        currentEncoding = 2;        targetEncoding = 1;        saveToLocal.set(targetEncodingCookie, targetEncoding, 2);        translateBody();        if (isSnackbar) btf.snackbarShow(snackbarData.chs_to_cht);    }}function JTPYStr() {    return '万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾'}function FTPYStr() {    return '萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽'}function Traditionalized(cc) {    let str = '';    const ss = JTPYStr();    const tt = FTPYStr();    for (let i = 0; i &lt; cc.length; i++) {        if (cc.charCodeAt(i) &gt; 10000 &amp;&amp; ss.indexOf(cc.charAt(i)) !== -1) { str += tt.charAt(ss.indexOf(cc.charAt(i))) } else str += cc.charAt(i)    };    return str;}function Simplized(cc) {    let str = '';    const ss = JTPYStr();    const tt = FTPYStr();    for (let i = 0; i &lt; cc.length; i++) {        if (cc.charCodeAt(i) &gt; 10000 &amp;&amp; tt.indexOf(cc.charAt(i)) !== -1) { str += ss.charAt(tt.indexOf(cc.charAt(i))) } else str += cc.charAt(i)    }    return str;}function translateInitialization() {    translateButtonObject = document.getElementById('menu-translate');    if (translateButtonObject) {        if (currentEncoding !== targetEncoding) {            setTimeout(translateBody, translateDelay);        }        translateButtonObject.addEventListener('click', translatePage, false);    }}$('#menu-backward').on('click', function () { window.history.back(); });$('#menu-forward').on('click', function () { window.history.forward(); });$('#menu-refresh').on('click', function () { window.location.reload(); });$('#menu-darkmode').on('click', function () { switchDarkMode() });$('#menu-home').on('click', function () { window.location.href = window.location.origin; });/* 简体繁体切换 */$('#menu-translate').on('click', function () {    removeRightMenu();    translateInitialization();});$(\".menu-link\").on(\"click\", function () {    removeRightMenu()});$(\"#rightmenu-mask\").on(\"click\", function () { removeRightMenu() });$(\"#rightmenu-mask\").contextmenu(function () {    removeRightMenu();    return false;});\n\n\n\n4. 创建CSS在[博客根目录]/themes/butterfly/source/css文件夹下新建一个rightMenu.css，将以下代码复制到文件中。\n#rightMenu {    display: none;    position: fixed;    padding: 0 .25rem;    width: 9rem;    height: fit-content;    top: 10%;    left: 10%;    background-color: rgba(238, 255, 255, .85);    -webkit-backdrop-filter: blur(20px);    backdrop-filter: blur(20px);    color: #363636;    border-radius: 12px;    z-index: 99994;    border: #e3e8f7;    user-select: none;    box-shadow: rgba(0, 0, 0, .05);}#rightMenu a {    color: #363636;}#rightMenu .rightMenu-group {    padding: .35rem .3rem;    transition: .3s}#rightMenu .rightMenu-line {    border-top: 1px dashed #4259ef23}#rightMenu .rightMenu-group.rightMenu-small {    display: flex;    justify-content: space-between}#rightMenu .rightMenu-group .rightMenu-item {    border-radius: 8px;    transition: .3s;    cursor: pointer}#rightMenu .rightMenu-line .rightMenu-item {    margin: .25rem 0;    padding: .25rem 0}#rightMenu .rightMenu-group.rightMenu-line .rightMenu-item {    display: flex}#rightMenu .rightMenu-group .rightMenu-item:hover {    background-color: #6f42c1;    color: #fff;}#rightMenu .rightMenu-group .rightMenu-item:active {    transform: scale(.97)}#rightMenu .rightMenu-group .rightMenu-item i {    display: inline-block;    text-align: center;    line-height: 1.5rem;    width: 1.5rem;    padding: 0 .25rem}#rightMenu .rightMenu-line .rightMenu-item i {    margin: 0 .25rem}#rightMenu .rightMenu-group .rightMenu-item span {    line-height: 1.5rem}.rightMenu-small .rightMenu-item {    width: 30px;    height: 30px;    line-height: 30px}#rightmenu-mask {    position: fixed;    width: 100vw;    height: 100vh;    background: 0 0;    top: 0;    left: 0;    display: none;    z-index: 101;    margin: 0 !important;    z-index: 99993}\n\n\n\n5. 引入在主题配置文件[博客根目录]/themes/butterfly/_config.yml中引入Jquery、rightMenu.js和rightMenu.css\ninject:  head:    - &lt;link rel=\"stylesheet\" href=\"/css/rightMenu.css\"&gt;  bottom:    - &lt;script defer src=\"https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js\"&gt;&lt;/script&gt;    - &lt;script defer data-pjax src=\"/js/rightMenu.js\"&gt;&lt;/script&gt;\n\n\n需要注意的是，如果点击繁简切换，切换模式，出现了错误，请检查下主题的这两个功能是否开启。在主题配置文件[博客根目录]/themes/butterfly/_config.yml中搜索translate和darkmode，将enable设置为true，在重新编译运行。\n\n扩展这个章节将讲述如何去扩展右键的功能。通过上面的步骤，我们已经实现了下图中的功能。\n\n如果想在自定义右键上新增一个打印页面的功能。该如何去实现呢？\n\n增加DOM。（为了描述的更清晰，将沿用上面提到过的代码，+表示在此基础上新增的代码。）在[博客根目录]/themes/butterfly/layout/includes/right-menu/index.pug中新加如下代码：\n\n#rightMenu    .rightMenu-group.rightMenu-small        .rightMenu-item#menu-backward            i.fa-solid.fa-arrow-left        .rightMenu-item#menu-forward            i.fa-solid.fa-arrow-right        .rightMenu-item#menu-refresh            i.fa-solid.fa-arrow-rotate-right        .rightMenu-item#menu-home            i.fa-solid.fa-house    .rightMenu-group.rightMenu-line.rightMenuOther        a.rightMenu-item.menu-link(href='/archives/')            i.fa-solid.fa-archive            span='文章归档'        a.rightMenu-item.menu-link(href='/categories/')            i.fa-solid.fa-folder-open            span='文章分类'        a.rightMenu-item.menu-link(href='/tags/')            i.fa-solid.fa-tags            span='文章标签'    .rightMenu-group.rightMenu-line.rightMenuNormal        a.rightMenu-item.menu-link#menu-radompage(href='/random/index.html')            i.fa-solid.fa-shoe-prints            span='随便逛逛'        .rightMenu-item#menu-translate            i.fa-solid.fa-earth-asia            span='繁简切换'        .rightMenu-item#menu-darkmode            i.fa-solid.fa-moon            span='切换模式'+       .rightMenu-item#menu-print+           i.fa-solid.fa-print.fa-fw+           span='打印页面'#rightmenu-mask\n\n\n\n有兴趣的同学可以按下F12打开控制台，找到Elements，并找到#rightMenu的盒子，你会发现新增的pug语法最终会被编译成：\n&lt;div class=\"rightMenu-item\" id=\"menu-print\"&gt;    &lt;i class=\"fa-solid fa-print fa-fw\"&gt;&lt;/i&gt;    &lt;span&gt;打印頁面&lt;/span&gt;&lt;/div&gt;\n\n\n记住这个id为menu-print的属性，下面将会用到。\n\n在[博客根目录]/themes/butterfly/source/js/rightMenu.js中写入实现方法。\n\n$('#menu-translate').on('click', function () {    removeRightMenu();    translateInitialization();});$(\".menu-link\").on(\"click\", function () {    removeRightMenu()});+   $(\"#menu-print\").on(\"click\", function () {+       removeRightMenu();+       window.print();+   });$(\"#rightmenu-mask\").on(\"click\", function () { removeRightMenu() });$(\"#rightmenu-mask\").contextmenu(function () {    removeRightMenu();    return false;});\n\n\n\n不难发现，新增的代码实际上是在id为menu-print的盒子上绑了一个点击事件，后面的方法则是触发点击事件后要执行的过程。\nfunction () {    // 在这里执行你想实现的操作    // removeRightMenu();    // window.print();}\n\n\n\n\n此时点击鼠标右键，会出现新加的一项功能打印页面。\n\n\n到此，你学废了吗？遇到问题的话请在评论区留言。\n文章整合引用：Hexo + Butterfly 自定义右键菜单 | 唐志远 (fe32.top)\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo博客笔记书写Front-matter参数大全","url":"/2024/01/14/learnnote/hexo-bo-ke-da-jian-jiao-cheng/hexo-bo-ke-bi-ji-shu-xie-front-matter-can-shu-da-quan/","content":"Hexo博客笔记书写Front-matter参数大全\n常见Front-matter---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 长白崎img: /source/images/xxx.jpgtop: truehide: falsecover: truepublished: falsecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---\n\n参数说明\ntitle 文章标题\ndate 文章发布时间\nauthor 文章作者\nimg 标题图片\ntop 是否置顶true为置顶\nhide 是否隐藏文章true为隐藏\npublished 是否公开文章false为不公开\n\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo常用指令","url":"/2024/02/27/learnnote/hexo-bo-ke-da-jian-jiao-cheng/hexo-chang-yong-zhi-ling/","content":"Hexo常用指令\n创建新文章\n$ hexo new \"My New Post\" #这里My New Post是文章名称\n\n通过node运行当前博客\n$ hexo server #这里就是启动的意思\n\n生成静态页面\n$hexo generate #这里就是生成静态页面的指令\n\n\n\n打包静态页面并部署到github\n$ hexo g -d #这里g的意思就是打包成静态页面也就是指令generate，-d其实就是deploy，也就是部署的意思\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo解决进入页面动画加载缓慢问题","url":"/2024/01/23/learnnote/hexo-bo-ke-da-jian-jiao-cheng/hexo-jie-jue-jin-ru-ye-mian-dong-hua-jia-zai-huan-man-wen-ti/","content":"Hexo解决进入页面动画加载缓慢问题\n是否开启了进入页面启动加载动画，并且加载非常缓慢？\n导致这个的原因大致有：\n\n动画加载费时\n浏览器需要将网站整体的元素都初始化完成，导致耗费时间\n浏览器初始化网站时需要返回一个值，但一直没有返回\n你的网站它心情不太好🧐\n\nAnyway，想到一个粗暴但简单的方法来解决这个问题。\n解决办法打开 \\themes\\butterfly\\layout\\includes\\loading\\fullpage-loading.pug文件\n将标注//新增的两行代码添加进去\n#loading-box  .loading-left-bg  .loading-right-bg  .spinner-box    .configure-border-1      .configure-core    .configure-border-2      .configure-core    .loading-word= _p('loading')//- script. //原代码script(async). //新增  const preloader = {    endLoading: () =&gt; {      document.body.style.overflow = 'auto';      document.getElementById('loading-box').classList.add(\"loaded\")    },    initLoading: () =&gt; {      document.body.style.overflow = '';      document.getElementById('loading-box').classList.remove(\"loaded\")    }  }  window.addEventListener('load',()=&gt; { preloader.endLoading() })  setTimeout(function(){preloader.endLoading();}, 5000); //新增  if (!{theme.pjax &amp;&amp; theme.pjax.enable}) {    document.addEventListener('pjax:send', () =&gt; { preloader.initLoading() })    document.addEventListener('pjax:complete', () =&gt; { preloader.endLoading() })  }\n\n这两行代码的意思是：\n在加载动画时，采用的是异步加载方式。如果超过5秒没有反应，则认为超时。\n参考文章：Loading Animation | Akilarの糖果屋\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo通过插件对图片进行懒加载","url":"/2024/01/23/learnnote/hexo-bo-ke-da-jian-jiao-cheng/hexo-tong-guo-cha-jian-dui-tu-pian-jin-xing-lan-jia-zai/","content":"Hexo通过插件对图片进行懒加载\n一、下载Hexo-lazyload-image插件npm install hexo-lazyload-image --save\n\n\n\n\n\n二、修改配置找到hexo项目的根目录下的站点配置文件_config.yml，具体路径：blog/_config.yml，其中blog是你的项目文件夹。\nlazyload:  enable: true  onlypost: false # optional  loadingImg: # optional eg ./images/loading.gif  isSPA: false # optional  preloadRatio: 3 # optional, default is 1\n\n\n\n\nonlypost\n\ntrue：只有路由页面或者文章的图片才会被懒加载。\n\nfalse：除了站点背景图（如果有的话），整个站点的图片均会被懒加载。\n\n\n\nloadingImg：指定的话，加载自定义路径的图片用作文章图片加载时显示，不指定的话显示默认图片。\n\nisSPA\n\ntrue：针对单页面应用，当滚动条滚动到图片位置时就会向后端请求图片\nfalse：刷新才能请求图片\n\n\npreloadRatio：在多少倍的可见区域时触发图片请求，默认为1，即当前屏幕的区域。\n\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Nunjucks Error expected variable end解决办法","url":"/2024/06/08/learnnote/hexo-bo-ke-da-jian-jiao-cheng/nunjucks-error-expected-variable-end-jie-jue-ban-fa/","content":"Nunjucks Error expected variable end解决办法\n\n\n## 问题：\n\n&gt; 如果在部署hexo博客的时候报错Nunjucks Error expected variable end则可能是因为Hexo使用Nunjucks渲染贴子，使用=={{ }}==或者=={% %}==包装的内容被解析，这样会引起冲突。\n\n\n\n解决方法：使用以下标签包裹对应铭感字段就行：\n{% raw %}{% endraw %}\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"解决Hexo+Typora无法同时显示相对路径图片问题","url":"/2024/01/24/learnnote/hexo-bo-ke-da-jian-jiao-cheng/jie-jue-hexo-typora-wu-fa-tong-shi-xian-shi-xiang-dui-lu-jing-tu-pian-wen-ti/","content":"解决Hexo+Typora无法同时显示相对路径图片问题\n一、设置Typora\n设置如下图：\n\n\n二、安装和简单魔改hexo-asset-image插件在hexo项目根目录使用指令安装hexo-asset-images插件\nnpm hexo-asset-images --save\n\n或者：\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n\n然后设置hexo项目根目录_config.yml配置:\n\n然后设置_config.yml中的post_asset_folder配置属性为true\n\n这是正常的配置流程，但是！！！！！！！！！！！！！！！！！！\n==注：==这里hexo-asset-images有个bug，就是你打包笔记之后会发现他会直接把你的对应相对路径的图片文件夹名称给忽略掉。\n比如，我写一个笔记，Test.md，然后我在里面粘贴了一张xxx.png图片，那么通过我之前Typora的设置，那么他会自动在与笔记文件同级目录下新建一个与文件名称相同的目录并在这个目录下再新建一个images文件夹（也就是Test/images/xxx.png)然后会自动把我刚才复制的图片自动复制存到这个目录下面，并且这个md的引用路径也是相对于这个图片的相对路径。但是我们在编译的时候这个插件会忽略掉这个Test路径变成类似于images\\xxx.png的路径，而且我们md内的引用路径并没有变，路径引用任然是Test/images/xxx.png所以，当我们用网站打开时任然无法查看（不得不说，这插件设计的确实太不合理了）。\n所以，为了解决这个问题，只能改插件的源码。\n首先找到 /node_modules/hexo-asset-image/index.js 这个文件：\n\n然后将它的内容替换为如下内容：\n'use strict';var cheerio = require('cheerio');     // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {  return str.split(m, i).join(m).length;}     var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data){  var config = hexo.config;  if(config.post_asset_folder){       var link = data.permalink;   if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)      var beginPos = getPosition(link, '/', 1) + 1;   else      var beginPos = getPosition(link, '/', 3) + 1;   // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".   var endPos = link.lastIndexOf('/') + 1;    link = link.substring(beginPos, endPos);         var toprocess = ['excerpt', 'more', 'content'];    for(var i = 0; i &lt; toprocess.length; i++){      var key = toprocess[i];            var $ = cheerio.load(data[key], {        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      });           $('img').each(function(){       if ($(this).attr('src')){           // For windows style path, we replace '\\' to '/'.           var src = $(this).attr('src').replace('\\\\', '/');           if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp;              !/^\\s*\\//.test(src)) {             // For \"about\" page, the first part of \"src\" can't be removed.             // In addition, to support multi-level local directory.             var linkArray = link.split('/').filter(function(elem){               return elem != '';             });             var srcArray = src.split('/').filter(function(elem){               return elem != '' &amp;&amp; elem != '.';             });             if(srcArray.length &gt; 1)               srcArray.shift();             src = srcArray.join('/');             $(this).attr('src', config.root + link + src);             console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src);           }       }else{           console.info&amp;&amp;console.info(\"no src attr, skipped...\");           console.info&amp;&amp;console.info($(this));       }      });      data[key] = $.html();    }  }});\n\n如果没效果的话可以试试下面另一个改版：\n'use strict';var cheerio = require('cheerio');     // http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {  return str.split(m, i).join(m).length;}     var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data){  var config = hexo.config;  if(config.post_asset_folder){       var link = data.permalink;       console.info(\"debugTest-&gt; \"+link)   if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)      var beginPos = getPosition(link, '/', 1) + 1;   else      var beginPos = getPosition(link, '/', 3) + 1;   // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".   var endPos = link.lastIndexOf('/') + 1;    link = link.substring(beginPos, endPos);         var toprocess = ['excerpt', 'more', 'content'];    for(var i = 0; i &lt; toprocess.length; i++){      var key = toprocess[i];            var $ = cheerio.load(data[key], {        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      });           $('img').each(function(){       if ($(this).attr('src')){           // For windows style path, we replace '\\' to '/'.           var src = $(this).attr('src').replace('\\\\', '/');          //  console.info(src);                      var srcSplit=src.split('/images/');          if(srcSplit.length&lt;1) return; //如果图片文件长度不符合规范则直接return          //判断是否为本地src资源          if(srcSplit[srcSplit.length-1].includes(config.url.replaceAll(\"http://\",\"\").replaceAll(\"https://\",\"\"))){            $(this).attr('src', \"/\"+config.root + srcSplit[srcSplit.length-1].replaceAll(\"http://\",\"\").replaceAll(\"https://\",\"\"));            console.info&amp;&amp;console.info(\"update link as:--&gt;\"+\"/\"+srcSplit[srcSplit.length-1].replaceAll(\"http://\",\"\").replaceAll(\"https://\",\"\"));          }else{            $(this).attr('src', config.root + link +\"images/\"+ srcSplit[srcSplit.length-1]);            console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link +\"images/\"+ srcSplit[srcSplit.length-1]);          }       }else{           console.info&amp;&amp;console.info(\"no src attr, skipped...\");           console.info&amp;&amp;console.info($(this));       }      });      data[key] = $.html();    }  }});\n\n\n\n然后就可以解决无法同时在 Typora 和 Web 上看到图片的问题了。\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Kotliln基础","url":"/2023/12/21/learnnote/kotlin-xue-xi-bi-ji/kotlin-ji-chu/","content":"Kotlin基础\n","categories":["Kotlin"],"tags":["Kotlin"]},{"title":"ActiveMQ学习","url":"/2025/04/18/learnnote/java-xue-xi-bi-ji/activemq-xue-xi/","content":"ActiveMQ学习\n1.解压activemq压缩包，重命名文件夹\ntar -zxvf apache-activemq-5.11.1-bin.tar.gzmv apache-activemq-5.11.1 activemq\n\n2.防火墙开启activemq端口8161（管理平台端口）和61616（通讯端口）\nvi /etc/sysconfig/iptables-A INPUT -m state --state NEW -m tcp -p tcp --dport 8161 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 61616 -j ACCEPT\n\n3.启动、访问、查看状态和停止activemq服务\n./activemq/bin/activemq startwget 192.168.2.137:8161./activemq/bin/activemq status./activemq/bin/activemq stop\n\n二、activemq注册为系统服务，开启开机自启\n1.建立软连接\nln -s /usr/local/activemq/bin/activemq /etc/init.d/ #路径根据实际情况修改\n\n2.注册为系统服务\nvi /etc/init.d/activemq# 添加下面内容到/etc/init.d/activemq脚本chkconfig: 345 63 37description: Auto start ActiveMQJAVA_HOME=/usr/local/jdk1.8.0_144JAVA_CMD=java\n\n\n\n3.开启开机自启\nchkconfig activemq on\n\n4.可以以系统服务的方式启动、查看状态和停止服务\nservice activemq startservice activemq statusservice activemq stop\n\n","categories":["ActiveMQ"],"tags":["Java","ActiveMQ"]},{"title":"Deeplearning4j深度学习框架使用","url":"/2023/11/27/learnnote/java-xue-xi-bi-ji/deeplearning4j-shen-du-xue-xi-kuang-jia-shi-yong/","content":"Deeplearning4j深度学习框架使用\n","categories":["Java"],"tags":["Java","Deeplearning4j"]},{"title":"Docker学习","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/docker-xue-xi/","content":"第一章 Docker概述\n1.1虚拟化技术发展史\n在虚拟化技术出现之前，如果我们想搭建一台服务器，我们需要做如下的工作：\n\n购买一台硬件服务器；\n在硬件服务器上安装配置操作系统；\n在操作系统之上配置应用运行环境；\n部署并运行应用；\n\n这种方式的缺点就是：\n\n部署应用非常慢；\n需要花费的成本非常高（时间成本、服务器成本）；\n应用迁移麻烦；要将应用迁移，又得重复部署应用的过程：购买服务器-&gt;安装操作系统os-&gt;配置运行环境-&gt;部署应用\n\n所以，为了解决这个问题，后续出现 了虚拟化技术。\n1.2 虚拟化技术是什么？\n虚拟化（英文：Virtualization）是一种计算机资源管理技术，是将计算机的各种硬件资源，比如服务器、网络、CPU、内存及存储等，予以抽象和转换后呈现出一套新的硬件资源环境，在这一套新的硬件环境下可以安装我们的操作系统，部署我们的应用运行环境等，它打破计算机硬件资源不可切割的障碍，使我们可以比原本的计算机硬件资源结构更好的方式来组合应用这些资源。\n1.3  虚拟化技术的分类虚拟化一般分为：\n硬件虚拟化（hardware-level-virtualization）\n操作系统级虚拟化（os-level-virtualization）\n硬件级虚拟化  是运行在硬件上的虚拟化技术，它的核心技术是Hypervisor，Hypervisor是一种运行在基础物理服务器硬件之上的软件层，可以虚拟化硬件资源，例如cpu、硬盘、内存资源等。然后我们可以通过在虚拟化出来的资源之上安装操作系统，这也就是所谓的虚拟机。像VMWare，VirtualBox等都是使用该技术，我们经常使用的桌面版的虚拟机VMWare就是采用这种虚拟化技术。\n如下图所示：\n\n通过Hypervisor层，我们可以创建不同的虚拟机，并且每个虚拟机都是分离、独立的，这样一来，我们就可以在一台硬件服务器和本地操作系统之上虚拟化出多个服务器，用来部署我们的应用；\n1.4 虚拟化技术的优缺点虚拟化技术的优点：一台物理服务器可以虚拟化出多个虚拟的服务器，让计算机资源得以充分利用；\n虚拟化技术的缺点：1、每创建一个虚拟机的时候，都会创建一个操作系统，这个操作系统会占用很多资源，这样无疑大大添加了资源的消耗，当安装的虚拟机越多，资源消耗就越多。\n2、环境兼容问题，开发时的环境运行正常，部署到虚拟化环境测试则可能发生错误；\n1.5 容器技术的发展基于硬件级虚拟化技术的缺点和不足，后学又发展出来了另一种虚拟化技术，即操作系统级虚拟化技术；\n操作系统级虚拟化 是运行在操作系统之上的虚拟化技术，它模拟的是运行在一个操作系统上的多个不同进程，并将其封装在一个密闭的容器里面，该技术也称为容器化技术。\n在容器化技术领域，Docker是目前最流行的一种实现。Docker发布于2013年，Docker基于LXC技术，LXC是Linux平台上的容器化技术实现。\n注：LXC是Linux Container的简写，它是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程的资源，它与宿主机使用同一个内核，性能损耗小，这种技术是Linux提供的，但是直到Docker出世，该技术才被发挥出来。\n1.6 Docker的发展历史2010年，几个年轻人创业公司，起名为dotCloud，并且还获得了创业孵化器Y Combinator的支持，虽然dotCloud期间获得过一些融资，但随着IT巨头（微软、谷歌、亚马逊等）也杀入PaaS平台，dotCloud举步维艰。\n2013年，dotCloud创始人，28岁的Solomon Hykes做了一个艰难的决定：将dotCloud的核心引擎开源，这项引擎技术能够将Linux容器中的应用代码打包，轻松的在服务器之间迁移。\n然而这个基于LXC（Linux Container）技术的核心管理引擎开源后，让全世界的技术人员感到惊艳，感叹这一切太方便了……。也正是dotCloud的创始人这个艰难的孤注一掷的决定让所有的IT巨头们也为之一颤。\n\nDocker创始人Solomon Hykes（Docker之父）\n从2013年Docker开源开始，Docker技术风靡全球，于是dotCloud公司决定将Docker作为主要业务进行发展，并把公司改名为DockerInc，全身心投入到Docker的开发中，并于2014年8月，Docker宣布把PaaS（Platform as a Service，平台及服务）业务dotCloud出售给位于德国柏林的同样专注于即服务业务的提供商cloudControl，从此Docker可以轻装上阵，专注于Docker的研发。\n从2013年2月决定开源，到2013年3月20日发布Docker 0.1，只用了一个月时间。当前Docker的最新版本是18.03；\nDocker迅速成长，在2014年6月9日，Docker团队宣布Docker1.0,1.0版本标志着Docker平台已经足够成熟，并可以被应用到生产产品中（还提供了一些需要付费的支持选项）。\n一年的时间，使一个围绕着Docker的小型初创企业生态体系逐渐形成。Docker先后赢得了Google、微软、Amazon、VMware等IT巨头的青睐，他们纷纷表示将保证自己平台与Docker容器技术的兼容性。\n2016年2月29日，CloudControl公司在其官方微博中宣告即将破产，隶属于cloudControl公司的dotCloud也宣布将于2月29日关闭服务。作为Docker的前身，DotCloud目睹Docker的成长，成为云平台的一颗新星，而自己却力不从心，Docker的繁荣间接地导致Docker的前身dotCloud在PaaS平台的衰败，兴衰成败，令人唏嘘不已，这也许是颠覆式创新的经典案例。\n1.7 Docker是什么1、Docker是一个开源的应用容器引擎，它基于Google公司推出的Go语言实现，项目代码托管在GitHub上进行维护；\nhttps://github.com/docker/docker-ce\n2、Docker技术让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，打包好的容器可以发布到任何流行的Linux服务器上运行，这样就可以解决开发环境与运维环境不一致的问题，所以容器化技术解决了开发和运维之间的矛盾，让开发专注于开发，让运维专注于运维，不要被环境问题所打扰；\n3、Docker彻底释放了虚拟化的威力，极大降低了计算机资源供应的成本，Docker重新定义了程序开发测试、交付和部署过程，Docker提出了“构建一次，到处运行”的概念，让应用的开发、测试、部署和分发都变得前所未有的高效和轻松！\n4、Docker是一种轻量级的操作系统虚拟化解决方案，Docker的基础是Linux容器（LXC）技术，在LXC的基础上Docker进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作Docker的容器就像操作一个快速轻量级的虚拟机一样简单；Docker自开源后受到广泛的关注，Docker最早是基于Ubuntu开发的，但后续CnetOS、Debian、Fedora等主流的Linux操作系统都支持Docker；\n总结：简单地说，Docker是对软件和其依赖环境的标准化打包，应用之间相互隔离，共享一个OS Kernel（解决了资源浪费的问题），可以运行在很多主流操作系统上；\n但是也需要澄清一下，Docker本身不是容器，Docker只是管理容器的引擎。\n1.8 容器和虚拟机的区别容器是将代码和环境的关系打包在一起的一个集合，而虚拟机是在物理层面上，分出来的一个操作系统；\n多个容器可以运行在同一台物理服务器上，并共享一个操作系统的内核资源。多个虚拟机也可以运行在同一台机器上，但每个虚拟机都需要一个完整的操作系统；\n下图比较了Docker和传统虚拟化方式的不同之处：\n\n可见容器时在本地操作系统层面上实现虚拟化，直接复用本地主机的操作系统，不需要单独安装操作系统，而传统的虚拟化技术方式则需要单独安装每个虚拟机的操作系统。\n\n\n\n特性\n容器\n虚拟机\n\n\n\n启动\n秒级\n分钟级\n\n\n硬盘控件\n一般为几十MB\n一般为10GB\n\n\n性能\n接近原生\n弱于原生\n\n\n系统支持量\n单机支持上千个容器\n一般几十个\n\n\n操作系统\n与宿主机共享OS\n宿主机OS上运行虚拟机OS\n\n\n1.9为什么使用Docker作为一种新兴的虚拟化技术，Docker跟传统的虚拟化方式相比具有众多的优势。\n1、Docker容器的启动可以在秒级实现，这相比传统方式要快得多。\n2、Docker对系统资源的利用率很高，一台主机上可以同时运行数千个Docker容器。\n3、容器除了运行其中的应用外，基本不消耗额外的系统资源，使得应用的性能很高。传统虚拟机方式运行方式运行10个完全不同的应用可能我们会起10个虚拟机来部署，而Docker只需要启动10个隔离的应用即可。\n4、Docker可以更快速的交付和部署，大量地节约开发、测试、部署的时间，对开发者和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\n5、更高效的虚拟化，Docker容器的运行不需要额外的Hypervisor支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。\n6、更轻松的迁移和扩展，Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性可以让用户轻松地把一个应用程序从一个平台直接迁移到另一个平台。\n第二章 Docker环境搭建\n2.1 Docker的版本\nDocker从2013年3月20日发布Docker0.1，到现在已经发布了多个版本，从2017年3月开始docker在原来的基础上分为两个分支版本：Docker CE 和Docker EE。\nDocker CE即社区免费版，可永久免费使用；\nDocker EE 即企业版，功能更全，更强调安全，但需要付费使用；\n本课程介绍Docker CE版本，目前Docker版本为18.03\nDocker 官方网站：https://www.docker.com/\n2.2 Docker的安装首先，我们知道Docker并不是容器，它是一个管理容器的引擎。\n我们课程采用的Linux版本是CentOS7，学习Docker也更推荐在Linux环境下使用；\nDocker支持CentOS及以后的 版本；\nCentOS7系统可以直接通过yum进行安装：\n安装前可以查看一下系统是否已经安装了Docker：yum list installed | grep docker\n\n安装：yum install docker -y\n\n查看Docker版本（可用于查看是否安装成功）:docker -version (docker version,docker -v)\n\n卸载：yum remove docker -v\n\n\n\n2.3 Docker服务启动\n安装之后Docker服务；\n启动：systemctl start docker 或者  service docker start\n停止：systemctl stop docker 或者 service docker stop\n重启： systemctl restart docker 或者 service docker restart\n检查docker进程的运行状态：\nsystemctl status docker 或者 service docker status\n查看docker进程：ps -ef | grep docker\n2.4 Docker服务\ndocker info 查看docker系统信息\ndocker 查看所有的帮助信息\ndocker commond -help 查看某个commond命令的帮助信息。\n2.5 Docker使用初体验\n2.5.1 Docker的运行机制\n我们知道Docker并不是容器，而只是一个管理容器的引擎；\nDocker的底层运行原理：\nDocker服务启动-&gt;下载镜像-&gt;启动该镜像得到一个容器-&gt;容器里面运行着我们想要的程序；\n\n2.5.2 第一个Docker容器根据Docker的运行机制，我们将按照如下步骤运行第一个Docker容器；\n1、将Docker服务启动；\n2、下载一个镜像，Docker运行一个容器前需要本地存在有对应的镜像，如果镜像不存在本地，Docker会从镜像仓库下载（默认是Docker Hub公共注册服务器中的仓库https://hub.docker.com）。\n从docker hub官网搜索要使用的镜像，比如docker search tomcat进行搜索，然后下载所需要的镜像：\n下载镜像：docker pull tomcat\n\n运行镜像（前台运行）：docker run tomcat\n\n要后台运行，加参数 -d：docker run -d tomcat\n\n运行时并映射到对应Linux端口（前面为Linux端口，后面为镜像端口）docker run -d -p 8080:8080 tomcat\n\n\n\n显示本地已有的镜像：docker images\n\n在列出信息中，可以看到几个字段信息\nREPOSITORY：来自于 哪个仓库，比如 docker.io/tomcat\nTAG：镜像的标记，比如latest\nIMAGE ID：镜像的ID号（唯一）\nCRATED：创建时间\nSIZE：镜像大小\n3、启动下载下来的镜像得到一个容器：\n2.5.3 进入Docker容器\n进入容器：docker exec -it cef0d139bfd6 bash\n其中i表示交互式的，也就是保持标准输入流打开；\nt表示虚拟控制台，分配到一个虚拟控制台；\n退出容器：exit\n2.5.4 客户机访问容器\n从客户机上访问容器，需要有端口映射，docker容器默认采用桥接模式与宿主机通信，需要将宿主机的ip端口映射到容器的ip端口上；\n停止容器：docker stop 容器ID/名称\n启动容器：docker run -d -p 8080:8080 docker.io/tomcat 或者 41a54fe1f79d\n第三章 Docker核心组件\n3.1 Docker 架构\nDocker使用客户端-服务器（C/S）架构模式，使用远程 API 来管理和创建Docker容器。\n\nDocker容器通过Docker镜像来创建。\n镜像与容器的关系类似于面向对象编程中的类与对象的关系。\n\n\n\nDocker\n面向对象\n\n\n\n镜像\n类\n\n\n容器\n对象\n\n\n3.2 Docker 核心要素\nDocker包括三个核心要素\n镜像（Image）、容器（Container）、仓库（Repository）\n理解了这三个概念，就了解了Docker的整个 生命周期。\nDocker的运行离不开以上核心几个组件的支持，Docker的成功也是拜这几个组件所赐。\n有人会误以为，Docker就是容器，但Docker不是容器，而是管理容器的引擎。\n3.3 镜像\nDocker镜像就是一个只读的模板，可以用来创建Docker容器。\n例如：一个镜像可以包含一个完整的CentOS操作系统环境，里面仅安装了MySql或用户需要的其它应用程序。\nDocker提供了一个非常简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。\n3.3.2 镜像的组成结构\n镜像是由许多层的文件系统叠加构成的，最下面是一个引导文件系统bootfs，第二层是一个root文件系统rootfs，root文件系统通常是某种操作系统，比如centos、Ubuntu，在root文件系统之上又有很多层文件系统，这些文件系统叠加在一起，构成docker中的镜像；\n\n3.3.3 镜像的日常操作\n1、下载镜像，比如下载redis镜像：docker pull redis:latest\nredis是查询到的镜像名称，latest是镜像的标签tag\n安装一个镜像有两种方式，一种格式从官方镜像仓库下载，一种是自己通过dockerfile文件构建。\n如果有官方镜像，我们就不必自己用dockerfile文件构建了，除非官方没有才会自己去dockerfile文件构建；\n2、列出已经下载的镜像：docker images，或者 docker images redis\n3、运行镜像：docker run -d redis 其中-d表示在后台运行\n4、查看容器镜像的状态：docker ps\n通过 docker exec | a8584016f9b6(镜像ID) bash 进入 reids容器\n5、删除镜像 docker rmi redis:latest  注意是rmi，不是rm，rm是删除容器；\n6、强制删除镜像 docker rmi -f redis:latest\n7、查看本地所有的镜像 docker images\n3.4 容器\n3.4.1容器的最基本概念\n容器是从镜像创建的运行实例。它可以被启动、停止、删除。每个容器都是相互隔离的、保证安全平台。可以把看做一个简易版的Linux环境，包括root用户权限、进程控件、用户空间和网络空间和运行在其中的应用程序。\nDocker利用容器来运行引用，镜像是只读的 ，容器在启动的时候创建一层可写层作为最上层。  \n\n3.4.2 容器的日常操作启动容器有两种方式，一种是基于镜像创建一个容器并启动，另一个是将在终止状态的容器重新启动。\n通过镜像启动容器：docker run -d redis\n查看运行中的容器：docker ps\n查看所有的容器：docker ps -a\n停止容器：docker stop 容器id或容器名称\n开启容器：docker start 容器id或容器名称\n因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。\n删除容器：docker rm 容器id或容器名称\n删除容器时，容器必须是停止状态，否则会报错；\n进入容器：docker exec -it 容器id或容器名称 bash\n停止容器：docker stop 容器id或容器名称\n已经停止的容器，我们可以使用命令docker start 来启动。\n开启容器：docker start 容器id或容器名称\n还可以使用 docker inspect + 容器id或容器名称 查看容器的更多信息；\n停用全部运行中的容器：docker stop $(docker ps -q)\n删除全部容器：docker rm $(docker ps -aq)\n一条命令实现停用并删除容器：\ndocker stop $(docker ps -q) &amp; docker rm -f $(docker ps -aq)\n3.5 仓库\n3.5.1 仓库的基本概念仓库是集中存放镜像文件的场所，有时候会把仓库和仓库注册服务器（Registry）看做同一事务，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）；\n仓库分为公开仓库（Public）和私有仓库（Private）两种形式；\n最大的公开仓库是Docker Hub（https://hub.docker.com/)，存放了数量庞大的镜像供用户下载 ；\n当然，用户也可以在本地网络内创建一个私有仓库；\n当用户创建了一个自己的镜像之后就可以使用push命令将它上传到共有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上pull下来即可；\n注：Docker仓库的概念跟Git类似，注册服务器也类似于GitHub这样的托管服务；\n3.5.2 仓库的日常操作\n用户可通过docker search 命令来查找官方仓库中的镜像：\ndocker search rabbitmq\n\n可以看到返回了很多包含关键字的镜像，其中包括镜像名称、描述、星级（表示该镜像的受欢迎程度）、是否官方创建、是否自动创建；官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源的内容；\n根据是否是官方提供，可将镜像资源分为两类；\n一种是类似centos这样的基础镜像，被称为基础或根镜像。这些基础镜像是由Docker公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字；\n还有一种类型，比如tianon/centos镜像，它是由Docker的用户创建并维护的，往往带有用户名称前缀。可以通过前缀user_name/ 来指定使用某个用户提供的镜像，比如tianon用户；\n并利用docker pull命令来将它下载到本地：\ndocker pull rabbitmqdocker pull centos\n\n\n\n第四章 Docker使用示例\n4.1 Docker安装MySQL\n下载MySQL镜像：docker pull mysql:latest （安装的是最新的mysql8.0）docker run -p 3306:3306 -e MYSQL_DATABASE=workdb -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest\n\n其中-e是指定环境变量\n进入容器：docker exec -it 3e8bf7392b4e bash\n\n\n\n登录MySQL：mysql -u root -p\n\n\n\n修改密码：ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';\n\n\n\n授权远程登录访问：CREATE USER 'wkcto'@'%' IDENTIFIED WITH mysql_native_password BY '123456';GRANT ALL PRIVILEGES ON *.* TO  'wkcto'@'%';\n\n\n\n4.2 Docker安装Nginx\n下载Nginx镜像：docker pull nginxdocker run -p 80:80 -d nginx\n\n进入容器：docker exec -it 3e8bf7392b4e bash\n\n浏览器访问Nginx：http://192.168.80.201:80\nNginx部署静态网站：将Linux的文件拷贝到docker容器某个目录下：\ndocker cp root/test.html bf8a58328e18:/usr/share/nginx/html\n4.3 Docker安装Zookeeper\n下载Zookeepe镜像：docker pull zookeeperdocker run -p 2181:2181 -d zookeeper\n\n进入容器：docker exec -it 3e8bf7392b4e bash\n\n\n\n\n\n4.4 Docker 安装 ActiveMQ\n下载ActiveMQ镜像：docker pull webcenter/activemqdocker run -p 2181:2181 -d activemq\n\n\n\n进入容器 ：docker exec -it 3e8bg7392b4e bash\n\n\n\n\n\n第五章 Docker 自定义镜像\n5.1 认识 Dockerfile 文件\nDockerfile用于构建Docker镜像，Dockerfile文件是由一行行命令语句组成，基于这些命令既可以构建一个镜像，\n比如下面就是一个Dockerfile文件样例：\nFROM XXX/jdk:8MAINTAINER docker_userENV JAVA_HOME /usr/local/javaADD apache-tomcat-8.0.32.tar.gz /usr/local/RUN mv apache-tomcat-8.0.32 tomcat8EXPOSE 8080RUN chmod u+x /usr/local/tomcat/bin/*.shCMD /usr/local/tomcat8/bin/catalina.sh start\n\n\n\n\n\n\n\n5.2 Dockerfile 的基本结构\n一般的，Dockerfile分为四部分：\n基础镜像信息；\n维护者信息；\n镜像操作指令；\n容器启动时执行指令；\n5.3 Dockerfile 指令\nFROM格式为 FROM   或 FROM :\nDockerfile 文件的第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（每个镜像一次）；\nMAINTAINER格式为 MAINTAINER ，指定维护者信息；\nENV格式为 ENV  ，指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持；\nADD格式为 ADD  ；\n复制指定的到容器中的；\nEXPOSE格式为 EXPOSE  […]\n告诉Docker服务端容器暴露的端口号，供互联系统使用，在启动容器时需要通过 -p 映射端口，Docker主机会自动分配一个端口转发到指定的端口；\nWORKDIRWORKDIR 目录\n切换工作目录，没有则创建\nVOLUME格式为 [“Linux中的目录，注意一定要绝对路径”,”对应容器中的路径”]\n作用为创建一个匿名数据卷挂载点，就是映射linux的路径到容器路径使其共享可直接访问对应路径中的资源。（比如容器内生成的日志可以存放到对应挂载路径，这样即是容器退出其对应的日志文件还在）\nRUN格式为 RUN \nRUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像，\n当命令较长时可以使用  \\ 来换行；\nCMD指定启动容器时执行的命令，每个Dockerfile 只能有一条CMD命令。\n如果指定了多条命令，只有最后一条会被执行。\n如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。\n5.4 Dockerfile自定义镜像\n5.4.1 Dockerfile自定义JDK镜像\nFROM centos:latestMAINTAINER testADD jdk-8u271-linux-x64.tar.gz /usr/localENV JAVA_HOME /usr/local/jdk1.8.0_271ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV PATH $PATH:$JAVA_HOME/binCMD java -version\n\n构建镜像：\ndocker build -t test_jdk1.8.0_271 .\n\n运行镜像：\ndocker run -d 86ff367d5f1e\n\n\n\n\n\n5.1.2 自定义Tomcat镜像\n定义Dockerfile文件：\nFROM test_jdk1.8.0_271MAINTAINER testADD apache-tomcat-8.5.24.tar.gz/usr/local/ENV CATALINA_HOME /usr/local/apache-tomcat-8.5.24ENV PATH $PATH:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-8.5.24/bin/catalina.sh run\n\n构建镜像：\ndocker build -t test-tomcat-8.5.24 . #构建镜像，并且标签名称为test-tomcat-8.5.24\n\n运行镜像：\ndocker run -d -p 8080:8080 ab41b5f48256\n\n\n\n\n\n5.4.3 自定义MySQL镜像\n定义Dockerfile文件：\nFROM centos:centos6MAINTAINER testRUN yum install -y mysql-server mysqlRUN /etc/init.d/mysqld start &amp;&amp;\\mysql -e \"grant all privileges on *.* to 'root'@'%'identified by '123456' WITH GRANT OPTION ;\"&amp;&amp;\\mysql -e \"grant all privileges on *.* to 'root'@'localhost' identified by '123456' WITH GRANT OPTION ;\"&amp;&amp;\\mysql -uroot -p123456 -e \"show databases;\"EXPOSE 3306CMD /usr/bin/mysqld_safe\n\n构建镜像：\ndocker build -t test-mysql . #构建镜像，并且标签名称为test-mysql,这里的.代表的是Dockerfile所在路径为当前同级目录下\n\n运行镜像：\ndocker run -d -p 3306:3306 09ce279d92df\n\n\n\n\n\n5.4.4 自定义Redis镜像\n5.4.5 使用URL的Dockerfile创建镜像docker build github.com/creack/docker-firefox\n\n\n\n5.4.6 Docker Build相关参数说明docker build 命令用于使用 Dockerfile 创建镜像。\n语法docker build [OPTIONS] PATH | URL | -\n\nOPTIONS说明：\n\n**–build-arg=[] :**设置镜像创建时的变量；\n**–cpu-shares :**设置 cpu 使用权重；\n**–cpu-period :**限制 CPU CFS周期；\n**–cpu-quota :**限制 CPU CFS配额；\n**–cpuset-cpus :**指定使用的CPU id；\n**–cpuset-mems :**指定使用的内存 id；\n**–disable-content-trust :**忽略校验，默认开启；\n**-f :**指定要使用的Dockerfile路径；\n**–force-rm :**设置镜像过程中删除中间容器；\n**–isolation :**使用容器隔离技术；\n**–label=[] :**设置镜像使用的元数据；\n**-m :**设置内存最大值；\n**–memory-swap :**设置Swap的最大值为内存+swap，”-1”表示不限swap；\n**–no-cache :**创建镜像的过程不使用缓存；\n**–pull :**尝试去更新镜像的新版本；\n**–quiet, -q :**安静模式，成功后只输出镜像 ID；\n**–rm :**设置镜像成功后删除中间容器；\n**–shm-size :**设置/dev/shm的大小，默认值是64M；\n**–ulimit :**Ulimit配置。\n**–squash :**将 Dockerfile 中所有的操作压缩为一层。\n–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。\n–network: 默认 default。在构建期间设置RUN指令的网络模式\n\n实例使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。\ndocker build -t runoob/ubuntu:v1 .  #这里\n\n使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。\ndocker build github.com/creack/docker-firefox\n\n也可以通过 -f Dockerfile 文件的位置：\ndocker build -f /path/to/a/Dockerfile .\n\n在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：\ndocker build -t test/myapp .Sending build context to Docker daemon 2.048 kBError response from daemon: Unknown instruction: RUNCMD\n","categories":["Docker"],"tags":["Docker"]},{"title":"JDBC学习笔记","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/jdbc-xue-xi-bi-ji/","content":"JDBC学习笔记\n1.JDBC是什么？\nJava DataBase Connectivity（Java语言连接数据库）\n\n\n2.JDBC的本质是什么？\nJDBC是SUN公司制定的一套接口（interface）\njava.sql.*;（这个软件包下有很多接口）\n接口都有调用者和实现者。\n面向接口调用、面向接口写实现类，这都属于面向接口编程。\n为什么要面向接口编程？\n解耦合：降低程序的耦合度，提高程序的扩展能力。\n多态机制就是非常典型的：面向抽象编程。(不要面向具体编程)\n\n建议：Animal a = new Cat();Animal a = new Dog();//喂养的方法public void feed(Animal a){//面向父类幸型编程。        }//不建议：Dog d  = new Dog();Cat c = new Cat();\n\n思考：为什么SUN制定一套JDBC接口呢？\n因为每一个数据库的底层实现原理都不一样。\nOracle数据库有自己的原理。\nMySQL数据库也有自己的原理。\nMS SqlServer数据库也有自己的原理。\n…\n每一个数据库产品都有自己独特的实现原理。\n\n\n\n\n\n比如以下是SUN公司需要解决的驱动问题：\n//比如：如果是MySQL数据库厂家负责编写JDBC接口的实现类/*MySQL的数据库厂家 负责编写JDBC接口的实现类*/public class MySQL implements JDBC{ public void getConnection(){    System.out.println(\"连接MySQL数据库成功！\");}//实现类呗称为驱动。（MySQL驱动）//xxx.jar  当中有很多.class,都是对JDBC接口进行的实现。}\n\nJava程序员角色：\n/*Java程序员角色。不需要关心具体是哪个品牌的数据库，只需要面向JDBC接口写代码。面向接口编程，面向抽象编程，不要面向具体编程。*/public class JavaProgrammer{    public static void main(String[] args){        //JDBC jdbc = new MySQL();        //同时创建对象可以通过反射来机制实现。        Class c = Class.forName(\"MySQL\");        JDBC jdbc = (JDBC)c.newInstance();                //以下代码都是面向接口调用方法，不需要修改        jdbc.getConnection();    }}\n\n\nJDBC的本质到底是什么？\n\n就是一套接口。\n\n3.JDBC开发前的准备工作\n先从官网下载对应的驱动jar包，让后将其配置到环境变量classpath当中。\n以上的配置是针对于文本编辑器的方式开发，使用IDEA工具的时候，不需要配置以上的环境变量。\n\n4.JDBC编程六步（需要背会）第一步：   注册驱动（告诉Java程序，即将要连接的是哪个品牌的数      据库）\n第二步：   获取连接（表示JVM的进程和数据库进程之间的通道打开了，这属于进程之间的通信，重量级的，使用完之后一定要关闭通道。）\n第三步：   获取数据库操作对象（专门执行sql语句的对象）\n第四步：   执行SQL语句（DQL，DML…）\n第五步：   处理查询结果集（只有当第四步执行的是select语句的时候，才有这第五步处理查询结果集。）\n第六步：   释放资源（使用完资源之后一定要关闭资源。Java和数据库属于进程间的通信，开启之后一定要关闭。）\n实例：   import java.sql.*;import java.util.ResourceBundle;  public class ServerDAO {      Connection conn = null;    Statement stamt = null;    ResultSet rs = null;    public ServerDAO()    {        ResourceBundle bundle = ResourceBundle.getBundle(\"jdbc\");        String driver = bundle.getString(\"driver\");        String url = bundle.getString(\"url\");        String user = bundle.getString(\"user\");        String password = bundle.getString(\"password\");        //System.out.println(driver);            try {                //注册驱动            Class.forName(driver);            //获取数据库连接            conn = DriverManager.getConnection(url,user,password);            //获取数据库操作对象            stamt  = conn.createStatement();            System.out.println(\"服务器连接成功\");                //数据库语句            String sql = \"SELECT userName \\\"用户姓名\\\" FROM users\";                //查询使用exeuteQuery            rs = stamt.executeQuery(sql);            //增删改使用exeuteUpdate            }   catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (SQLException e) {            e.printStackTrace();        } finally {            try {                if(stamt!=null)                    stamt.close();                if(conn!=null)                    conn.close();                if( rs != null )                    rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        }}\n\n数据库查询：//返回的是一个查询集ResultSet rs = (Statement).executeQuery(\"查询语句\");\n\n数据库的增删改：//返回的int是有效改的数据条数int num = (Statement).executeUpdate(\"增删改语句\");\n\n数据库操作的软件能使用：Navicat\n数据库表的设计一般使用软件：PowerDesigner\n数据库的安全：\n注意SQL注入（安全隐患）解决安全隐患的方法：使用将Statement接口替换成Statement的子接口PreparedStatement（获取预编译的数据库操作对象）\nPreparedStatement在预编译期会进行一个安全检查所以相比Statement更安全。\n并且，PrepaStatement的运行效率也比Statement高！！！\nStatement是编译一次运行一次，PreparedStatement是预编译一次可以按模板运行N次。\n但是statement并不是一无用处，有些业务需要SQL注入的那么就需要Statement了，因为PrepareSta无法胜任其注入功能（比如表的数据排序语句）。\n实例：\nimport java.sql.*;import java.util.ResourceBundle;public class ServerDAO { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; public ServerDAO() {     ResourceBundle bundle = ResourceBundle.getBundle(\"jdbc\");     String driver = bundle.getString(\"driver\");     String url = bundle.getString(\"url\");     String user = bundle.getString(\"user\");     String password = bundle.getString(\"password\");     //System.out.println(driver);     try {         //注册驱动         Class.forName(driver);         //获取数据库连接         conn = DriverManager.getConnection(url,user,password);         System.out.println(\"服务器连接成功\");          //数据库语句         //SQL语句的框子，其中一个？，表示一个占位符，一个？将来接受一个“值”，注意：占位符不能使用单引号括起来否则会当成字符串         String sql = \"SELECT * FROM users where userName = ?\";         //获取数据库预编译操作对象         //程序执行到此处，会发送sql语句框子给DBMS，然后DBMS进行sql语句的预先编译         ps = conn.prepareStatement(sql);         //给占位符？传值（第一个问号下标是1，第二个问号下标是2，JDBC中所有下标从1开始）         ps.setString(1，);         //查询使用exeuteQuery         rs = ps.executeQuery();         //增删改使用exeuteUpdate     }   catch (ClassNotFoundException e) {         e.printStackTrace();     } catch (SQLException e) {         e.printStackTrace();     } finally {         try {             if(stamt!=null)                 stamt.close();             if(conn!=null)                 conn.close();             if( rs != null )                 rs.close();         } catch (SQLException e) {             e.printStackTrace();         }     } }}\n5.实践中函数的使用如何获取查询后的数据？\n通过学习我们知道查询时使用的是executerQuery()，而这个类有一个方法是next()，这个next()便可以遍历所有所查询到的数据，同时配合getString()【()里面可以是对应标签序号数字或者直接标签的名字也行】或者getInt()等这一些函数便可以得到相应的数据。\n\n6.优化1.如何提高数据库的指令运行速度？与服务器的交互大多数或者说最耗时的阶段便是与数据库建立连接的阶段，即Connection阶段。\n\n解决方案：\n使用数据库连接池技术，既在开始启动服务器时就开始初始化并提前建立好与数据库足够多的连接，这些连接将会存到“池”里面，这里的“池”可以使用HashMap集合来代替。\n\n\n\n","categories":["Java"],"tags":["Java","JDBC"]},{"title":"Java之Servlet学习","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/java-zhi-servlet-xue-xi-bi-ji/","content":"Java之Servlet学习\n流程图：\n\n一、Servlet规范介绍：1.servlet规范来自于JAVAEE规范中的一种2.作用：\n在servlet规范中，指定【动态资源文件】开发步骤\n\n在servlet规范中，指定Http服务器调用动态资源文件规则\n\n在servlet规范中，指定Http服务器管理动态资源文件实例对象规则\n\n\n注：第一个是给人看的，后两个是给Http服务器看的\n\n二、Servlet接口实现类：1.Servlet接口来自于Servlet规范下一个接口，这个接口存在Http服务器提供Jar包2.Tomcat服务器下lib文件夹中有一个servlet-api.jar存放Servlet接口（javax.servlet.Servlet)3.Servlet规范中任务，Http服务器能调用的【动态资源文件】必须是一个Servlet接口实现类\n列子：\nclass Student{    //不是动态资源文件，Tomcat无权调用}class Teacher implements Servlet{    //合法动态资源文件，Tomcat有权调用    Servlet obj = new Teacher();    obj.doGet();}\n\n\nTomcat根据Servlet规范调用Servlet接口实现类规则：\nTomcat有权创建Servlet接口实现实例对象\nServlet oneServlet = new OneServlet();\n\n\nTomcat根据实例对象调用service方法处理当前请求\noneServlet.service()\n\n\n三、Servlet接口实现类开发步骤：第一步：创建一个Java类让它继承于HttpServlet父类，使之成为一个Servlet接口实现类\nservlet接口类待实现的接口方法有：\n\ninit\ngetServlet\ngetServletConfig\ngetServletInfo\ndestory\nservice\n\n\n第二步：重写HttpServlet父类两个方法。doGet或者doPost\n浏览器—–get—-》 oneServlet.doGet()\n浏览器—–post—》 oneServlet.doPost()\npost可以使用getParameter(“key”)获取请求体参数对应值\n\n第三步：将Servlet接口实现类信息【注册】到Tomcat服务器【网站】—–&gt;【web】—&gt;【WEB-INF】—&gt;web.xml\n\n&lt;!--将Servlet接口实现类类路径地址交给Tomcat--&gt;&lt;servlet&gt;&lt;servlet-name&gt;mm&lt;/servlet-name&gt;&lt;!--申明一个变量存储servlet接口实现类类路径--&gt;&lt;servlet-class&gt;com.bjpowernode.controller.oneServlet&lt;/servlet-class&gt;&lt;!--申明servlet接口--&gt;&lt;/servlet&gt;\n\nTomcat String mm = \"com.bjpowernode.controller.oneServlet\";\n\n&lt;!--为了降低用户访问Servlet接口实现类难度，需要设置简短请求别名--&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;mm&lt;/servlet-name&gt;    &lt;url-pattern&gt;/one&lt;/url-pattern&gt;&lt;!--设置简短请求别名，别名在书写时必须以\"/\"为开头--&gt;&lt;/servlet-mapping&gt;\n\n如果现在浏览器向Tomcat索要OneServlet时地址\nhttp://localhost:8080/myWeb/one\n\n\n\n四、Servlet对象生命周期：1.网站中所有的Servlet接口实现类的实例对象，只能由Http服务器负责创建。开发人员不能手动创建Servlet接口实现类的实例2.在默认的情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时自动创建这个Servlet接口实现类的实例对象在手动配置情况下，要求Http服务器在启动时自动创建某个Servlet接口实现类的实例对象\n&lt;servlet&gt;    &lt;servlet-name&gt;mm&lt;/servlet-name&gt;&lt;!--声明一个变量存储servlet接口实现类类路径--&gt;    &lt;servlet-class&gt;com.bjpowernode.controller.OneServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;30&lt;/load-on-startup&gt;&lt;!--填写一个大于0的整数--&gt;&lt;/servlet&gt;\n\n3.在Http服务器运行期间，一个Servlet接口实现类只能被创建出一个实例对象4.在Http服务器关闭时刻，自动将网站中所有的Servlet对象进行销毁五、HttpServletResponse接口1.介绍:\nHttpServletResponse接口来自于Servlet规范中，在Tomcat中存在servlet-api.jar\nHttpServletResponse接口实现类由Http服务器负责提供\nHttpServletResponse接口负责将doGet/doPost方法执行结果写入到【响应体】交给浏览器\n开发人员习惯于将HttpServletResponse接口修饰的对象成为【响应对象】\n\n2.主要功能：\n将执行结果以二进制形式写入到【响应体】\n可以设置响应头中[content-type]属性值，从而控制浏览器使用对应编译器将响应体二进制数据编译为【文字，图片，视频，命令】\n设置响应头【location】属性，将一个请求地址赋值给location从而控制浏览器向指定服务器发送请求\n\n\n**注：**在doGet和doPost等请求接口实现类中HttpServletResponse对应的形参可以获取到输出流，可以是用时write和print方法进行输出，但是一般都使用print。我们在进行输出传递时一般会先使用content-type，在Java中即setContentType定义好输出给浏览器的信息时什么类型（注意要在获取输出流之前定义），默认为text类型。\nJava后端可以通过下面方法来远程控制浏览器请求行为【请求地址，请求方式，请求参数】，即设置响应头中的【location】属性\n输出流.sendRedirect(地址)\n\n六、HttpServletRequest接口1.介绍：\n\nHttpServletRequest接口来自于Servlet规范中，在Tomcat中存在的servlet-api.jar\nHttpServletRequest接口实现类由Http服务器负责提供\nHttpServletRequest接口负责在doGet/doPost方法运行时读取Http请求协议包中信息\n开发人员习惯于将HttpServletRequest接口修饰的对象成为【请求对象】\n\n2.作用：\n\n可以读取Http请求协议包中【请求行】信息\n可以读取保存在Http请求协议包中【请求头】或者【请求体】中请求参数信息\n可以代替浏览器向Http服务器申请资源文件调用\n\n\n//1.通过请求对象(request)，读取【请求行】中【url】信息String url = request.getRequestURL().toString();//2.通过请求对象(request)，读取【请求行】中【method】信息String method = request.getMethod();//3.通过请求对象(request)，读取【请求行】中uri信息/*URI：资源文件精准定位地址，在请求行中并没有URI这个属性。实际上是从URL中截取一个字符串，这个字符串格式\"/网站名/资源文件名\"URI用于让Http服务器对被访问的资源文件进行定位*/String uri = request.getRequestURI(); //substringSystem.out.println(\"URL\"+url);System.out.println(\"method\"+method);System.out.println(\"URI\"+uri);\n\n注：\n\n浏览器以GET方式发送请求，请求参数保存在【请求头】，在Http请求协议包到达Http服务器之后，第一件事就是进行解码。请求头二进制内容由Tomcat负责解码，Tomcat9.0默认使用【UTF-8】字符集，可以解释一切国家文字\n浏览器以POST方式发送请求，请求参数保存在【请求体】，在Http请求协议包Http服务器之后，第一件事就是进行解码。请求体二进制内容由当前请求对象(request)负责解码。request默认使用[ISO-8859-1]字符集，一个东欧语系字符集，此时如果请求体参数内容是中文，将无法解码只能得到乱码\n\n解决方案：\n\n在Post请求方式下，在读取请求体内容之前，应该通知请求对象使用UTF-8字符集对请求体内容进行一次重新解码\n&gt;//通知请求对象(request)，使用utf-8字符集对请求体二进制内容进行一次重新解码&gt;request.setCharacterEncoding(\"utf-8\");\n\n\n七、请求对象和响应对象生命周期1.在Http服务器接收到浏览器发送的【Http请求协议包】之后，自动为当前的【Http请求协议包】生成一个【请求对象】和一个【响应对象】\n2.在Http服务器调用doGet/doPost方法时，负责将【请求对象】和【响应对象】作为实参传递到方法，确保doGet/doPost正确执行\n3.在Http服务器准备推送Http响应协议包之前，负责将本次请求关联的【请求对象】和【响应对象】销毁\n\n即：【请求对象】和【响应对象】生命周期贯穿一次请求的处理过程中\n​       【请求对象】和【响应对象】相当于用户在服务端的代言人\n\n\n上图涉及到数据库操作，其中DAO是自己所写的一个数据库操作封装类，其主要是分层思想，详情下图：\n\n\n\n默认欢迎资源文件：\n\n用户发送了一个针对某个网站的【默认请求】时，此时由Http服务器自动从当前网站返回的资源文件\n正常请求：http://localhost:8080/myWeb/index.html\n默认请求：http://localhost:8080/myWeb\n\nTomcat对于默认欢迎资源文件定位规则：\n\n1.规则位置：Tomcat安装位置/conf/web.xml\n2.规则命令：\n&lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.htl&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;\n\n设置当前网站的默认欢迎资源文件规则\n\n1.规则位置：网站/web/WEB-INF/web.xml\n2.规则命令：\n网站设置自定义默认文件定位规则，此时Tomcat自带定位规则将失效\nServlet作为定义为默认文件时开头的“/”记得抹掉\n\n\n八、Http状态码\n1.介绍：\n\n由三位数字组成的一个符号。\n\nHttp服务器在推送响应包之前，根据本次请求处理情况将Http状态码写入到响应包中【状态行】上\n\n如果Http服务器针对本次请求，返回了对应的资源文件。\n\n\n通过Http状态码通知浏览器应该如何处理这个结果。\n\n通过Http状态码向浏览器解释不能提供服务的原因\n\n2.分类：\n\n组成 100-599；分为5个大类\n\n1XX：\n\n\n​\t\t最有特征 100：通知浏览器本次返回的资源文件并不是一个独立\t\t的资源文件，需要浏览器在接受响应包之后，，继续向Http服务\t\t器所要依赖的其他资源文件\n\n\n2XX：\n\n​\t\t最有特征200，通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器在接收到之后不需要索要其他关联文件。\n\n3XX：\n\n​\t\t最有特征302，通知浏览器本次返回的不是一个资源文件内容而是一个资源文件地址，需要浏览器根据这个地址自动发起请求来索要这个资源文件。\nresponse.sendRedirect(“资源文件地址”)写入到响应头中的location中，而这个行为会导致Tomcat将302状态码写入到状态行。\n\n4XX：\n\n\n404：通知浏览器，由于在服务端没有定位到被访问的资源文件因此无法提供帮助。\n405：通知浏览器，在服务端中已经定位到被访问的资源文件（Servlet），但是这个Servlet对于浏览器所采用的请求方式不能处理（就比如只写了doPost没有写doGet）\n\n\n5XX:\n\n\n500：通知浏览器，在服务端已经定位到被访问的资源文件（Servlet）这个Servlet可以接收浏览器采用请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败。\n\n\n\n九、多个Servlet之间调用规则：\n1.前提条件：\n\n某些来自浏览器发送请求，往往需要服务端中多个Servlet协同处理。但是浏览器一次只能访问一个Servlet，导致用户需要手动通过浏览器发起多次请求才能得到服务。这样增加用户获得服务难度，导致用户放弃访问当前网站。\n\n2.提高用户使用感受规则：\n\n无论本次请求涉及到多少个Servlet，用户只需要【手动】通知浏览器发起一次请求即可。\n\n3.多个Servlet之间调用规则：\n\n重定向解决方案\n请求转发解决方案\n\n\n\n十、重定向解决方案：\n1.工作原理：用户第一次通过【手动方式】通知浏览器访问OneServlet。oneServlet工作完毕后，将TwoServlet地址写入到响应头location属性中，导致Tomcat将302状态码写入到状态行。在浏览器接受到响应包之后，会读取到302状态。此时浏览器自动根据响应头location属性地址发起第二次请求，访问TwoServlet去完成请求中剩余任务\n2.实现命令：\nresponse.sendRedirect(“请求地址”)\n将地址写入到响应包中相应头中location属性\n3.特征：\n\n请求地址：\n既可以把当前网站内部的资源文件地址发送给浏览器（/网站名/资源名）\n也可以把其他 网站资源文件地址发送给浏览器（http://ip地址:端口号/网站名/资源文件）\n\n请求次数：\n浏览器至少发送两次请求，但是只有一次请求是用户手动发送。\n后续请求都是浏览器自动发送的。\n\n请求方式：\n重定向解决方案中，通过地址栏通知浏览器发起下一次请求，因此通过重定向解决方案调用的资源文件接收的请求方式一定是【GET】\n\n\n4.缺点：\n\n重定向解决方案需要在浏览器与服务器之间进行多次往返，大量时间消耗在往返次数上，增加用户等待服务时间。\n\n\n\n十一、请求转发解决方案：\n\n1.原理：用户第一次通过手动方式要求浏览器访问OneServlet。OneServler工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，申明调用TwoServlet。Tomcat在接收到这个请求后，自动调用TwoServlet来完成剩余任务。\n2.实现命令：请求对象代替浏览器向Tomcat发送请求\n//1.通过当前请求对象生成资源文件申请报告对象RequestDispatcher report = request.getRequestDispatcher(\"/资源文件名\");//一定要以\"/\"为开头，且不要写网站名！！！//2.将报告对象发送给Tomcatreport.forward(当前请求对象，当前相应对象)\n\n4.优点：\n\n无论本次请求涉及到多少个Servlet，用户只需要手动通过浏览器发送一次请求\nServlet之间调用发生在服务端计算机上，节省服务端与浏览器之间往返次数增加处理服务速度\n\n4.特征：\n\n请求次数：\n在请求转发过程中，浏览器只发送一次请求\n\n请求地址：\n只能向Tomcat服务器申请调用当前网站下资源文件地址\nrequest.getRequestDispathcer(“/资源文件名”)//不要写网站名\n\n请求方式：\n在请求转发过程中，浏览器只发送了一个Http请求协议包。\n参与本次请求的所有Servlet共享同一个请求协议包，因此这个Servlet接受的请求方式与浏览器发送的请求方式保持一直\n\n\n\n\n十二、多个Servlet之间数据共享实现方案：1.数据共享：OneServlet工作完毕后，将产生数据交给TwoServlet来使用\n2.Servlet规范中提供四个数据共享方案：\n\nServletContext接口\nCookie类\nHttpSession接口\nHttpServletRequest接口\n\n\n十三、ServletContext接口：1.介绍：\n1.来自于Servlet规范中一个接口。在Tomcat中锤子servlet-api.jar在Tomcat中负责提供这个接口实现类\n2.如果两个Servlet来自于同一个网站。彼此之间通过网站的ServletContext实例对象实现数据共享\n3.开发人员习惯于将ServletContext对象称为【全局作用域对象】\n\n2.工作原理：\n每一个网站都存在一个全局作用域对象。\n这个全局作用域对象【相当于】一个Map。\n在这个网站中OneServlet可以将一个数据存入到全局作用域对象，当前网站中其他Servlet此时都可以从全局作用域对象得到这个数据进行使用\n\n3.全局作用域对象生命周期\n\n在Http服务器启动过程中，自动为当前网站在内存中创建一个全局作用域对象\n在Http服务器运行期间时，一个网站只有一个全局作用域对象\n在Http服务器运行期间，全局作用域对象一直出于存活状态\n在Http服务器准备关闭时，负责将当前网站中全局作用域对象进行销毁处理\n\n全局作用域对象生命周期贯穿网站整个运行期间\n4.命令实现：【同一个网站】oneServlet将数据共享给TwoSerletOneServlet{    public void doGet(HttpServletRequest request,HttpServletResponse response){        //1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】        ServletContext application = request.getServletContext();        //2.将数据添加到全局作用域对象作为【共享数据】        application.setAttribute(\"key1\",数据);    }}\n\nTwoServlet{    public void doGet(HttpServletRequest request,HttpServletResponse response){        //1.通过【请求对象】向Tomcat索要当前网站中【全局作用域对象】        ServletContext application = request.getServletContext();        //2.从全局作用域对象得到指定关键字对应数据        Object 数据 = application.getAttribute(\"key1\");            }}\n\n\n\n十四、Cookie1.介绍：\n\nCookie来自于Servlet规范中一个工具类，存在于Tomcat提供servlet-api.jar中\n如果两个Servlet来自于同一个网站 ，并且为同一个浏览器/用户提供服务，此时借助于Cookie对象进行数据共享\nCookie一般来存放当前用户的私人数据，在共享数据的过程中提高服务质量\n在现实生活场景中，Cookie相当于用户在服务端得到的【会员卡】\n\n\n2.原理：\n用户通过浏览器第一次向MyWeb网站发送请求申请OneServlet。\nOneServlet在运行期间创建一个Cookie存储与当前用户相关数据\nOneServlet工作完毕后，【将Cookie写入到响应头】交还给当前浏览器。\n浏览器收到响应响应包之后，将Cookie存储在浏览器的缓存\n一段时间之后，用户通过【同一个浏览器】再次向【myWeb网站】发送请求申请TwoServlet时。【浏览器需要无条件的将myWeb网站之前推送过来的Cookie，写入到请求头】发送过去\n此时TwoServlet在运行时，就可以通过读取请求头中cookie中信息，得到OneServlet提供的共享数据\n\n\n3.实现命令：同一个网站OneServlet与TwoServlet借助于Cookie实现数据共享\nOneServlet{    public void doGet(HttpServletRequest , HttpServletResponse resp)        //1.创建一个cookie对象，保存共享数据（当前用户数据）        Cookie card = new Cookie();    /*    cookie相当于一个键值对    一个cookie中只能存放一个键值对    这个键值对的key与value只能是String    键值对中key不能是中文    */        //2.【发卡】将cookie写入到响应头，交给浏览器    resp.addCookie(card);    resp.addCookie(card1);}\n\n\nTwoServlet{    public void doGet( HttpServletRequest request,HttpServletResponse resp)    {        //1.调用请求对象从请求头得到浏览器返回的Cookie        Cookie cookieArray[] = request.getCookies();        //2.循环遍历数据得到每一个cookie的key与value        for(Cookie card : cook ){            card.getName();//读取key “key1”            card.getValue();//读取value “abc”            //提供较好的服务。。。。。。。。。        }            }}\n\n\n\n4.Cookie销毁时机：\n1.在默认情况下，Cookie对象存放在浏览器的缓存中。因此只要浏览器关闭，Cookie对象就被销毁掉\n2.在手动设置情况下，可以要求浏览器将接收的Cookie存放在客户端计算机上硬盘上，同时需要指定Cookie在硬盘上存活时间。在存活时间范围内，关闭浏览器关闭客户端计算机，关闭服务器，都不会导致Cookie被销毁。在存活事件到达时，Cookie自动从硬盘上被删除\ncookie.setMaxAge(60);//cookie在硬盘上存活1分钟\n\n\n十五、HttpSession接口：1.介绍：\nHttpSession接口来自于Servlet规范下一个接口。存在于Tomcat中servlet-api.jar\n其实现类由Http服务器提供。Tomcat提供实现类存在于servlet-api.jar\n\n如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，此时借助于HttpSession对象进行数据共享\n\n开发人员习惯于将HttpSession接口修饰对象称为【会话作用域对象】\n\n\n2.HttpSession与Cookie区别：【面试题】\n存储位置：一个在天上，一个在地上\nCookie：存放在客户端计算机（浏览器内存/硬盘）\nHttpSession：存放在服务端计算机内存\n\n\n数据类型：\nCookie对象存储共享数据类型只能是String\nHttpSession对象可以存储任意类型的共享数据Object\n\n\n数据数量：\n一个Cookie对象只能存储一个共享数据\nHttpSession使用map集合存储共享数据，所以可以存储任意数量共享数据\n\n\n参照物：\nCookie相当于客户在服务端【会员卡】\nHttpSession相当于客户在服务端【私人保险柜】\n\n\n\n3.命令实现：\n同一个网站(myWeb)下OneServlet将数据传递给TwoServlet\nOneServlet{public void doGet(HttpServletRequest request,HttpServletResponse response){//1.调用请求对象向Tomcat索要当前用户在服务端的私人储物柜HttpSession session = request.getSession();//设置session的存活时间为10秒    session.setMaxInactiveInterval(10);//2.将数据添加到用户私人储物柜session.setAttribute(\"key1\",共享数据);}}\n浏览器访问/myWeb中TwoServlet\nTwoServlet{public void doGet(HttpServletRequest request,HttpServletResponse response){//1.调用请求对象向Tomcat索要当前用户在服务端的四人储物柜HttpSession session = request.getSession();//2.从会话作用域对象得到OneServlet提供的共享数据Object 共享数据 = session.getAttribute(\"key1\");}}\n4.HttpSession与用户关联的原理图：\n5.HttpSession实现购物车原理图：\n6.getSession()与getSession(false)区别：\n\ngetSession()：如果当前用户在服务端已经拥有了自己的私人储物柜，要求Tomcat将这个私人储物柜进行返回，如果当前用户在服务端尚未拥有自己的私人储物柜则要求Tomcat为当前用户创建一个全新的私人储物柜。\n\ngetSession(false)：如果当前用户在服务端已经拥有了自己的私人储物柜，要求Tomcat将这个私人储物柜进行返回。如果当前用户在服务端尚未拥有自己的私人储物柜则此时Tomcat将返回null且不会创建一个新的私人储物柜。\n\n\n\n7.HttpSession销毁时机：\n\n用户与HttpSession关联时使用的Cookie只能存放在浏览器缓存中。\n在浏览器关闭时，意味着用户与他的HttpSession关系呗切断。\n由于Tomcat无法检测浏览器何时关闭，因此在浏览器关闭时并不会导致Tomcat将浏览器关联的HttpSession进行销毁\n为了解决这个问题，Tomcat为每一个HttpSession对象设置【空闲时间】，这个空闲时间默认30分钟，如果当前HttpSession对象空闲时间达到30分钟则此时Tomcat认为用户已经放弃了自己的HttpSession，此时Tomcat就会销毁掉这个HttpSession。\n\n\n8.HttpSession空闲时间手动设置：\n在当前网站/web/WEB-INF/web.xml\n&lt;session-config&gt;    &lt;!--当前网站中每一个session最大空闲时间为5分钟--&gt;    &lt;session-timeout&gt;5&lt;/session-timeout&gt;&lt;/session-config&gt;\n\n十六、HttpServletRequest接口实现数据共享：1.介绍：\n\n如果在同一个网站中，如果两个Servlet之间通过【请求转发】方式进行调用，彼此之间共享同一个请求协议包。而一个请求协议包只对应一个请求对象，因此servlet之间共享同一个请求对象，此时可以利用这个请求对象在两个Servlet之间实现数据共享。\n在请求对象实现Servlet之间数据共享功能时，开发人员将请求对象成为【请求作用域对象】\n\n\n2.命令实现：\nOneServlet通过请求转发申请调用TwoServlet时，需要给TwoServlet提供共享数据\nOneServlet{    public void doGet(HttpServletRequest req,HttpServletResponse response){        //1.将数据添加到【请求作用域对象】中attribute属性        req.setAttribute(\"key1\",数据);//数据类型可以是任意类型Object        //2.向Tomcat申请调用TwoServlet        req.getRequestDispatcher(\"/two\").forward(req,response);    }} \n\nTwoServlet{    public void doGet(HttpServletRequest req,HttpServletResponse response){            //从当前请求对象得到OneServlet写入到共享数据        Object 数据 = req.getAttribute(\"key1\");        }}\n\n\n\n十七、Servlet规范扩展———-监听器接口1.介绍：\n\n一组来自于Servlet规范下接口，共有8个接口。在Tomcat存在servlet-api.jar包\n监听器接口需要由开发人员亲自实现，Http服务器提供jar包并没有对应的实现类\n监听器接口用于监控【作用域对象生命周期变化时刻】以及【作用域对象共享数据变化时刻】\n\n\n2.作用域对象：\n\n在Servlet规范中，认为在服务端内存中可以在某些条件下为两个Servlet之间提供数据共享方案的对象，被称为【作用域对象】\n\nServlet规范下作用域对象：\nServletContext：全局作用域对象\nHttpSession：会话作用域对象\nHttpServletRequest：请求作用域对象\n\n\n\n3.监听器接口实现接口实现类开发规范：三步\n\n根据监听的实际情况，选择对应监听器接口进行实现\n重写监听器接口声明【监听事件处理方法】\n在web.xml文件将监听器接口实现类注册到Http服务器\n\n重写监听接口：\n\n在Tomcat中注册监听接口实现类：\n\n\n4.ServletContextListener接口：\n\n作用：\n通过这个接口合法的检测全局作用域对象被初始化时刻以及被销毁时刻\n\n监听事件处理方法：\npublic void contextInitlized()：在全局作用域对象被Http服务器初始化被调用\npublic void contextDestory()：在全局作用域对象被Http服务器销毁时候触发调用\n\n\n\n5.ServletContextAttributeListener接口：\n\n作用：\n通过这个接口合法的检测全局作用域对象共享数据变化时刻\n\n监听事件处理方法：\npublic void contextAdd()：在全局作用域对象添加共享数据\npublic void contextReplaced()：在全局作用域对象更新共享数据\npublic void contextRemove()：在全局作用域对象删除共享数据\n\n\n重写接口：\n\n注册监听接口实现类：\n\n\n6.全局作用域对象共享数据变化时刻：\nServletContext application = request.getServletContext();application.setAttribute(\"key1\",100);//新增共享数据application.setAttribute(\"key1\",200);//更新共享数据application.removeAttribute(\"key1\");//删除共享数据\n\n7.服务器与数据库之间通信的优化：在网站后端中，数据库的操作其获取连接数据库耗时长（Connection），所以可以在服务器启动的时候就创建一个连接池。\n\n十八、Servlet规范扩展———Filter接口（过滤器接口）1.介绍：\n\n来自于Servlet规范下接口，在Tomcat中存在于servlet-api.jar包\nFilter接口实现类由开发人员负责提供，Http服务器不负责任提供\nFilter接口在Http服务器调用资源文件之前，对Http服务器进行拦截\n\n\n2.具体作用：\n\n拦截Http服务器，帮助Http服务器检测当前请求合法性\n拦截Http服务器，对当前请求进行增强操作\n\n\n3.Filter接口实现类开发步骤：三步\n\n创建一个Java类实现Filter接口\n重写Filter接口中doFilter方法\nweb.xml将过滤器接口实现类注册到Http服务器\n\n\n4.Filter基础使用例子\n使用：\n\n在web.xml注册：\n\n\n5.Filter拦截地址格式：\n\n命令格式：\n&lt;filter-mappint&gt;    &lt;filter-mapping&gt;oneFilter&lt;/filter-mapping&gt;    &lt;url-pattern&gt;拦截地址&lt;/url-pattern&gt;&lt;/filter-mappint&gt;\n\n命令作用：\n拦截地址通知Tomcat在调用何种资源文件之前需要调用OneFilter过滤进行拦截\n\n要求Tomcat在调用某一个具体文件之前，来调用OneFilter拦截，例：\n/img/mm.jpg\n\n要求Tomcat在调用某一个文件夹下所有的资源文件之前，来调用OneFilter拦截，例：\n/img/*\n\n要求Tomcat在调用任意文件夹下某种类型文件之前，来调用OneFilter拦截，例：\n*.jpg\n\n要求Tomcat在调用网站中任意文件时，来调用OneFilter拦截，例：\n/*\n\n\n\n6.拦截恶意访问流程图：\n\n\n互联网通信流程图：\n\n\n\n","categories":["Java"],"tags":["Java","Servlet"]},{"title":"SpringMVC简介","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/java-zhi-springmvc-xue-xi-bi-ji/","content":"SpringMVC简介1.SpringMVC概述\nSpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于SpringFrameWork的后续产品，已经融合在Spring Web Flow中。\nSpringMVC已经成为目前最主流的MVC框架之一，并且随着Spring3.0的发布，全面超越Struts2，成为最优秀的MVC框架。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无需实现任何接口。同时它还支持RESTful编程风格的请求。\n\n1.1.基于MVC架构\n基于MVC架构，功能分工明确。解耦合。\nM：Modle（模型）\nV：View（视图）\nC：Controller（控制器）\n\n1.2.容易理解，上手快，使用简单\n就可以开发一个注解的SpringMVC项目，SpringMVC也是轻量级的，jar很小。不依赖的特定的接口和类。\n\n1.3.作为Spring框架一部分，能够使用Spring的IOC和AOP\n方便整合Strtus，MyBatis，Hiberate，JPA等其他框架。\n\n2.什么是SpringMVC\n他是基于MVC开发模式的架构，用来优化控制器，它是Spring家族的一员，它也具备IOC和AOP。\n\n3.什么是MVC\n它是一种开发模式，它是模型视图控制器的简称，所有的web应用都是基于MVC开发。\nM：模型层，宝行实体类，业务逻辑层，数据访问层。\nV：视图层，html，JavaScript，Vue等都是视图层，用来显现数据\nC：控制器，它是用来接收客户端的请求，并返回响应到客户端的组件，Servlet就是组件。\n\n4.SSM架构1.Spring框架作用\n整合SpringMVC和MyBatis，解耦合\n\n2.SpringMVC框架作用\n优化控制器，比如Servlet、action\n\n3.MyBatis框架作用\n优化数据访问层，比如优化JDBC数据库连接，并且有自带的数据库连接池\n\n5.SSH架构\nSpring\nStruts2\nHibernate\n\n6.SpringMVC框架的优点\n轻量级，基于MVC的架构\n易于上手，容易理解，功能强大\n它具备IOC和AOP\n完全基于注解开发\n\n\n\n请求（client）经过顺序：\nclient——》tomcat——》web.xml——》springmvc——》controller——》service——》mapper——》db\n\n6.2.SpringMVC执行的流程\n\n\n7.基于注解的SpringMVC框架开发的步骤\n新建项目，选择webapp模板。\n\n修改目录，添加缺失的test，java，resources（两套），并修改目录属性\n\n\n\n\n修改pom.xml文件，添加SpringMVC的依赖，添加Servlet的依赖\n\n\n\n\n\n添加SpringMVC.xml配置文件，指定包扫描（因为要基于注解开发），添加视图解析器。\n\n\n\n\n删除web.xml文件，新建web.xml\n\n在web.xml文件中注册SpringMVC框架（所有的web请求都是基于servlet的）\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns,jcp.org/xml/ns/javaee/web-app_4_0.xsd\"         version=\"4.0\"&gt;   &lt;!--注册SpringMVC框架--&gt;    &lt;servlet&gt;    \t&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;        \t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;    \t&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;!--\t\t指定拦截什么样的请求\t\thttp://localhost:8080/one\t\thttp://localhost:8080/index.jsp\t\thttp://localhost:8080/demo.action     \t&lt;a href=\"${pageContext.request.contextPath}/demo.action\"&gt;发访问服务器&lt;/a&gt;\t\t--&gt;        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;/web-app&gt;\n\n\n\n在webapp目录下新建admin目录，在admin目录下新建main.jsp页面，删除index.jsp页面，并新建，发送请求给服务器\n\n开发控制器（Servlet），它是一个普通的类。\n\n@Controller //交给Spring去创建public class DemoAction{    /**    以前的Servlet的规范    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException,IOException {}    action中所有的功能实现都是由方法来完成的    action方法的规范    1)访问权限是public    2)方法的返回值任意    3)方法名称任意    4)方法可以没有参数，如果有可是任意类型    5)要使用@RequestMapping注解来申明一个访问的路径（名称）*/        @RequestMapping(\"/demo\")    public String demo(){        System.out.println(\"服务器被访问到了\");        return \"main\";  //可以直接跳到/admin/main.jsp页面上    }    }\n\n\n\n添加tomcat进行测试功能\n\n\n8.分析web请求1.web请求执行的流程\n​                                               核心处理器\nindex.jsp&lt;——————-&gt;DispatcherServlet&lt;———————&gt;SpringMVC的处理器是一个普通的方法\none.jsp&lt;——————-&gt;DispatcherServlet&lt;———————&gt;SpringMVC的处理器是一个普通的方法\nDispatcherServlet要在web.xml文件中注册才可用。\n\n5.@RequestMapping注解详解\n此注解就是来映射服务器访问的路径。\n\n此注解可加在方法上，是为此方法注册一个可以访问的名称（路径）\n\n\n\n@RequestMapping(\"/demo\")public String demo(){    System.out.println(\"服务器被访问到了......\");    return \"main\"; //可以直接跳到/admin/main.jsp页面上}&lt;a href=\"${pageContext.request.contextPath}/demo.action\"&gt;服务器访问&lt;/a&gt;\n\n此注解可以加在类上，相当于是包名（虚拟路径） ,区分不同类中相同的action的名称\n\n\n那么如果想要访问这个demo的路径将会变为…/user/demo……..\n\n\n此注解可区分get请求和post请求\n\n\n\n@Controllerpublic class ReqAction { @RequestMapping(value = \"/req\",method = RequestMethod.GET) public String req(){     System.out.println(\"我是处理get请求的......\");     return \"main\"; } @RequestMapping(value = \"/req\" , method = RequestMethod.POST) public String req1(){     System.out.println(\"我是处理post请求的......\");     return \"main\"; }}\n\n带参数的post请求：\n@RequestMapping(\"/one\")public String one(String mynme,int age/*自动注入，并且类型转换*/){    System.out.println(\"myname=\"+myname+\",age=\"+(age+100));    return \"main\";}/*对象封装提交数据\t在提交请求中，保证请求参数的名称与实体类中成员变量的名称一致，则可以自动创建对象，则可以自动提交数据，自动类型转换，自动封装数据到对象中。\t实体类中：\tpublic class Users{\t\tprivate String name;\t\tprivate int age;\t\t......\t}\t页面：\t&lt;form action=\"${pageContext.request.contextPath}/two.action\" method=\"post\"&gt;\t\t姓名：&lt;input name=\"name\"&gt;&lt;br&gt;\t\t年龄：&lt;input name=\"age\"&gt;&lt;br&gt;\t\t&lt;input type=\"submit\" value=\"提交\"&gt;\t&lt;/form&gt;*/action:@RequestMapping(\"/two\")public String two(Users u/*这是一个自定义的实体类，前端的参数会根据类中属性变量名注入进去*/){    System.out.println(u);    return \"main\";}//动态占位符解析/*仅限于超链接或地址栏提交数据。它是一杠一值，一杠一个大括号，使用注解@PathVariable来解析。*/@RequestMapping(\"/three/{name}/{age}\")public String three(    @PathVariable  ==&gt;专门解析路径中的请求参数    String name,    @PathVariable    int age){    System.out.println(\"myname=\"+myname+\",age=\"+(age+100));    return \"main\";}/*4)映射名称不一致\t提交请求参数与action方法的形参的名称不一致，使用注解@RequestParam来解析\t姓名：&lt;input name=\"name\"&gt;&lt;br&gt;\t年龄：&lt;input name=\"age\"&gt;&lt;br&gt;*/@RequestMapping(\"/four\")public string four(    @RequestParam(\"uname\") ==&gt;专门用来解决名称不一致的问题    String name,     @RequestParam(\"uage\")    int age){        return \"main\";}/*5)手工提取数据*/@RequestMapping(\"/five\")public String five(HttpServletRequest request){    String name = request.getParameter(\"name\");    int age = Integer.parseInt(request.getParameter(\"age\"));        return \"main\";}\n中文乱码解决方法​\t配置过滤器：\n\n\n\n8.action方法的返回值\nString：客户端资源的地址，自动凭借前缀和后缀。还可以屏蔽自动拼接字符串，可以指定返回的路径。\nObject：返回JSON格式的对象。自动将对象或集合转为JSON。使用的Jackson工具进行转换，必须要添加Jackson依赖。一般用于Ajax请求。\nvoid：无返回值，一般用于Ajax请求。\n基本数据类型，用于Ajax请求。\nModelAndView：返回数据和视图对象，现在用的很少。\n\n9.完成Ajax请求访问服务器，返回学生集合。\n添加Jackson依赖\n在webapp目录下新建js目录，添加jQuery函数库\n在index.jsp页面上导入函数库\n在action上添加注解@ResponseBody，用来处理Ajax请求\n在springmvc.xml文件中添加注解驱动&lt;mvc:annotationdriven /&gt;，它用来解析@ResponseBody注解\n\n==因为是处理的是Ajax请求，所以不用添加视图解析器==\n\nJava代码：\n&gt;@Controller&gt;public class StudentListAction{   @RequestMapping(\"/list\")   @ResponseBody  //解析Ajax请求，必须要在springmvc.xml文件中添加注解驱动   public List&lt;Student&gt; list(){       List&lt;Student&gt; list = new Student(\"张三\",23);       Student stu1 = new Student(\"张三\",23);       Student stu2 = new Student(\"李四\",24);       Student stu3 = new Student(\"王五\",25);       list.add(stu1);       list.add(stu2);       list.add(stu3);              return list;          }&gt;}\n\n注意在springmvc配置文件当中添加注解驱动\n\n\n10.请求跳转\nJumpAction.java：\n@RequestMapping(\"/one\")public String one(){ System.out.println(\"这是请求转发页面跳转......\"); return \"main\"; //默认是请求转发，使用视图解析器凭借前缀后缀进行页面跳转}@RequestMapping(\"/two\")public String two(){ System.out.println(\"这是请求转发action跳转......\");    //forward:\t这组字符串可以屏蔽前缀和后缀的拼接，实现请求转发跳转。 return \"forward:/other.action\"  //默认是请求转发，使用视图解析器拼接前缀后缀进行页面跳转}@RequestMapping(\"/three\")public String three(){    System.out.println(\"这是重定向页面......\");    //redirect:\t这组字符串可以屏蔽前缀和后缀的拼接，实现重定向跳转。    return \"redirect:/admin/main.jsp\";}@RequestMapping(\"/four\")public String four(){    System.out.println(\"这是重定向action......\");     //redirect:\t这组字符串可以屏蔽前缀和后缀的拼接，实现重定向跳转。    return \"redirect:/other.action\";}\n\nOtherAction.java：\n```## 11.SpringMVC默认的参数类型不需要去创建，直接拿来使用即可1. HttpServletRequest2. HttpServletResponse3. HttpSession4. Model5. Map6. ModelMap注意：Map,Model,ModelMap和request一样，都使用请求作用域进行传递，所以服务端的跳转必须是请求转发DataAction.java```java@RequestMapping(\"/data\")public String data(HttpServletRequest request,                  HttpServletResponse response,                  HttpSession session,                  Model model,                  Map map,                  ModelMap modelMap){    //做一个数据，传到.jsp页面上    Users u = new Users(\"张三\",22);    request,setAttribute(\"requestUsers\",u);    session.setAttribute(\"sessionUsres\",u);    model.addAttribute(\"modelUsers\",u);    map.put(\"mapUsers\",u);    modelMap.addAttribute(\"modelMaoUsers\",u);        return \"main\";}\n12.日期处理1. 日期的提交处理A. 单个日期处理   要使用注解@DateTimeFormat，此注解必须搭配springmvc.xml文件中的&lt;mvc:annotationdriven标签 &gt;\n\n@Controllerpublic class MyDateAction{        SimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd\");        @RequestMapping(\"/mydate\")       public String mydate(\t\t@DateTimeFormat(pattern=\"yyyy-MM-dd\")\t\tDate mydate){        System.out.println(mydate);        System.out.println(sf.format(mydate);        return \"show\";    }        }\n\n==一定要记得添加注解驱动！！！！==\n\n\nB. 类中全局日期处理注册一个注解，用来解析本类中所有的日期类型，自动转换。\n\n@Controllerpublic class MyDateAction{ SimpleDateFormat sf = new SimpleDateFormat(\"yyyy-MM-dd\");    //注册一个全局的日期处理注解，全局日期处理可以不用注册驱动    @InitBinder    public void initBinder(WebDataBinder dataBinder){        dataBinder.registerCustomEditor(Date.class,new CustomDateEditor(sf.true));    }     @RequestMapping(\"/mydate\")    public String mydate(\t\t@DateTimeFormat(pattern=\"yyyy-MM-dd\")\t\tDate mydate){     System.out.println(mydate);     System.out.println(sf.format(mydate);     return \"show\"; }}\n13.&lt;mvc:annotation-driven /&gt;标签的使用​\t\t&lt;mvc:annotation-driven /&gt;会自动注册两个bean，分别为\nDefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter。是springmvc为@controller分发请求所必须的。除了注册了这两个bean，还提供了很多支持。\n\n支持使用ConversionService实例对表单参数进行类型转换；\n支持使用@NumberFormat、@DateTimeFormat；\n注解完成数据类型的格式化；\n支持使用@RequestBody和@ResponseBody注解；\n静态资源的分流也使用这个标签；\n\n13.1.资源在WEB-INF目录下​\t此目录下的动态资源，不可直接访问，只能通过请求转发的方式进行\n14.SpringMVC的拦截器​\t针对请求和响应进行额外的处理，在请求和响应的过程中添加预处理，后处理和最终处理。\n拦截器执行原理：\n\n\n\n15.拦截器执行的时机\n\npreHandle()：在请求被处理之前进行操作，预处理。\npostHandle()：在请求被处理之后，但结果还没有渲染前进行操作，可以改变响应结果，后处理。\nafterCompletion：所有的请求响应结束后执行善后工作，清理对象，关闭资源。\n\n16.拦截器实现的两种方式\n\n继承HandlerInterceptorAdapter的父类\n实现HandlerInterceptor接口，实现的接口，推荐使用实现接口的方式。\n\n17.拦截器实现的步骤\n\n改造登录方法，在session中存储用户信息，用于进行权限验证。\n\n开发拦截器的功能，实现HandlerInterceptor接口，重写preHandle()方法\n\npublic class Loginlnterceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        if( request.getSession().getAttribute(\"users\") == null ) {//            此时就是没有登录，打回到登录页面            request.setAttribute(\"msg\",\"您还没有登录，请先去登录！\");            request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request,response);            return false;        }        return true;//放行    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);    }}\n\n\n\n在springmvc.xml文件中注册拦截器\n\n\n\n&lt;!--    注册拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;&lt;!--            映射要拦截的请求--&gt;            &lt;mvc:mapping path=\"/**\"/&gt;&lt;!--            设置放行的请求--&gt;            &lt;mvc:exclude-mapping path=\"/showLogin\"/&gt;            &lt;mvc:exclude-mapping path=\"/login\"/&gt;&lt;!--            配置具体的拦截器实现功能的类--&gt;            &lt;bean class=\"com.springmvc.study.interceptor.Loginlnterceptor\"&gt;&lt;/bean&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;\n\n\n18.SSM整合的步骤\n\n建库，建表\n新建Maven项目，选择webapp模板\n修改目录\n修改pom.xml文件（使用老师提供）\n添加jdbc.properties属性文件\n添加SqlMapConfig.xml文件（使用模板）\n添加applicationContext_mapper.xml文件（数据访问层的核心配置文件）\n添加applicationContext_service.xml文件（业务逻辑层的核心配置文件）\n添加springmvc.xml文件\n删除web.xml文件，新建，改名，设置中文编码，并注册springmvc框架，并注册Spring框架\n新建实体类user\n新建UserMapper.java接口\n新建UserMapper.xml实现增删改更查所有功能\n新建service接口和实现类\n新建测试类，完成所有功能的测试\n新建控制器，完成所有功能\n浏览器测试功能\n\n@CrossOrigin  //在服务器端支持跨域访问\n什么是跨域：\n\n跨域有多种，一种是跨端口访问，一种是跨IP地址访问，还有一种是跨服务器访问。\n\n@RestController  //如果本类中全部都是ajax请求，则使用此注解，方法上的@ResponseBody可不写\nElement UI\nnode.js：v12.16.2\nVue\n6.五种数据提交方式的优化\n散提交数据\n\n","categories":["Java","Spring"],"tags":["Java","SpringMVC"]},{"title":"Java之Spring框架学习笔记","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/java-zhi-spring-kuang-jia-xue-xi-bi-ji/","content":"Java之Spring框架学习笔记一、介绍：1.1.Spring是什么\nSpring是分层的JavaSE/EE应用full-stack轻量级开源框架，以IOC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核。\n提供了展现层SpringMVC和持久层SpringJDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的JavaEE企业应用开源框架。\n\n1.2.Spring的优势1)方便解耦，简化开发\n通过Spring提供的IOC容器，开源将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的多度耦合。\n用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，开源更专注于上层的应用。\n\n2)AOP编程的支持\n通过Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP实现的功能开源通过AOP轻松实现。\n\n3)声明式事务的支持\n可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式灵活的进行事务管理，提高开发效率和质量。\n\n4)方便程序的测试\n可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。\n\n5)方便集成各种优秀框架\nSpring对各种优秀框架（Struts、Hibemate、Hessian、Quartz等）的支持。\n\n6)降低JavaEE API的使用难度\nSpring对JavaEE API（JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。\n\n7)Java源码是经典学习范例\nSpring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。\n\n1.3.Spring的体系结构\n\n\n二、Spring快速入门2.1.Spring程序开发步骤1.导入Spring开发的基本包坐标：\n\n\n2.编写Dao接口和实现类\n\n\n\n3.创建Spring核心配置文件\n\n\n4.创建Spring配置文件中配置UserDaoImpI\n\n\n5.使用Spring的API获得Bean实例\n\n\n2.2.知识要点：Spring的开发步骤\n1.导入坐标\n2.创建Bean\n3.创建applicationContext.xml\n4.在配置文件中进行配置\n5.创建ApplicationContext对象getBean\n\n三、Spring配置文件3.1.Bean标签基本配置\n用于配置对象交由Spring来创建。\n默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。\n基本属性：\n\nid：Bean实例在Spring容器中的唯一标识\nclass：Bean的全限定名称\n\n\n3.2.Bean标签范围配置1)scope：指对象的作用范围，取值如下：\n\n\n2)当scope的取值为singleton时：\nBean的实例化个数：1个\nBean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例\nBean的生命周期：\n\n对象创建：当应用加载，创建容器时，对象就被创建了\n对象运行：只要容器在，对象一直活着\n对象销毁：当应用卸载，销毁容器时，对象就被销毁了\n\n\n3)当scope的取值为prototype时：\nBean的实例化个数：多个\nBean的实例化时机：当调用getBean()方法时实例化Bean\n\n对象创建：当使用对象，创建新的对象实例\n对象运行：只要对象在使用中，就一直活着\n对象销毁：当对象长时间不用时，被Java的垃圾回收器回收了\n\n\n即：\nsingleton：在ApplicationContext的时候就会创建对象，并且只会是一个对象，当使用getBean的时候引用的也是同一个对象。\nprototype：在ApplicationContext的时候并不会创建对象，只会在getBean的时候进行创建，并且每个getBean都会新生成一个对象。\n3.3.Bean生命周期配置\n\ninit-method：指定类中的初始化方法名称\ndestroy-method：指定类中销毁方法名称\n\n\n3.4.Bean实例化三种方式\n\n无参构造方法实例化\n工厂静态方法实例化\n工厂实例方法实例化\n\n\n3.5.Bean的依赖注入分析3.6.Bean的依赖注入概念\n依赖注入（Dependency Injection）：它是Spring框架核心IOC的具体实现。\n在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。\nIOC解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。\n那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。\n简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。\n\n3.7.Bean的依赖注入方式怎么将UserDao怎样注入到UserService内部呢？\n构造方法\nset方法\n\n1)有参构造注入\n\n\n2)set方法注入P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：\n\n首先需要引入P命名空间：\nxmlns:p=\"http://www.springframework.org/schema/p\"\n\n其次，需要修改注入方式：\n&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\" p:userDao-ref=\"userDao\"/&gt;\n\n\n\n3.8.Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，除了对象的引用考科一注入，普通数据类型，集合等都可以在容器中进行注入。\n注入数据的三种数据类型\n普通数据类型\n引用数据类型\n集合数据类型\n\n\n普通属性的注入：\n\nList类型注入：\nMap类型注入：\n\n3.9.引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载。\n&lt;import resource=\"applicationContext-xxx.xml\"/&gt;\n\n4.0.知识要点：Spring的重点配置\n&lt;bean&gt;标签    id属性:在容器中Bean实例的唯一标识，不允许重复    class属性:要实例化的Bean的全限定名    scope属性:Bean的作用范围，常用是SingLeton（默认）和prototype   &lt;property&gt;标签:属性注入        name属性:属性名称        value属性:注入的普通属性值        ref属性:注入的对象引用值        &lt;list&gt;标签        &lt;map&gt;标签            &lt;entry&gt;标签:这个是map使用的        &lt;properties&gt;标签            &lt;props&gt;这个是Properties使用的标签                &lt;prop&gt;props内的一个标签   &lt;constructor-arg&gt;标签&lt;import&gt;标签:导入其他的Spring的分文件\n\n\n","categories":["Java"],"tags":["Java","Spring"]},{"title":"Java分层思想","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/java-fen-ceng-si-xiang-bi-ji/","content":"Java分层思想\n结构图：\n\n从最常规的分层结构来说，系统层次从上到下依次为：\n\n表现层/UI层/界面层：主要是客户端的现实。\n服务层/业务层：直接为客户端提供的服务或功能。也是系统所能对外提供的功能。\n领域层：系统内的领域活动。\nDAO层：数据访问对象，通过领域实体对象来操作数据库。\n\n其中有些知道原则（精华）：\n1、上层总是依赖其下层，依赖关系不跨层。\n2、表现层除外，同一层之间方法不允许相互调用。这是实际开发中一些开发者容易范的错误！如果真是同一层之间存在方法调用，需要注意，这些调用都是一些上层不可见方法，比如一些工具方法等。\n3、一切从服务层出发，从系统需要提供的功能进行分析，确定Service接口中的方法。而不是从数据库的表出发，创建DAO，再创Domain，然后Service，这实际上是对系统分层的误解。\n4、系统最核心的设计就是将系统中的实体划分为领域模型。在此基础上设计数据的DAO层，并将这些活动暴露给服务层，服务层的实现依赖于领域活动。\n5、每个接口的职责范围明确有界。\nservice是业务层 \naction层即作为控制器\nDAO (Data Access Object) 数据访问\n1.JAVA中Action层, Service层 ，modle层 和 Dao层的功能区分？（下面所描述的service层就是biz） \n首先这是现在最基本的分层方式，结合了SSH架构。modle层就是对应的数据库表的实体类。\nDao层是使用了Hibernate连接数据库、操作数据库（增删改查）。\nService（biz）层：引用对应的Dao数据库操作，在这里可以编写自己需要的代码（比如简单的判断）。\nAction层：引用对应的Service（biz）层，在这里结合Struts的配置文件，跳转到指定的页面，当然也能接受页面传递的请求数据，也可以做些计算处理。\n以上的Hibernate，Struts，都需要注入到Spring的配置文件中，Spring把这些联系起来，成为一个整体。\n其他答案： \n　　一般java都是三层架构 数据访问层（dao） 业务逻辑层（biz 或者services） 界面层（ui） \naction 是业务层的一部分，是一个管理器 （总开关）（作用是取掉转）（取出前台界面的数据，调用biz方法，转发到下一个action或者页面）  \n模型成（model）一般是实体对象(把现实的的事物变成java中的对象)作用是一暂时存储数据方便持久化（存入数据库或者写入文件）而是 作为一个包裹封装一些数据来在不同的层以及各种java对象中使用  \ndao是数据访问层 就是用来访问数据库实现数据的持久化（把内存中的数据永久保存到硬盘中 其他答案： Action是一个控制器 Dao主要做数据库的交互工作 Modle 是模型 存放你的实体类 Biz 做相应的业务逻辑处理  \n**2.java中dao层和biz层的区别是什么？**\n首先解释面上意思，service是业务层，dao是数据访问层。 \n　　呵呵，这个问题我曾经也有过，记得以前刚学编程的时候，都是在service里直接调用dao，service里面就new一个dao类对象，调用，其他有意义的事没做，也不明白有这个有什么用，参加工作久了以后就会知道，业务才是工作中的重中之重。 \n　　我们都知道，标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦，解耦说的意思是你更改某一层代码，不会影响我其他层代码，如果你会像spring这样的框架，你会了解面向接口编程，表示层调用控制层，控制层调用业务层，业务层调用数据访问层。初期也许都是new对象去调用下一层，比如你在业务层new一个DAO类的对象，调用DAO类方法访问数据库，这样写是不对的，因为在业务层中是不应该含有具体对象，最多只能有引用，如果有具体对象存在，就耦合了。当那个对象不存在，我还要修改业务的代码，这不符合逻辑。好比主板上内存坏了，我换内存，没必要连主板一起换。我不用知道内存是哪家生产，不用知道多大容量，只要是内存都可以插上这个接口使用。这就是MVC的意义。 接下来说你感觉service的意义，其实因为你现在做东西分层次不是那么严格，在一个你们做东西业务本身也少，举个最简单的例子，你做一个分页的功能，数据1000条，你20条在一个页，你可以把这个功能写成工具类封装起来，然后在业务层里调用这个封装的方法，这才是业务里真正干得事，只要没访问数据库的，都要在业务里写。 \n　　再有不明白的追问，这是经验问题，呵呵，其实以后你就会懂。只是刚开始写的代码都是有个请求，我就去数据库取，业务几乎没有。 \n其他优秀答案： 比说你现在用的是SSH框架，做一个用户模块： \n (1)、假设现在你做这个功能会用到user表和权限表，那么你前台的页面访问action，action再去调用用户模块service，用户模块service判断你是操作user表还是权限表，如果你操作的是user表则service的实现类就去调用userDAO。如果是操作的是权限表则调用权限的DAO \n (2)、也就是说DAO一定是和数据库的每张表一一对应，而service则不是。明白的没？其实你一个项目一个service和一个DAO其实也一样可以操作数据库，只不过那要是表非常多，出问题了，那找起来多麻烦，而且太乱了 \n (3)、好处就是你的整个项目非常系统化，和数据库的表能一致，而且功能模块化，这样以后维护或者改错比较容易，性能也高一些简单的说DAO层是跟数据库打交道的，service层是处理一些业务流程的， 至于你说的为什么要用service层封装，我认为：一般来说，某一个程序的有些业务流程需要连接数据库，有些不需要与数据库打交道而直接是一些业务处理，这样就需要我们整合起来到service中去，这样可以起到一个更好的开发与维护的作用，同时也是MVC设计模式中model层功能的体现 \n3.java中的action是什么，DAO又是什么？ \nAction类 是[获得Form表单数据，并处理逻辑的类] \n　　DAO(Data Access Object) 是一个接口实现[通过SessionFactory获得操作数据库的会话，并实现一些基本的删除 添加 修改数据，在servlet中更实际化业务操作] \n**4. 什么是Pojo类？**\n简单的Java对象（Plain Old Java Objects）实际就是普通JavaBeans,使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。 \n5.pojo类和vo类分别是什么 \nvo有两种说法,一个是viewObject,一个是valueObject..\n　　就拿前者来说吧,它只负责封装页面传递过来的数据,这和PO有些不同..\n　　就拿struts1来说,ActionForm就是一个典型的viewObject. 而valueObject是页面与页面之间的传递时保存值的对象….\n　　总的来说,PO是最终传给BO以及BO传个DAO的东西,他很多情况下与我们真正的数据库表想对应.\n　　而viewObject是一个页面上提交后的数据,不一定完全和PO的属性相同…. \npojo与DTO的区别\national Mapping（对象关系映射）的缩写。通俗点讲，就是将对象与关系数据库绑定，用对象来表示关系数据。\n在O/R Mapping的世界里，有两个基本的也是重要的东东需要了解，即VO，PO。\n VO，值对象(Value Object)，PO，持久对象(Persisent Object)，它们是由一组属性和属性的get和set方法组成。从结构上看，它们并没有什么不同的地方。但从其意义和本质上来看是完全不同的。\n1．VO是用new关键字创建，由GC回收的。 \n PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 \n2．VO是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。 \n PO则是有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。\n3．VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 PO的属性是跟数据库表的字段一一对应的。\nPO对象需要实现序列化接口。\n-————————————————\nPO是持久化对象，它只是将物理数据实体的一种对象表示，为什么需要它？因为它可以简化我们对于物理实体的了解和耦合，简单地讲，可以简化对象的数据转换为物理数据的编程。VO是什么？它是值对象，准确地讲，它是业务对象，是生活在业务层的，是业务逻辑需要了解，需要使用的，再简单地讲，它是概念模型转换得到的。 \n首先说PO和VO吧，它们的关系应该是相互独立的，一个VO可以只是PO的部分，也可以是多个PO构成，同样也可以等同于一个PO（当然我是指他们的属性）。正因为这样，PO独立出来，数据持久层也就独立出来了，它不会受到任何业务的干涉。又正因为这样，业务逻辑层也独立开来，它不会受到数据持久层的影响，业务层关心的只是业务逻辑的处理，至于怎么存怎么读交给别人吧！不过，另外一点，如果我们没有使用数据持久层，或者说没有使用hibernate，那么PO和VO也可以是同一个东西，虽然这并不好。 \n-—————————————————\n**java的(PO,VO,TO,BO,DAO,POJO)解释**\nPO(persistant object) 持久对象 \n在o/r映射的时候出现的概念，如果没有o/r映射，没有这个概念存在了。通常对应数据模型(数据库),本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。 \n**VO(value object) 值对象**\n通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。 \nTO(Transfer Object)，数据传输对象\n在应用程序不同tie(关系)之间传输的对象 \nBO(business object) 业务对象 \n从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。 \nPOJO(plain ordinary java object) 简单无规则java对象\n纯的传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段及setter和getter方法！。 \n**DAO(data access object) 数据访问对象**\n是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO, 提供数据库的CRUD操作… \n**O/R Mapper 对象/关系 映射**\n定义好所有的mapping之后，这个O/R Mapper可以帮我们做很多的工作。通过这些mappings,这个O/R Mapper可以生成所有的关于对象保存，删除，读取的SQL语句，我们不再需要写那么多行的DAL代码了。 \n实体Model(实体模式) \nDAL(数据访问层) \nIDAL(接口层) \nDALFactory(类工厂) \nBLL(业务逻辑层) \nBOF   Business Object Framework    业务对象框架 \nSOA   Service Orient Architecture   面向服务的设计 \nEMF   Eclipse Model Framework     Eclipse建模框架\n-—————————————\nPO：全称是persistant object持久对象，最形象的理解就是一个PO就是数据库中的一条记录。好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。\nBO：全称是business object:业务对象。主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。比如一个简历，有教育经历、工作经历、社会关系等等。\n我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。建立一个对应简历的BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。VO ：\n**value object值对象**\nViewObject表现层对象\n主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。DTO ：\nData Transfer Object数据传输对象\n主要用于远程调用等需要大量传输对象的地方。\n比如我们一张表有100个字段，那么对应的PO就有100个属性。\n但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO\n**POJO ：**\nplain ordinary java object 简单java对象，个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。\n一个POJO持久化以后就是PO，直接用它传递、传递过程中就是DTO，直接用来对应表示层就是VO\n**DAO：**\ndata access object数据访问对象\n这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要。\n主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO\n-—————————————————————-\nPO:persistant object持久对象,可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作.                                            \n**VO:value object值对象。**通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递. \nDAO:data access object数据访问对象，此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作. \nBO:business object业务对象,封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作; POJO:plain ordinary java object 简单无规则java对象,我个人觉得它和其他不是一个层面上的东西,VO和PO应该都属于它。\n-——————————————–\nVO：值对象、视图对象\nPO：持久对象\nQO：查询对象\nDAO：数据访问对象\nDTO：数据传输对象\n-—————————————\nstruts 里的 ActionForm 就是个VO;\nhibernate里的 实体bean就是个PO,也叫POJO;\nhibernate里的Criteria 就相当于一个QO;\n在使用hibernate的时候我们会定义一些查询的方法,这些方法写在接口里,可以有不同的实现类.而这个接口就可以说是个DAO.\n个人认为QO和DTO差不多.\n-—————————————\nPO或叫BO，与数据库最接近的一层，是ORM中的O，基本上是数据库字段对应BO中的一个属性，为了同步与安全性考虑，最好只给DAO或者Service调用，而不要用packcode,backingBean,或者BO调。\nDAO，数据访问层，把VO，backingBean中的对象可以放入。。。。\nDTO，很少用，基本放入到DAO中，只是起到过渡的作用。\nQO，是把一些与持久性查询操作与语句放入。。\nVO，V层中用到的基本元素与方法等放其中。如果要其调用BO，则要做BO转换VO，VO转换BO操作。VO的好处是其页面的元素属性多于BO，可起到很好的作用。。。。\n-—————————————\n楼上的不对吧，PO是持久化对象。BO＝business object—业务对象。\nPO可以严格对应数据库表，一张表对映一个PO。\nBO则是业务逻辑处理对象，我的理解是它装满了业务逻辑的处理，在业务逻辑复杂的应用中有用。\nVO：value object值对象、view object视图对象\nPO：持久对象\nQO：查询对象\nDAO：数据访问对象——同时还有DAO模式\nDTO：数据传输对象——同时还有DTO模式\n总结\n以上就是本文关于Java分层概念详解的全部内容.\n","categories":["Java","软件工程"],"tags":["Java"]},{"title":"Java学习踩坑笔记","url":"/2023/07/19/learnnote/java-xue-xi-bi-ji/java-xue-xi-cai-keng-bi-ji/","content":"Java学习踩坑笔记\nJava如何在打包成jar包之后也能读取resource文件夹里面的文件？\n//获取文件的URLURL url = new HintUtil().getClass().getClassLoader().getResource(\"notice.wav\");InputStream resourceAsStream = new HintUtil().getClass().getResourceAsStream(\"/notice.wav\");BufferedInputStream myStream = new BufferedInputStream(resourceAsStream);as = AudioSystem.getAudioInputStream(myStream);\n\n\n这里提供了一个获取resource文件流的例子，亲测有效！！！。\n\n","categories":["Java"],"tags":["Java"]},{"title":"Java并发编程","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/java-bing-fa-bian-cheng-bi-ji/","content":"Java并发编程\n1、java-JUC快速入门\n1.1、JUC是什么？\nJUC是java.util.concurrent包的简称，在Java5.0天加，目的就是为了更好的支持高并发任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！\n\n1.2、进程与线程的区别：\n进程：一个运行中的程序的集合；一个进程往往可以包含多个线程，至少包含一个线程\nJava默认有几个线程？\n答案为两个，一个main线程，一个gc线程\n线程：线程（thread）是操作系统能够进行运算调度的最小单位。\n\n1.3、并发与并行的区别：\n并发（多线程操作同一个资源，交替执行）\nCPU一核，模拟出来多条线程，天下武功，唯快不破，快速交替。\n并行（多个人一起行走，同时进行）\nCPU多核，多个线程同时进行；使用线程池操作\n\n1.4、线程有六种状态：public enum State {    //新生    NEW,    //运行    RUNNABLE,    //堵塞    BLOCKED,    //等待    WAITING,    //超时等待    TIMED_WAITING,    //终止    TERMINATED}\n\n1.5、wait/sleep的区别：\n1、来自不同的类：wait来自object类，sleep来自线程类\n2、关于所的释放：wait会释放锁，sleep不会释放锁\n3、使用的范围不同：wait必须在同步代码块中，sleep可以在热河地方睡眠\n\n2、JUC的结构\n\n1、tools（工具类）：又叫信号量三组工具类，包含有：\n1）CountDownLatch（闭锁）是一个同步辅助类，在完成一组正在其他线程执行的操作之前，它允许一个或多个线程一直等待。\n2）CyclicBarrier（栅栏）之所以叫barrier，是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点，并且在释放等待线程后可重用。\n3）Semaphore（信号量）是一个计数信号量，他的本质是一个”共享锁“。信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。线程可以通过release()来释放它所持有的信号量许可证。\n2，executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：\n1）ScheduledExecutorService 解决那些需要任务重复执行的问题\n2）ScheduledThreadPoolExecutor 周期性任务调度的类实现\n3，atomic(原子性包)：是JDK提供的一组原子操作类，\n包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，他们的实现原理大多是持有它们各自的对应的类型变量value，而且被volatile关键字修饰了。这样来保证每次一个线程要使用它都会拿到最新的值。\n4，locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：\n1）ReentrantLock 它是独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。\n2）ReentrantReadWriteLock 它包括子类ReadLock和WriteLock。ReadLock是共享锁，而WriteLock是独占锁。\n3）LockSupport 它具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。\n5，collections(集合类)：主要是提供线程安全的集合， 比如：\n1）ArrayList对应的高并发类是CopyOnWriteArrayList，\n2）HashSet对应的高并发类是 CopyOnWriteArraySet，\n3）HashMap对应的高并发类是ConcurrentHashMap等等\n\n下面具体来学习一下多线程创建及使用方法：\n普通的线程代码，之前都是用thread或者runable接口的；\n具体实现如下：\npublic class demo01{    public static void main(String[] args){        ThreadDemo threadDemo = new ThreadDemo();        threadDemo.start();        new Thread(new ThreadDemo2()).start();    }}class ThreadDemo extends Thread{   @Override   public void run(){       System.out.println(\"普通线程已开启（继承Thread）\");   }}class ThreadDemo2 implements Runnable{    @Override    public void run(){        System.out.println(\"普通线程已开启（实现Runnable接口）\");    }}\n\n程序运行结果：\n\n普通线程已开启（继承Thread）普通线程已开启（实现Runnbale接口）\n\n\n3、Lock锁（重点）传统synchronized\nsynchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：\n\n修饰一个代码块，或修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；\n修饰一个方法，被修饰的方法称为同步方法，其作用的对象是调用这个方法的对象；\n修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；\n修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主要的对象是这个类的所有对象。\n\nLock接口\n\n随着这种添加的灵活性，额外的责任。没有结构化锁定会删除使用synchronized方法和语句发生的锁的自动释放。在大多数情况下，应使用以下惯用语：\nLock l = ...  l.lock(); //加锁try{       // access the resource protected by this lock} finally {       l.unlock();  //解锁}\n\n实现类\n\nreentrantLock构造器\npublic ReentrantLock(){    sync = new NonfairSync(); //无参默认非公平锁}public ReentrantLock(boolean fair){    sync = fair ? new FairSync() : new NonfairSync(); //传参为true为公平锁}\n\n公平锁：十分公平，可以先来后到，一定要排队\n非公平锁：释放不公平，可以插队（默认）\npublic class SaleTicketDemo {       public static void main(String[] args){           Ticket ticket = new Ticket();                   new Thread(()-&gt;{for(int i =0 ; i &lt; 40 ; ++i) ticket.sale();},\"a\").start();           new Thread(()-&gt;{for(int i =0 ; i &lt; 40 ; ++i) ticket.sale();},\"b\").start();           new Thread(()-&gt;{for(int i =0 ; i &lt; 40 ; ++i) ticket.sale();},\"c\").start();               }}class Ticket{       private int ticketNum = 30;       private Lock lock = new ReentrantLock();           public void sale() {           lock.lock();           try {               if(this.ticketNum &gt; 0) {                   System.out.println(Thread.currentThread().getName() + \"购得第\" + ticketNum-- + \"张票, 剩余\" + ticketNum + \"张票\");               }               Thread.sleep(10);           } catch (Exception e) {               e.printStackTrace();           } finally {               lock.unlock();           }       }}\nsynchronized和lock锁的区别\nsynchronized内置的java 关键字，Lock是一个java类\nsynchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁\nsynchronized会自动释放锁，Lock必须要手动释放锁！！如果不释放锁，会产生死锁\nsynchronized线程1（获得锁，阻塞），线程2（等待）；Lock锁就不一定会等待下去\nsynchronized可重入锁，不可以中断的，非公平的；Lock锁，可重入的，可以判断锁，非公平（可自己设置）\nsynchronized适合锁少量的代码同步问题，Lock适合锁大量的同步代码\n\n什么是可重入的？说明：所谓可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。\nsynchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。\n下面给个代码示例：\npublic class Son extends Father {    public static void main(String[] args) {        Son son = new Son();        son.sonDoSomeSthing();    }    public synchronized void sonDoSomeSthing(){        fatherDoSomeSthing();        System.out.println(\"son invoke sonDoSomeSthing\");    }    @Override    public synchronized void fatherDoSomeSthing() {        System.out.println(\"son invoke fatherDoSomeSthing\");        super.fatherDoSomeSthing();    }}public class Father {    public synchronized void fatherDoSomeSthing(){        System.out.println(\"father invoke fatherDoSomeSthing\");    }}\n\n执行结果：\n\n从上述代码示例可以看到调用的三个方法均得到了执行。当synchronized修饰普通方法时，使用的是对象锁，也就是Son对象。三个方法的锁都是Son对象。我们在子类中执行sonDoSomeSthing方法时，获取了Son对象锁，然后在sonDoSomeSthing时调用了重写父类的fatherDoSomeSthing方法，该方法的锁也是Son对象锁，然后在其中调用父类的fatherDoSomeSthing方法，该方法的锁也是Son对象锁。一个锁多次请求均调用成功，可见synchronized是可重入锁。\nsynchronized可重入锁的实现原理：synchronized底层是利用计算机系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态status。\n当一个线程请求方法时，会去检查锁状态。\n\n如果锁状态是0，代表该锁没有被占用，使用CAS操作获取锁，将线程ID替换成自己的线程ID。\n如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法；如果是非重入锁，就会进入阻塞队列等待。\n\n在释放锁时，\n\n如果是可重入锁的，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。\n如果非可重入锁的，线程退出方法，直接就会释放该锁。\n\nCondition准确的通知和唤醒线程\nCondition是一个接口，基本的方法就是await()和signal()方法；\nCondition依赖于Lock接口，生成一个Condition的基本代码是Lock.newCondition()\n调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Condition中的await()对应Object的wait()；\nCondition中signal()对应Object的notify();\nCondition中signalAll()对应Object的notifyAll()。\n\n\n\n对比项\nObject Monitor Methods\nCondition\n\n\n\n前置条件\n获取对象的锁\n调用Lock.lock()获取锁调用Lock.newCondition()获取Condition对象\n\n\n调用方法\n直接调用如：object.wait()\n直接调用如：condition.awati()\n\n\n等待队列个数\n一个\n多个\n\n\n当前线程释放锁并进入等待状态\n支持\n支持\n\n\n当前线程释放锁并进入等待状态，在等待状态中不响应中断\n不支持\n支持\n\n\n当前线程释放锁并进入超时等待状态\n支持\n支持\n\n\n当前线程释放锁并进入等待状态到将来的某个时间\n不支持\n支持\n\n\n唤醒等待队列中的一个线程\n支持\n支持\n\n\n唤醒等待队列中的全部线程\n支持\n支持\n\n\n\nCondition常见例子（生产者消费者模式（完成加一减一各一次操作）：import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class PC {    public static void main(String[] args) {        a a = new a();        new Thread(()-&gt;{            for (int i =0;i&lt;10;i++){                a.increment();            }        },\"A\").start();        new Thread(()-&gt;{            for (int i =0;i&lt;10;i++){                a.decrease();            }        },\"B\").start();    }}class  a{    public int nummber=0;    Lock lock = new ReentrantLock();    Condition condition = lock.newCondition();    public   void  increment(){        lock.lock();        try {            while(nummber!=0){                condition.await();            }            nummber++;            System.out.println(Thread.currentThread().getName()+\"&gt;&gt;\"+nummber);            condition.signalAll();        }        catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public  void decrease(){        lock.lock();        try {            while(nummber!=1){                condition.await();            }            nummber--;            System.out.println(Thread.currentThread().getName()+\"&gt;&gt;\"+nummber);            condition.signalAll();        }        catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}\n\n","categories":["Java","并发编程"],"tags":["Java","并发编程"]},{"title":"Java注解编程及AOP编程","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/java-jie-kou-bian-cheng-ji-aop-bian-cheng/","content":"Java注解编程及AOP编程\nJava注解（Annotation）又称Java标注，是JDK5.0引入的一种注释机制。\nJava语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。\n网上很多关于 Java Annotation 的文章，看得人眼花缭乱。Java Annotation 本来很简单的，结果说的人没说清楚；弄的看的人更加迷糊。\n我按照自己的思路，对 Annotation 进行了整理。理解 Annotation 的关键，是理解 Annotation 的语法和用法，对这些内容，我都进行了详细说明；理解 Annotation 的语法和用法之后，再看 Annotation 的框架图，可能有更深刻体会。废话就说这么多，下面开始对 Annotation 进行说明。若您发现文章中存在错误或不足的地方，希望您能指出！\n内置的注解\nJava定义了一套注解，共有7个，3个在java.lang中，剩下4个在java.lang.annotation中。\n作用在代码的注解是\n@Override：检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\n@Deprecated：标记过时方法。如果使用该方法，会报编译警告。\n@SuppressWarnings：指示编译器去忽略注解中申明的警告。\n\n作用在其他注解的注解（或者说 元注解）是\nRetention：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。\n@Documented：标记这些注解是否包含在用户文档中。\nTarget：标记这个注解应该是那种Java成员。\nInherited：标记这个注解是继承于哪个注解类（默认 注解并没有继承于任何子类）\n\n从Java7开始，额外添加了3个注解\n@SafeVarargs：Java7开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。\n@Functionallnterface：Java8开始支持，标识一个匿名函数或函数式接口。\n@Repeatable：Java8开始支持，标识某注解可以在同一个申明上使用多次。\n\nAnnotation架构\n\n从中，我们可以看出：\n\n1个Annotation和1个RetentionPolicy关联。\n\n可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。\n\n\n1个Annotation和1~n个ElementType关联。\n\n可以理解为：对于每1个Annotation对象，可以有若干个ElementType属性。\n\n\nAnnotation有许多实现类，包括：Deprecated，Documented，Inherited，Override等等。\n\nAnnotation的每个实现类，都“和1个RetentionPolicy关联”并且“和1~n个ElementType关联”。\n下面，我先介绍框架图的左半边（如下图），即Annotation，RetentionP，ElementType；然后在就Annotation的实现类进行举例说明。\n\n\n\n\nAnnotation组成部分\nJava Annotation的组成中，有3个非常重要的主干类。它们分别是：\nAnnotation.java：\npackage java.lang.annotation;public interface Annotation {    boolean equals(Object obj);        int hashCode();        String toString();        Class&lt;? extends Annotation&gt; annotationType();}\n\nElementType.java：\npackage java.lang.annotation;public enum ElementType {    TYPE, /*类、接口（包括注释类型）或枚举声明*/    FIELD, /*字段声明（包括枚举常量）*/    METHOD, /*方法声明*/    PARAMETER, /*参数声明*/    CONSTRUCTOR, /*构造方法声明*/    LOCAL_VARIABLE, /*局部变量声明*/    ANNOTATION_TYPE, /*注释类型申明*/    PACKAGE /*包声明*/}\n\nRetentionPolicy.java：\npackage java.lang.annotation;public enum RetentionPolicy {    SOURCE, /*Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了*/    CLASS, /*编译器Annotation存储于类对应de.class文件中。默认行为*/    RUNTIME /*编译器将Annotation存储于class文件中，并且可由JVM读入*/}\n\n说明：\n\nAnnotation就是个接口。\n\n“每1个Annotation”都与“1个RetentionPolicy”关联，并且与 “1～n 个 ElementType” 关联。可以通俗的理解为：每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。\n\n\nElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。\n\n“每 1 个 Annotation” 都与 “1～n 个 ElementType” 关联。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。\n\n\nRetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。\n\n\n\n“每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联。\n\na) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。\nb) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。\nc) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。\n\n这时，只需要记住”每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联，并且与 “1～n 个 ElementType” 关联。学完后面的内容之后，再回头看这些内容，会更容易理解。\n\njava 自带的 Annotation\n理解了上面的 3 个类的作用之后，我们接下来可以讲解 Annotation 实现类的语法定义了。\n1）Annotation通用定义\n@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation1 {    }\n\n说明：\n上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：\n(01) @interface\n使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。\n定义 Annotation 时，@interface 是必须的。\n注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。\n(02) @Documented\n类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。\n定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。\n(03) @Target(ElementType.TYPE)\n前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。\n@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。\n定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。\n(04) @Retention(RetentionPolicy.RUNTIME)\n前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。\n@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。\n定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。\n2）java自带的Annotation通过上面的示例，我们能理解：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型，@Retention 用来指定 Annotation 的策略。\n理解这一点之后，我们就很容易理解 java 中自带的 Annotation 的实现类，即 Annotation 架构图的右半边。如下图：\n\njava 常用的 Annotation：\n@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。@Documented  -- @Documented 所标注内容，可以出现在javadoc中。@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。\n\n由于 “@Deprecated 和 @Override” 类似，”@Documented, @Inherited, @Retention, @Target” 类似；下面，我们只对 @Deprecated, @Inherited, @SuppressWarnings 这 3 个 Annotation 进行说明。\n2.1) @Deprecated\n@Deprecated 的定义如下：\n@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Deprecated {}\n\n说明：\n\n(01) @interface – 它的用来修饰 Deprecated，意味着 Deprecated 实现了 java.lang.annotation.Annotation 接口；即 Deprecated 就是一个注解。 (02) @Documented – 它的作用是说明该注解能出现在 javadoc 中。\n(03) @Retention(RetentionPolicy.RUNTIME) – 它的作用是指定 Deprecated 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated 的信息保留在 .class 文件中，并且能被虚拟机读取。\n(04) @Deprecated 所标注内容，不再被建议使用。\n\n例如，若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息。示例如下:\n","categories":["Java"],"tags":["Java","AOP","注解编程"]},{"title":"Kafka使用","url":"/2025/02/15/learnnote/java-xue-xi-bi-ji/kafka-shi-yong/","content":"Kafka使用\n什么是 KafkaKafka 是由 Linkedin 公司开发的，它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台，它同时也是一款开源的基于发布订阅模式的消息引擎系统。\nKafka 的基本术语\n消息：Kafka 中的数据单元被称为消息，也被称为记录，可以把它看作数据库表中某一行的记录。\n\n批次：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。\n\n主题：消息的种类称为 主题（Topic）,可以说一个主题代表了一类消息。相当于是对消息进行分类。主题就像是数据库中的表。\n\n分区：主题可以被分为若干个分区（partition），同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性，单一主题中的分区有序，但是无法保证主题中所有的分区有序\n\n\n生产者：向主题发布消息的客户端应用程序称为生产者（Producer），生产者用于持续不断的向某个主题发送消息。\n\n消费者：订阅主题消息的客户端程序称为消费者（Consumer），消费者用于处理生产者产生的消息。\n\n消费者群组：生产者与消费者的关系就如同餐厅中的厨师和顾客之间的关系一样，一个厨师对应多个顾客，也就是一个生产者对应多个消费者，消费者群组（Consumer Group）指的就是由一个或多个消费者组成的群体。\n\n\n偏移量：偏移量（Consumer Offset）是一种元数据，它是一个不断递增的整数值，用来记录消费者发生重平衡时的位置，以便用来恢复数据。\n\nbroker: 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。\n\nbroker 集群：broker 是集群 的组成部分，broker 集群由一个或多个 broker 组成，每个集群都有一个 broker 同时充当了集群控制器的角色（自动从集群的活跃成员中选举出来）。\n\n副本：Kafka 中消息的备份又叫做 副本（Replica），副本的数量是可以配置的，Kafka 定义了两类副本：领导者副本（Leader Replica） 和 追随者副本（Follower Replica），前者对外提供服务，后者只是被动跟随。\n\n重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。\n\n\nKafka 的特性（设计原则）\n高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。\n高伸缩性：每个主题(topic) 包含多个分区(partition)，主题中的分区可以分布在不同的主机(broker)中。\n持久性、可靠性：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。\n容错性：允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作\n高并发：支持数千个客户端同时读写\n\nKafka 的使用场景\n活动跟踪：Kafka 可以用来跟踪用户行为，比如我们经常回去淘宝购物，你打开淘宝的那一刻，你的登陆信息，登陆次数都会作为消息传输到 Kafka ，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递给 Kafka ，这样就可以生成报告，可以做智能推荐，购买喜好等。\n传递消息：Kafka 另外一个基本用途是传递消息，应用程序向用户发送通知就是通过传递消息来实现的，这些应用组件可以生成消息，而不需要关心消息的格式，也不需要关心消息是如何发送的。\n度量指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。\n日志记录：Kafka 的基本概念来源于提交日志，比如我们可以把数据库的更新发送到 Kafka 上，用来记录数据库的更新时间，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。\n流式处理：流式处理是有一个能够提供多种应用程序的领域。\n限流削峰：Kafka 多用于互联网领域某一时刻请求特别多的情况下，可以把请求写入Kafka 中，避免直接请求后端程序导致服务崩溃。\n\nKafka 的消息队列Kafka 的消息队列一般分为两种模式：点对点模式和发布订阅模式\nKafka 是支持消费者群组的，也就是说 Kafka 中会有一个或者多个消费者，如果一个生产者生产的消息由一个消费者进行消费的话，那么这种模式就是点对点模式\n\n如果一个生产者或者多个生产者产生的消息能够被多个消费者同时消费的情况，这样的消息队列成为发布订阅模式的消息队列\n\nKafka 系统架构\n如上图所示，一个典型的 Kafka 集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。\n核心 APIKafka 有四个核心API，它们分别是\n\nProducer API，它允许应用程序向一个或多个 topics 上发送消息记录\nConsumer API，允许应用程序订阅一个或多个 topics 并处理为其生成的记录流\nStreams API，它允许应用程序作为流处理器，从一个或多个主题中消费输入流并为其生成输出流，有效的将输入流转换为输出流。\nConnector API，它允许构建和运行将 Kafka 主题连接到现有应用程序或数据系统的可用生产者和消费者。例如，关系数据库的连接器可能会捕获对表的所有更改\n\n\nKafka 为何如此之快Kafka 实现了零拷贝原理来快速移动数据，避免了内核之间的切换。Kafka 可以将数据记录分批发送，从生产者到文件系统（Kafka 主题日志）到消费者，可以端到端的查看这些批次的数据。\n批处理能够进行更有效的数据压缩并减少 I/O 延迟，Kafka 采取顺序写入磁盘的方式，避免了随机磁盘寻址的浪费，更多关于磁盘寻址的了解，请参阅 程序员需要了解的硬核知识之磁盘 。\n总结一下其实就是四个要点\n\n顺序读写\n零拷贝\n消息压缩\n分批发送\n\nKafka 安装和重要配置Kafka 安装我在 Kafka 系列第一篇应该比较详细了，详情见带你涨姿势的认识一下kafka 这篇文章。\n那我们还是主要来说一下 Kafka 中的重要参数配置吧，这些参数对 Kafka 来说是非常重要的。\n","categories":["Kafka"],"tags":["Kafka","消息队列"]},{"title":"MyBatis框架学习","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/mybatis-xue-xi/","content":"MyBatis框架学习1.常用的框架SSM：\nSpring：它是整合其它框架的框架，它的核心是IOC和AOP，它由20多个模块组成，在很多领域都提供了很好的解决方案，是一个大佬级别的存在。\nSpringMVC：它是Spring家族的一员，专门用来优化控制器（Servlet）的。提供了极简单数据提交，数据携带，页面跳转等功能。\nMyBatista：是持久层的一个框架，用来进行数据库访问的优化，专注于SQL语句，极大的简化了JDBC的访问。\n\n2.什么是框架\n它是一个半成品软件，将所有的公共的，重复的功能解决掉，帮助程序员快速高效的进行开发，它是可复用，可扩展的。\n\n3.什么是MyBatis框架\nMyBatis本是apache的一个开源框架iBatis，2010年这个项目由apache software foundation迁移到了Google code ， 并且改名为MyBatis。2013年11月迁移到Github，最新版本是MyBatis 3.5.7，其发布时间是2021年4月7日。\nMyBatis完成数据访问层的优化，它专注于sql语句，简化了过去JDBC繁琐的访问。\n\n4.MyBatis框架解决的主要问题\n减轻使用JDBC的复杂性，不用编写重复的创建Connection，Statement；不用编写关闭资源代码。直接使用Java对象，表示结果数据。让开发者专注SQL的处理。其他分心的工作由MyBatis代劳。\n\n5.MyBatis可以完成：\n注册数据库的驱动，例如：Class.forName(“com.mysql.jdbc.Driver”);\n创建JDBC中必须使用的Connection，Statement，ResultSet对象\n从xml中获取SQL，并执行SQL语句，把ResultSet结果转换Java对象\nList&lt;Student&gt; list  = new ArrayLsit&lt;&gt;();ResultSet rs = state.executeQuery(\"select * from student\");while(rs.next){    Student student - new Student();    student.setName(rs.getString(\"name\"));    student.setAge(ts.getInt(\"age\"));    list.add(student);}\n\n\n6.MyBatis框架结构\n\n\n7.添加框架的步骤1）添加依赖2）添加配置文件具体步骤：\n1.新建库建表\n2.新建maven项目，选quickstart模板\n3.修改目录，添加缺失的目录，修改目录属性\n4.修改pom.xml文件，添加MyBatis的依赖，添加Mysql的依赖\n5.修改pom.xml文件，添加资源文件指定\n6.在idea中添加数据库的可视化\n7.添加jdbc.properties属性文件（数据库的配置）\n8.添加SqlMapConfig.xml文件，MyBatis的核心配置文件\n9.创建实体类Student，用来封装数据\n10.添加完成学生表的增删改查的功能的StudentMapper.xml文件\n11.创建测试类，进行功能测试\n\n8.文件配置：核心文件配置：\n\n\ndefault所对应值表示所引用的是哪个数据库配置\n\n其中为配置事务管理器\n\nSQL操作\n\nSQL操作时在另外一个xml文件单独写的\n\n查询Java代码实例：\n\n\nJava对应MyBatis的类型别名：\n\n\n参数详解：    collection：用来指定入参的类型，如果是List集合，则为list，如果是Map集合，则为map，如果是数组，则为array。\n​\titem：每次循环遍历出来的值或对象。（注意里面的值必须与#{}里面的值相同）\n​\tsepatator：多个值或对象或语句之间的分割符。\n​\topen：整个循环外面的前括号。\n​\tclose：整个循环外面的后括号。\n\n从这里截断一、批量插入的的例子：UsersMapper.java（接口）\nint insertBatch(List&lt;Users&gt; list);\n\n\n\nUsersMapper.xml\n&lt;insert id=\"insertBatch\"&gt;\tinsert into users(username,birthday,sex,address) values    &lt;foreach collection=\"list\" item=\"u\" separator=\",\"&gt;    \t(#{u.userName},#{u.birthday},#{u.sex},#{u.address})    &lt;/foreach&gt;&lt;/insert&gt;\n\n\n\n二、入参是map（重点掌握）\n如果入参超过一个以上，使用map封装查询条件，更有语义，查询条件更明确\n\n1.返回值是map(一条map)如果返回的数据实体类无法包含，可以使用map返回多张表中的若干数据，返回后这些数据之间没有任何关系，就是object类型。返回的map的key就是列名或别名。\n2.返回值是多行的map3.查询表名与实体类属性名不一致解决方案\nsql语句中添加别名\n使用resultMap：\n&lt;!--property对应实体类属性的变量名column对应sql中所对应查询表名或者表明所对应的标签名首先要key主键绑定，然后非主键的绑定--&gt; &lt;resultMap id=\"bookmap\" type=\"book\"&gt;&lt;!--        主键绑定--&gt;        &lt;id property=\"id\" column=\"bookid\"&gt;&lt;/id&gt;&lt;!--        非主键绑定--&gt;        &lt;result property=\"name\" column=\"bookname\"&gt;&lt;/result&gt;    &lt;/resultMap&gt;    &lt;select id=\"getAll\" resultMap=\"bookmap\"&gt;        select username,address        from users    &lt;/select&gt;\n\n@Testpublic void test_7(){     UsersMapper uMapper = sqlSession.getMapper(UsersMapper.class);    List&lt;Book&gt; list = uMapper.getAll();    list.forEach(book-&gt;System.out.println(book));}\n三、表之间的关联关系关联关系是有方向的。（电商项目不会使用关联关系，因为会大大拖慢速度）\n\n一对多关联：一个老师可以教多个学生，多个学生只有一个老师来教，站在老师方，就是一对多关联。\n多对一关联：一个老师可以教多个学生，多个学生只有一个老师来教，站在学生方，就是多对一关联。\n一对一关联：一个老师辅导一个学生，一个学生只请教一个老师。学生和老师是一对一。\n多对多关联：园区划线的车位和园区的每一辆车。任意一个车位可以停任意一辆车。任意一辆车可以停在任意一个车位上。\n\n1.一对多关联关系\n客户和订单就是典型的一对多关联关系。\n一个客户名下可以有多个订单。\n客户表是一方，订单表是多方。\n\nUpdate表更新操作\n1. update 标签update 标签是用于定义更新 语句的.\n1.1 常用属性update 有几个常用的属性, 但是通常只需要设置id 即可.\n\nid: sql 片段在命名空间内的唯一标识. 和mapper 中方法名保持一致\nparameterType: 参数类型, 通常都可以省略.\nflushCache: 是否刷新(清空)一级缓存和二级缓存, 默认为true. 笔者尝试设置为false,并不生效. 所以使用默认即可.\ntimeout: sql 执行超时时间, 默认未设置, 由数据库驱动决定.\nstatementType: 执行sql时使用的statement类型, 默认为PREPARED. 可选值为:STATEMENT，PREPARED 或 CALLABLE 的一个\n\n&lt;update id=\"deleteAuthor\" parameterType=\"domain.blog.Author\" flushCache=\"true\" statementType=\"PREPARED\" timeout=\"20\"&gt;&lt;/update&gt; \n\n1.2 返回值\n我们知道, jdbc 执行更新语句时, 返回的是sql 执行影响的记录条数. Mybatis 可将此返回结果自动封装为int , long, boolean 以及其对应的包装类型.\n对于不同的返回类型, sql 片段的写法是完全一致的\n\nMapper中方法定义:\n// 返回值为空void update(EmployeePO emp);// 返回值为布尔类型boolean update(EmployeePO emp);// 返回值为删除的条数long update(EmployeePO emp);\n\nsql 片段:\n&lt;update id=\"update\"&gt;    update t_employee    set id = #{id}, name = #{name}, sex=#{sex}, entryDate =#{entryDate}    where id = #{id}&lt;/update&gt;\n\n2. update 标签举例2.1 sql 片段&lt;!-- 通过id 删除 --&gt;&lt;update id=\"update\"&gt;    update t_employee    set id = #{id}, name = #{name}, sex=#{sex}, entryDate =#{entryDate}    where id = #{id}&lt;/update&gt;&lt;!-- 更新不为空的属性 --&gt;&lt;update id=\"updateNotNull\"&gt;    update t_employee    &lt;set &gt;        &lt;if test=\"name != null\"&gt;            name = #{name},        &lt;/if&gt;        &lt;if test=\"sex != null\"&gt;            sex = #{sex},        &lt;/if&gt;        &lt;if test=\"entryDate != null\"&gt;            entryDate = #{entryDate},        &lt;/if&gt;    &lt;/set&gt;    where id = #{id}&lt;/update&gt;\n\n2.2 mapper 文件public interface EmployeeMapper {    // 修改    long update(EmployeePO employeePO);    // 更新不为空的属性    boolean updateNotNull(EmployeePO employeePO);}\n\n2.3 测试类// 测试更新方法@Testpublic void update(){    EmployeeMapper employeeMapper = SqlSessionUtil.getMapper(EmployeeMapper.class, true);    EmployeePO employeePO = employeeMapper.findById(1L);    employeePO.setName(employeePO.getId() + \"_\" + employeePO.getName());    long flag = employeeMapper.update(employeePO);    Assert.assertEquals(1L, flag);}// 测试更新方法@Testpublic void updateNotNull(){    EmployeeMapper employeeMapper = SqlSessionUtil.getMapper(EmployeeMapper.class, true);    EmployeePO employeePO = new EmployeePO(null, 26, \"W\",LocalDate.now());    employeePO.setId(1L);    employeeMapper.updateNotNull(employeePO);}\n\n\n\n\n\nMyBatis框架自动POJO的Bean注入规则：\n当POJO只有一个有参构造函数将会通过这个构造函数进行输入，否则将直接报错。\n当POJO没有任何手写的构造函数时MyBatis框架将会使用set注入。\n当有多个构造函数时且没有的无参构造那么MyBatis就只会从这些有参构造进行注入，如果没有一个能匹配的上的话就会报错，但是如果有手写了无参构造的话如果有参构造没有匹配的注入将会进行set注入避免报错。总结：从以上能够看出Mybatis结合Spring框架自动进行POJO注入时的优先顺序是：先构造，后set。\n\nMapper的xml和Mapper的Java接口的关系\n说明：Mapper的Java接口不是必须的，也可以不写Mapper对应的Java接口直接使用Mapper的xml，这里要注意的是单纯的使用MyBatis，Mapper的xml中的namespace和对应的sql的id都代表的是唯一id的意思没有其他关联的用途，除非设定绑定\n\n\nMyBatis中特殊符号转义符1、转译特殊符号方式注释：严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。\n\n\n\n符号\n原符号\n替换符号\n\n\n\n小于\n&lt;\n&amp;lt;\n\n\n小于等于\n&lt;=\n&amp;lt;&lt;=\n\n\n大于\n&gt;\n&amp;gt;\n\n\n大于小于\n&gt;=\n&amp;gt;=\n\n\n不等于\n&lt;&gt;\n&amp;lt;&amp;gt;\n\n\n与\n&amp;\n&amp;amp;\n\n\n单引号\n’\n&amp;apos;\n\n\n双引号\n“\n&amp;quot;\n\n\n\nmapper文件写法：\nselect * form tablenme t where t.code &amp;lt;&amp;gt; 1\n\n2、使用 CDATA 区段所有XML文档中的文本均会被解析器解析。只有CDATA区段（CDATA section）中的文本会被解析器忽略。\n大于等于 &lt;![CDATA[ &gt;= ]]&gt;  小于等于 &lt;![CDATA[ &lt;= ]]&gt; 不等于&lt;![CDATA[ &lt;&gt; ]]&gt; mapper文件写法： select t.* form tablenme t where t.code &lt;![CDATA[&lt;&gt;]]&gt; 1\n\n\n\nWhere和if标签的使用\n&lt;select id=\"getPerson\" resultType=\"com.lzj.bean.Employee\"&gt;    select * from tbl_employee    &lt;where&gt;        &lt;!-- test：判断表达式（OGNL）        遇见特殊符号应该去写转义字符：&amp;&amp;、''等字符        --&gt;        &lt;if test=\"id!=null\"&gt;            id=#{id}        &lt;/if&gt;        &lt;if test=\"lastName!=null and lastName!=''\"&gt;            and last_name like #{lastName}        &lt;/if&gt;        &lt;if test=\"email!=null and email.trim()!=''\"&gt;            and email=#{email}        &lt;/if&gt;         &lt;!-- ognl会进行字符串与数字的转换判断  \"0\"==0 --&gt;        &lt;if test=\"gender==0 or gender==1\"&gt;            and gender=#{gender}        &lt;/if&gt;    &lt;/where&gt; &lt;/select&gt;\n\n注意，&lt;if&gt;失败后， &lt;where&gt; 关键字只会去掉库表字段赋值前面的and，不会去掉语句后面的and关键字，即注意，&lt;where&gt; 只会去掉&lt;if&gt; 语句中的最开始的and关键字。所以下面的形式是不可取的\n&lt;select id=\"getPerson\" resultType=\"com.lzj.bean.Employee\"&gt;    select * from tbl_employee    &lt;where&gt;        &lt;if test=\"id!=null\"&gt;            id=#{id} and        &lt;/if&gt;        &lt;if test=\"lastName!=null and lastName!=''\"&gt;            last_name like #{lastName} and        &lt;/if&gt;        &lt;if test=\"email!=null and email.trim()!=''\"&gt;            email=#{email} and        &lt;/if&gt;         &lt;if test=\"gender==0 or gender==1\"&gt;            gender=#{gender}        &lt;/if&gt;    &lt;/where&gt; &lt;/select&gt;\n\n","categories":["Java","MyBatis"],"tags":["Java","MyBatis"]},{"title":"MySQL学习笔记","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/mysql-xue-xi-bi-ji/","content":"MySQL学习笔记\n\nauto_increment —自增序列\n在插入时，如果不给定具体用户编号，此时根据auto_increment的值递增添加\n\n安装Mysql8(CentOS7)一、添加MySQL Yum仓库\n下载MySQL RPM包\nwget https://dev.mysql.com/get/mysql80-community-release-el7-9.noarch.rpm\n\n安装MySQL仓库\nsudo rpm -ivh mysql80-community-release-el7-9.noarch.rpm\n\n验证仓库是否添加成功\nyum repolist enabled | grep \"mysql.*-community.*\"\n\n\n二、安装MySQL 8\n更新系统并安装MySQL\nsudo yum updatesudo yum -y install mysql-server --nogpgcheck\n\n或\nsudo yum updatesudo yum -y install mysql-community-server --nogpgcheck\n\n\n\n启动MySQL服务\nsudo systemctl start mysqld\n\n设置开机自启\nsudo systemctl enable mysqld\n\n获取初次启动密码\n\n\ngrep 'A temporary password' /var/log/mysqld.log\n\n三、登录MySQLmysql -u root -p# 输入新设置的密码\n\n四、第一次登录可能需要修改默认密码操作alter user 'root'@'localhost' IDENTIFIED BY '修改的密码';\n\n\n\n\n五、配置远程访问（可选）\n登录MySQL后执行\nCREATE USER '用户名'@'%' IDENTIFIED BY '强密码';GRANT ALL PRIVILEGES ON *.* TO '用户名'@'%' WITH GRANT OPTION;FLUSH PRIVILEGES;\n\n安装Mysql5(CentOS7)一、添加MySQL Yum仓库\n下载MySQL RPM包\nsudo wget wget https://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm\n\n安装MySQL仓库\nsudo rpm -ivh mysql57-community-release-el7-8.noarch.rpm\n\n验证仓库是否添加成功\nyum repolist enabled | grep \"mysql.*-community.*\"\n\n\n二、安装MySQL 5\n更新系统并安装MySQL\nsudo yum updatesudo yum -y install mysql-server --nogpgcheck\n\n或\nsudo yum updatesudo yum -y install mysql-community-server --nogpgcheck\n\n\n\n启动MySQL服务\nsudo systemctl start mysqld\n\n设置开机自启\nsudo systemctl enable mysqld\n\n获取初次启动密码\n\n\ngrep 'A temporary password' /var/log/mysqld.log\n\n三、登录MySQLmysql -u root -p# 输入新设置的密码\n\n四、第一次登录可能需要修改默认密码操作alter user 'root'@'localhost' IDENTIFIED BY '修改的密码';\n\n若报错Your password does not satisfy the current policy requirements则表示该版本Mysql有密码强度检测，一般不允许过于简单的密码，此时如果你还是想搞简单的密码那么可以执行：\nset global validate_password_policy=0;\n\n\n\n\n五、配置远程访问（可选）\n登录MySQL后执行\nCREATE USER '用户名'@'%' IDENTIFIED BY '强密码';GRANT ALL PRIVILEGES ON *.* TO '用户名'@'%' WITH GRANT OPTION;FLUSH PRIVILEGES;\n\n彻底删除MySQL(CentOS7)1.查询本机安装的mysql\nrpm -qa |grep -i mysql\n\n2.使用yum remove ..删除每一个安装\n删除后在使用rpm -qa |grep -i mysql进行检验\n3.查找mysql相关目录\nfind / -name mysql\n\n4.对这些目录一个个的进行删除\nrm -rf\n\n5.删除/etc/my.cnf文件\nrm -rf /etc/my.cnf\n\n6.删除/var/log/mysql/mysqld.log文件\nrm -rf /var/log/mysql/mysqld.log\n\n\n\n添加数据库用户create user ccc identified by 'pass';\n\n上面的命令创建了用户ccc，密码是pass，在mysql.user里可以查看到新增用户的信息：\nselect User,Host from mysql.user where User= 'ccc';\n\n\n\n给予用户数据库权限grant all privileges on cccdb.* to ccc@'%';flush privileges; #刷新权限\n\n上面的语句将cccdb数据库的所有操作权限都授权给了用户ccc。\n可以通过show grants命令查看权限授予执行的命令：\nshow grants for 'ccc';\n\n","categories":["MySql"],"tags":["MySql"]},{"title":"MyBatis逆向生成使用","url":"/2025/04/09/learnnote/java-xue-xi-bi-ji/mybatis-ni-xiang-sheng-cheng-shi-yong/","content":"MyBatis逆向生成使用\n一、导入Mybatis-generator逆向插件\n在pom.xml文件中加入相应插件配置\n\n&lt;plugins&gt;           &lt;!--      mybatis-generator 逆向工具插件   --&gt;            &lt;!-- mybatis代码生成插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.4.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置--&gt;                    &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;!--允许覆盖--&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;               &lt;!--   插件的依赖   --&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                        &lt;version&gt;1.4.1&lt;/version&gt;                    &lt;/dependency&gt;                    &lt;!--mysql驱动依赖--&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;mysql&lt;/groupId&gt;                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                        &lt;version&gt;8.0.33&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;      &lt;/plugins&gt;\n\n这里需要注意一下configurationFile对应配置信息的内容，这里的路径对应之后需要你创建的配置文件路径。\n二、创建MyBatis逆向配置文件以下为配置文件模板\ngeneratorConfig.xml：注意此配置文件所在地方为第一步中插件配置中指定的路径\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt;    &lt;!--mysql 连接数据库jar 这里选择自己本地位置;    如果不知道maven本地仓库地址，可以使用EveryThing工具全局搜索mysql-connector-java，找到jar包位置；    也可以手动下载一个jar放在指定位置，进行引用。    --&gt;    &lt;!--    这里如果没有插件依赖没有引入mysql驱动的话就加这个指定mysql驱动依赖位置--&gt;&lt;!--    &lt;classPathEntry location=\"D:\\Maven\\repository\\com\\mysql\\mysql-connector-j\\8.0.33\\mysql-connector-j-8.0.33.jar\"/&gt;--&gt;    &lt;!--            targetRuntime有两个值：                MyBatis3Simple：生成的是基础版，只有基本的增删改查。                MyBatis3：生成的是增强版，除了基本的增删改查之外还有复杂的增删改查。        --&gt;    &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt;        &lt;!--防止生成重复代码--&gt;        &lt;plugin type=\"org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin\"/&gt;        &lt;commentGenerator&gt;            &lt;!--是否去掉生成日期--&gt;            &lt;property name=\"suppressDate\" value=\"true\"/&gt;            &lt;!-- 是否去除自动生成的注释,true：是,false:否 --&gt;            &lt;property name=\"suppressAllComments\" value=\"true\"/&gt;        &lt;/commentGenerator&gt;        &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;        &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"                        connectionURL=\"jdbc:mysql://localhost:3306/smstwo\"                        userId=\"root\"                        password=\"ht520520\"&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和           NUMERIC 类型解析为java.math.BigDecimal --&gt;        &lt;javaTypeResolver&gt;            &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- 指定javaBean生成的位置            targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；            targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录         --&gt;        &lt;javaModelGenerator targetPackage=\"com.SMS.domain\" targetProject=\"src/main/java\"&gt;            &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false；如果多个数据库改为true分目录 --&gt;            &lt;property name=\"enableSubPackages\" value=\"false\"/&gt;            &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;            &lt;property name=\"trimStrings\" value=\"true\"/&gt;        &lt;/javaModelGenerator&gt;        &lt;!--  指定mapper映射文件生成的位置,也就是mapper.xml           targetPackage、targetProject同javaModelGenerator中作用一样--&gt;        &lt;sqlMapGenerator targetPackage=\"com.SMS.dao\" targetProject=\"src/main/java\"&gt;            &lt;property name=\"enableSubPackages\" value=\"false\"/&gt;        &lt;/sqlMapGenerator&gt;        &lt;!--也可设置到Resource里面--&gt;&lt;!--        &lt;sqlMapGenerator targetPackage=\"mybatis.mapper\" targetProject=\"vhr-web\\src\\main\\resources\"/&gt;--&gt;        &lt;!-- 指定mapper接口生成的位置         targetPackage、targetProject同javaModelGenerator中作用一样         --&gt;        &lt;javaClientGenerator type=\"XMLMAPPER\"                             targetPackage=\"com.SMS.dao\"                             targetProject=\"src/main/java\"&gt;            &lt;property name=\"enableSubPackages\" value=\"false\"/&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 指定数据库表        domainObjectName：生成的domain类的名字,当表名和domain类的名字有差异时一定要设置，如果不设置，直接使用表名作为domain类的名字；        可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；        --&gt;        &lt;table tableName=\"t_userlogin\" domainObjectName=\"User\"&gt;&lt;/table&gt;        &lt;table tableName=\"t_class\" domainObjectName=\"MyClass\"&gt;&lt;/table&gt;        &lt;table tableName=\"t_course\" domainObjectName=\"Course\"&gt;&lt;/table&gt;        &lt;table tableName=\"t_dept\" domainObjectName=\"Dept\"&gt;&lt;/table&gt;        &lt;table tableName=\"t_leave\" domainObjectName=\"Leave\"&gt;&lt;/table&gt;        &lt;table tableName=\"t_student\" domainObjectName=\"Student\"&gt;&lt;/table&gt;        &lt;table tableName=\"t_tearcher\" domainObjectName=\"Tearcher\"&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;\n\n","categories":["Mybatis"],"tags":["Mybatis"]},{"title":"Native-image技术与应用","url":"/2023/10/27/learnnote/java-xue-xi-bi-ji/native-image-ji-zhu-yu-shi-yong/","content":"Native-image技术与应用\n1. 背景相关\n作为一个程序员，总是会在工作的时候开发一些方便自己工作的程序，但是作为一个Java程序员，给自己或者朋友开发的办公小程序总是使用一个Jar包并不是一个很好的体验，主要是：\n\n启动不方便\n需要Java环境\n有时候打出来的Jar比较大，不便于分享传输\n\n但是现在有了GraalVM，让这些都不是问题了，直接生成可执行程序，丢哪哪就能用\n2. GraalVM\nGraalVM是一款高性能的虚拟机，它能够直接将Java程序编译成本地可执行文件，可以在不安装JVM的情况下运行程序。当然了它的特性远不止这些，比如支持多语言，更低的内存占用等等，但这些并不是这篇博客所涉及的，有兴趣可以去他们的官网里了解一下。\n3.安装GraalVM JDK\n下载界面：https://github.com/graalvm/graalvm-ce-builds/releases/tag/vm-22.3.1\n这里用到的是Java 17版本：\n\n下载完成之后，放入你本地的JDK目录，例如：\n\n接着配置变量环境：\n\n通过cmd测试一下看看是否配置环境成功：\n\n安装native-image\nNative Image是一种将Java代码提前编译为独立可执行文件的技术，此刻执行文件包括应用程序类、依赖、运行时库以及JDK静态连接的本机代码。 Graalvm通过子模块SubstrateVM来支持Native Image，相比JVM其生成的程序具有更快的启动时间和更低的运行时开销。\n需要在管理员模式下打开一个cmd窗口，然后执行：\ngu install native-image\n安装Visual studio\n为了打包成exe可执行程序，这一步也是不可避免需要做的，这里推荐安装2019版本之后的，我安装的是visual studio 2022，下载地址：https://visualstudio.microsoft.com\n\n配置Cl.exe环境\n 安装完成以后我们还需要一些配置，不然直接进行打包会失败，这个要根据你VS安装的路径来，比如：\n D:\\Microsoft Visual Studio\\2022\\BuildTools\\VC\\Tools\\MSVC\\14.34.31933\\bin\\Hostx64\\x64\n\n \n\n添加graal-sdk的maven依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;org.graalvm.sdk&lt;/groupId&gt;    &lt;artifactId&gt;graal-sdk&lt;/artifactId&gt;    &lt;version&gt;21.3.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;\n在打包成jar包之后你需要利用跟踪代理运行应用程序生成对应的配置文件：\n\n执行此命令前注意你的idea配置的JDK也需要是GraalVM JDK\njava -agentlib:native-image-agent=config-output-dir=[项目路径]\\src\\main\\resources\\META-INF\\native-image -jar [你的打包好的jar包路径]\n解决找不到stdio.h等情况\n\n如果出现没有stdio等库等原因可能是因为读取不到本地库文件导致，这个时候你只需要添加相应的库即可\n\n配置环境变量。添加INCLUDE：\n\n\n\n添加LIB：\n\n\n\n推荐基础打包教程手把手将你的Java maven项目通过GraalVM打包成windows可执行程序 - 知乎 (zhihu.com)\n关于反射等问题graalvm 编译原生java 解决反射的问题 maven配置 - 方东信 - 博客园 (cnblogs.com)\nagentlib指令使用java -agentlib:native-image-agent=config-output-dir=E:\\AAAA_CODE\\new-eclipse-workspace\\native-netty-log4j\\src\\main\\resources\\META-INF\\native-image -jar E:\\AAAA_CODE\\new-eclipse-workspace\\native-netty-log4j\\target\\native-image-js.jar\n","categories":["Java"],"tags":["Java","Native-image"]},{"title":"OAuth2.0入门","url":"/2025/02/14/learnnote/java-xue-xi-bi-ji/oauth2.0-ru-men/","content":"OAuth2.0入门\n说明：OAuth全称为Open Authorization（开放授权）。OAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。\n一、为什么需要OAuth2.0协议​    简单来说就是当第三方应用需要用户保存在其他应用上的资源时，比如网易云音乐的第三方登录功能，需要获取用户在其他应用上的用户名和头像等信息，这时通过OAuth开放协议以一种安全的方式授权第三方应用去获取这些资源。\n二、OAuth2.0 角色Client：第三方应用，比如上面的网易云音乐Resource Owner：资源所有者，即用户Authorization Server：授权服务器，即提供第三方登录服务的服务器，如QQResource Server：拥有资源信息的服务器，通常和授权服务器属于同一应用\n三、Access Token 和 Refresh TokenAccess Token是客户端访问资源服务器的令牌。通过这个令牌，客户端可以访问第三方应用上受保护的资源。但是Access Token有效期一般较短（这可以降低Acces Token泄漏而带来的风险），当Access Token过期时用户就需要频繁的授权客户端访问资源，这非常影响用户体验，因此引入Refresh Token来获取新的Access Token。\n下面看看OAuth2.0的基本流程。\n\n\n客户端请求获取访问令牌，并向授权服务器提供授权许可（这里有四种认证方式）\n授权服务器对客户端身份进行认证，并校验授权许可，如果校验通过，则发放访问令牌和刷新令牌\n客户端通过访问令牌（Access Token）访问受保护的资源\n资源服务器校验访问令牌（Access Token），如果校验通过，则提供服务，返回资源\n重复（3）和（4）直到访问令牌过期。如果客户端访问令牌（Access Token）已经过期，则认证服务器会返回InvalidTokenError异常（6），此时不能继续访问受保护的资源\n当访问令牌（Access Token）失效以后，资源服务器返回一个无效令牌错误\n客户端通过刷新令牌（Refresh Token）请求获取一个新的访问令牌\n授权服务器对客户端进行身份认证并校验刷新令牌，如果校验通过，则发放新的访问令牌（并且，可以选择发放新的刷新令牌）\n\n四、4种授权类型​    为了获得访问令牌(Token)，客户端需要先从资源所有者(用户)那里获得授权。授权是以授权许可(Grant Type)的形式来表示的。OAuth定义了四种授权类型：\n1、授权码模式（Authorization Code Grant）\n 当用户访问资源时，比如在网易云音乐中使用第三方登录功能，例如QQ登录，那么这里的资源就是用户的QQ昵称和头像等信息。此时第三方应用（网易云音乐）将发送请求到授权服务器（QQ）去获取授权，此时授权服务器（QQ）将返回一个界面给用户，用户需要登录到QQ，并同意授权网易云音乐获得某些信息（资源）。当用户同意授权后，授权服务器将返回一个授权码（Authorization Code）给第三方应用，此时第三方应用在通过client_id、client_secret（这是需要第三方应用在授权服务器去申请的）和授权码去获得Access Token和Refresh Token，此时授权码将失效。然后就是第三方应用通过Access Token去资源服务器请求资源了，资源服务器校验Access Token成功后将返回资源给第三方应用。\n2、隐式授权（Implicit Grant）​       隐式授权又称简化授权模式，它和授权码模式类似，只不过少了获取授权码的步骤，是直接获取令牌token的，且没有Refresh Token，适用于公开的浏览器单页应用。因为令牌直接从授权服务器返回，所以没有安全保证，令牌容易因为被拦截窃听而泄露。\n3、密码模式（Resource Owner Password Credentials Grant）\n首先资源所有者（用户）提供自己的用户名和密码给客户端（Client），然后客户端（Client）携带从用户那里获取的凭证去授权服务器请求Token， 授权服务器对客户端进行身份认证，并校验资源所有者的凭证，如果都校验通过，则发放Token。\n适用范围：只适用于应用是受信任的场景。一个典型的例子是同一个企业内部的不同产品要使用本企业的 Oauth2.0 体系。在这种情况下，由于是同个企业，不需要向用户展示“xxx将获取以下权限”等字样并询问用户的授权意向，而只需进行用户的身份认证即可。这个时候，只需要用户输入凭证并直接传递给鉴权服务器进行授权即可。\n4、客户端授权模式（Client Credentials Grant）\n客户端（Client）通过Client_id和Client_secret去授权服务器请求Token，授权服务器认证Client_id和Client_secret是否正确，若正确则发放Token给客户端（Client）。最后客户端通过AccessToken请求资源。\n适用范围：只适用于应用是受信任的场景。\n","categories":["鉴权认证"],"tags":["OAuth"]},{"title":"RabbitMQ消息队列学习笔记","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/rabbitmq-xiao-xi-dui-lie-xue-xi-bi-ji/","content":"","categories":["Java","消息队列"],"tags":["Java","RabbitMQ"]},{"title":"Redis学习","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/redis-xue-xi/","content":"Redis学习\nRedis安装流程\n下载Redis包\nwget https://download.redis.io/releases/redis-7.2.0.tar.gz\n\n\n\n解压文件\ntar -zxvf redis-7.2.0.tar.gz\n\n进入redis安装目录\ncd redis-7.2.0\n\n\n\n1.Redis是开源的数据库，首先如果要运行话先要用gcc编译器编译好之后才能运行。\n如果没有gcc编译器的可以使用yum指令\nyum -y install gcc\n\n2.然后就可以在Redis安装包的根目录下执行\nmake\n\n指令，这样就会自动编译Redis的源代码。\n让后就可以在redis根目录和根目录下的src目录下各执行一遍\nmake install\n\n这样就会将redis的指令全部copy映射到Linux的bin目录，到时候在任何目录下都可以直接执行相关的指令操作redis了。\n编译完后就可以直接使用\nredis-server #运行redis-server &amp; #后台运行redis-cli shutdown  #停止redisredis-server -h [IP地址] -p [端口号] #可以用来指定对应的非默认redis启动redis-cli -h [IP地址] -p [端口号] shutdown #和上面的意思差不多，只不过换成了停止redisredis-cli  #使用redis自带的客户端连接redisredis-cli -h [IP地址] -p [端口号]\n\n\n\n将Redis设置成开启自启\n1.新建文件\nvi /etc/systemd/system/redis.service\n\n2.进入之后将以下信息复制进去：（注意ExecStart的内容为你们自己的redis.conf文件的路径）\n[Unit]Description=redis-serverAfter=network.target[Service]#Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/redis-7.2.0/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target\n\n之后便保存退出。\n\n退出之后要让文件生效\nsystemctl daemon-reloadsystemctl enable redis\n\n然后重启redis\nsystemctl start redis\n\n查看redis状态\nsystemctl status redis\n\n如何测试redis服务的性能：\n执行指令\nredis-benchmark\n\n查看redis服务是否正常运行：\nping\t\t如果正常——pong（前提是在redis-cli连接后）\n查看redis服务器的统计信息\ninfo # 查看redis服务的所有统计信息info [信息字段] # 查看redis服务器的指定的统计信息，如info Replication\n\nredis的数据库实例：\n作用类似于mysql的数据库实例，redis中的数据库实例只能由redis服务来创建和维护，开发人员不能修改和自行创建数据库实例；默认情况下：redis会自动创建16个数据库实例，并且给这些数据库实例进行编号，从0开始，一直到15，使用时通过编号来使用数据库；可以通过配置文件，指定redis自动创建的数据库个数：redis的每一个数据库实例本身占用的存储空间是很少的，所以也不造成存储空间的太多浪费。\n​\t\t默认情况下，redis客户端连接的是编号是0的数据库实例\nRedis常用指令：\nselect [index] #index表示某个数据库的编号，这个指令用来选择数据库set [key] [value]  #往数据库内添加值get [key]  #获取对应key的值dbsize  #查看当前数据库中key的数目，返回当前数据库的key的数量keys *  #查看当前数据库实例所有的keyflushdb #清空当前库的所有数据flushall  #清空所有数据库的数据（清空整个Redis服务的数据），谨慎使用！！！config get *  #查看redis中所有的配置信息config get parameter #查看redis中的指定的配置信息\n\n\n\n\n\nRedis的特点\n1. 支持数据持久化Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n2. 支持多种数据结构Redis不仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n3. 支持数据备份Redis支持数据的备份，即master-slave模式的数据备份\nA、字符串类型string字符串类型是Redis中最基本的数据结构，它能存储任何类型的数据，包括二进制数据，序列化后的数据，JSON化的对象甚至是一张图片。最大512M。\n\n\n\nkey\nvalue\n\n\n\nusername\n张三和李四\n\n\nB、列表类型 listRedis列表是简单的字符串列表，按照插入顺序排序，元素可以重复。你可以添加一个元素到列表的头部（左边）或者尾部（右边），底层是个链表结构。\n\n\n\nkey\nvalue\n\n\n\nreqion\n北京  上海  天津\n\n\nC、集合类型setRedis的Set是string类型的无序无重复集合。\n\n    \n        key\n        value\n    \n    \n        framework\n    \n    \n        spring\n    \n    \n        mybatis\n    \n    \n        struts\n    \n\n\n\n\nD、哈希类型hashRedis hash 是一个string类型的field和value的映射表，hash特表适合用于存储对象。\n\n\n\nkey\nloginuser\n\n\n\nfield\nvalue\n\n\nuname\n张三\n\n\ntimes\n5\n\n\nregion\n北京\n\n\nE、有序集合类型zset（sorted set）Redis有序集合zset和集合set一样也是string类型元素的集合，且不允许重复的成员。不同的是zset的每个元素都会关联一个分数（分数可以重复），redis通过分数来为集合中的成员进行从小到大的排序。\n\n    \n        key\n        value score\n    \n    \n        salary\n    \n    \n        张三 3500\n    \n    \n        李四 5000\n    \n    \n        周丽 8000\n    \n\n\n\n\nRedis的Key的操作命令\n语法：keys pattern作用：查找所有符合模式pattern的key，pattern可以使用通配符。\n\n*：表示0或多个字符，例如：keys *查询所有的key。\n?：表示单个字符，例如：wo?d，匹配 word，wood\n[]：表示选择[]内的一个字符，例如 wo[or]d，匹配word，wood，不匹配wold，woord\n\n语法：exists key作用：判断key在数据库中是否存在。\n\nexists key：如果存在返回1，如果不存在则返回0\nexists key [key key …]：返回值是存在的key的数量\n\n语法：move key index作用：移动指定key到指定的数据库实例\n\nmove key index：将当前库的指定的key移动到了index库内\n\n语法：ttl作用：查看指定key的剩余生存时间，ttl为time to live的简称\n\nttl key：如果key不存在则返回-2，如果key没有设置生存时间，返回-1\n\n语法：expire key seconds作用：设置key的最大生存时间：expire key seconds\n\nexpire k2 20：给k2设置20秒生存时间，超过20秒k2自动删除\n\n语法：type key作用：查看指定key的数据类型\n语法：rename key newkey作用：重命名指定的key\n语法：del key [key key …]作用：删除指定key，返回值是返回实际删除 的数量。\nRedis中有关string类型数据的操作命令：\n语法：set key value作用：添加一条数据\n语法：get key作用：从Redis中获取string类型的数据，如果key已经存在了则后来的value会把以前的value覆盖掉\n语法：append key value作用：追加字符串，返回追加后的字符串长度，如果key不存在那么作用就类似于set新创建一个key并追加value值。 \n语法：strlen key作用：获取key对应value的字符串长度\n语法：incr key作用：将字符串数值进行加1运算，要求key所表示value必须是数值，否则报错。\n\nincr zsage：返回加1运算之后的数据，如果key不存在，首先设置一个key，值初始化为0，然后进行incr运算。\n\n语法：decr key作用：将字符串数值进行减1运算，要求key所表示value必须是数值，否则报错。\n\ndecr zsage：返回减1运算之后的数据，如果key不存在，首先设置一个key，值初始化为0，然后进行decr运算。\n\n语法：incrby key offset作用：将字符串数值进行加offset运算，返回加offset运算之后的数据，要求key所表示value必须是数值，否则报错。\n\nincrby zsage 10：如果key不存在，首先设置一个key，初始化为0，然后进行incrby运算。\n\n语法：decrby key sffset作用：将字符串数值进行减offset运算，返回加offset运算之后的数据，要求key所表示value必须是数值，否则报错。\n\ndecrby zsage 10：如果key不存在，首先设置一个key，初始化为0，然后进行decrby运算。\n\n语法： getrange key startIndex endIndex作用：获取字符串中的子字符串，下标自左至右，从0开始，以后往后，最后一个字符的下标是字符串长多-1；字符串中每一个下标也可以是负数，负下标表示自右至左，从-1开始，一次往前，最右边一个字符的下标是-1。\n\ngetrange key startIndex endIndex：获取字符串key中从startIndex到endIndex的字符组成的子字符串\n\n语法：setrange key startIndex value作用：用value覆盖从下标为startIndex开始的字符串\n语法：setex作用：设置它最大生命周期\n\nsetex key seconds value\n\n语法：setnx key value作用：设置string类型的数据value到redis数据库中，当key不存在时设置成功，负责将放弃设置\n语法：mset 键1 值1 键2 值2 键3 值3 …作用：批量将string类型的数据设置到redis中\n语法：mget k1 k2 k3 k4 …作用：批量从redis中获取string类型的数据\n语法：msetnx k1 v1 k2 v2 k3 v3 …作用：批量设置string类型的数据value到redis数据库中，当所有key都不存在时设置成功，负责（只要有一个已经存在），则全部放弃设置。 \nRedis中有关列表（List）类型的操作指令\nRedis列表是简单的字符串列表，按照初入顺序排序，左边（头部））、右边（尾部）或者中间都可以添加元素。链表的操作无论是头或尾效率都极高，但是如果对中间元素进行操作，那效率会大大降低了。\n对表类型的数据操作总的思想是通过key和下标操作value，key是数据标识，下标是数据在列表中的位置，value是我们感兴趣的业务数据。\n单key-多有序value，一个key对应多个value，多个value之间有顺序，最左侧是表头，最右侧是表尾，每一个元素都有下标，表头元素的下标是0，一次往后排序，最后一个元素下标是列表长度-1；\n每一个元素的下标又可以用负数表示，负下标表示从表尾计算，最后一个元素下标用-1表示，元素在列表中的顺序或者下标由放入的顺序来决定。\n语法：lpush key value [value value value ……]作用：将一个或者多个值一次插入到列表的表头（左侧）\n\nlpush ke vlaue [value value ……]\n\n语法：lrange key startIndex endIndex作用：获取指定列表中指定下标区间的元素\n语法：rpush key value [value value ……]作用：将一个或者多个值依次插入到列表的表尾（右侧）\n语法：lpop key作用：从指定列表头中移除并且返回表头元素\n语法：rpop key作用：从指定列表尾中移除并且返回表头元素\n语法：lindex key index作用：获取指定列表中指定下标的元素\n语法：llen key作用：获取指定列表的长度\n语法：lrem key value作用：移除列表中某一位元素（value），跟value相等的。\n语法：lrem key count value作用：移除列表中某一些元素，根据count值移除指定列表中跟value相等的数据。当count&gt;0：从列表的左侧移除count个跟value相等的数据；当vount&lt;0：从列表的右侧移除count个跟value相等的数据；当count=0：从列表中移除所有跟value相等的数据\nRedis中有关set类型数据的操作命令\nRedis的Set是string类型的无序不重复集合。\n集合类型的数据操作总的思想是通过key确定集合，key是集合标识，没有下标，只有直接操作业务数据和数据的个数。\n语法：sadd key value [value value …]作用：将一个或者多个元素添加到指定的集合中（添加重复元素时会过滤掉重复元素）\n\nsadd set01 a b c a：这里实际的只能加入三个元素，也就是a、b、c（不会有重复的数据）\n\n语法：smembers key作用：获取指定集合中所有的元素\n语法：sismember  key member作用：判断指定元素（member）在集合（key）中是否存在，存在就返回1，不存在就返回0\n语法：srem key member [member ……]作用：移除指定集合中一个或者多个元素，不存在的元素不被忽略，如果存在那么就会返回成功移除的个数。\n语法：srandmember key [count]作用：随机获取指定集合中的一个或者多个（count）元素，当count&gt;0：随机获取多个元素之间不能重复；当count&lt;0：随机获取的多个元素之间可能重复\n语法：spop key [count]作用：从指定集合中随机移除一个或者多个元素\n语法：smove source dest member作用：将指定集合中的指定元素移动到另一个元素\n\nsmove set1 set2 a：移动a元素到set2集合当中\n\n语法：sdiff key key [key key ….]作用：获取指定一个集合中有、但是其它集合中都没有的元素组成的新集合(差集)\n\nsdiff set1 set2 set3\n\n语法：sinter key key key [key key ……]作用：获取所有指定集合中都有的元素组成的新集合（交集）\n语法：sunion key key [key key ……]作用：获取所有指定集合中所有元素组成的大集合\nRedis中有关hash类型数据的操作命令\nRedis的hash是一个string类型的key和value的映射表，这里的value是一系列的键值对，hash特别适合用于存储对象。\n哈希类型的数据操作总的思想是通过key和field操作value，key是数据标识，field是域，value是我们感兴趣的业务数据。\n语法：hset key filed1 value1 [field2 value2 …]作用：将一个或者多个field-value对设置到哈希表中\n\nhset stu1001 id 1001\n\n语法：hget key field作用：获取指定哈希表中指定field的值\n\nhget hash id：获取名为hash的hash表中的id的值\n\n语法：hmset key filed1 value1 [field2 value2 ……]作用：批量设置多个filed-value，作用和前面的hset一样\n语法：hmget key field1 [field2 field3 ……]作用：批量获取指定哈希表中的field的值\n语法：hgetall key作用：获取指定哈希表中所有的field和value\n语法：hdel key field1 [dield2 field3 …]作用：从指定哈希表中删除一个或者多个field\n语法：hlen key作用：获取指定哈希表中所有的filed个数 \nhlen stu1001：获取key为stu1001的哈希表有多个field。\n语法：hexists key field作用：判断指定哈希表中是否存在某一个field，有则返回1，没有则0\n语法：hkeys key作用：获取指定哈希表中所有field列表\n语法：hvals key作用：获取指定哈希表中所有的value列表\n语法：hincrby key field int(这里的int只能是整数)作用：对指定哈希表中指定field值进行加法运算\n语法：hincrbyfloat key field float作用：对指定哈希表中指定field值进行浮点数加法运算\n语法：hsetnx key field value作用：将一个field-value对设置到哈希表中，当key-field已经存在时，则放弃设置，否则继续设置。\nRedis中有关zset类型数据的操作命令\nRedis有序集合zset和集合set一样也是string类型元素的集合，且不允许重复的成员\n不同的是zset的每个元素都会关联一个分数（分数可以重复），redis通过分数来为集合中的成员进行从小到大的排序。\n本质上是集合，所有元素不能重复。既然有序集合中每一个元素都有顺序，那么也都有下标；有序集合中元素的排序规则由列表中元素的排序规则不一样。\n语法：zadd key score member [score member …]作用：将一个或多个member及其score值加入有序集合\n\nzadd zset01 20 z1 z2 50 z3 40 z4\n\n语法：zrange key startIndex endIndex [withscores]作用：获取指定有序集合中指定下标区间的元素，如果加上withscores那么就会显示后面的分数。\n\nzrange zset01 0 -1\n\n语法：zrangebyscore key min max [withscores]作用：获取指定有序集合中指定分数区间（闭区间）的元素\n语法：zrem key member [member ……]作用：删除有指定有序集合中一个或者多个元素\n\nzrem zset z3 z4\n\n语法：zcard key作用：获取指定有序集合中所有元素的个数\n语法：zrank key member作用：获取指定有序集合中指定元素的排名（闭区间）\n语法：zcount key min max作用：获取指定有序集合中分数在指定区间内的元素的个数\n语法：zscore key member作用：获取指定有序集合中指定元素的分数\n语法：zrevrank key member作用：获取指定有序集合中指定元素的排名（按照分数从大到小的排名）\n语法：zrevrange key startIndex endIndex [WITHSCORES]作用：查询有序集合，指定区间内的元素。集合成员按score值从大到小来排序；startIndex和endIndex都是从0开始表示第一个元素，1表示第二个元素，以此类推；startIndex和 endIndex都可以取负数，表示从后往前取，返回值：指定区间的成员组成的集合。\nRedis的配置文件\n在redis根目录下提供redis.conf配置文件；可以配置一些redis服务端运行时的一些参数；如果不适用配置文件，那么redis会按照默认的参数运行；如果使用配置文件，在启动redis服务时候必须要指定redis所使用的配置文件\nredis-server redis.conf  #像这样\n\n\n\nRedis配置文件中关于网络的配置：port：指定redis服务所使用的端口，默认使用6379\nbind：配置客户端连接redis服务时，所能使用的ip地址，默认可以使用redis服务所在主机上任何一个ip都可以；一般情况下，都会配置一个ip，而且通常是一个真实的网卡上的IP。\ntcp-keepalive：TCP连接保活策略 ，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。如果设置为0，则不会进行保活检测。\nRedis常规配置：loglevel：配置日志级别，开发阶段可以设置成debug，生成阶段通常设置为notice或者warning。\nlogfile：指定日志文件。redis在运行过程中，会输出一些日志信息：默认情况下，这些日志信息会输出到控制台：我们可以使用logfile配置日志文件，使redis把日志信息输出到文件里面。要保证日志文件所在目录必须存在，文件可以不存在。还要在redis启动时指定所使用的配置文件，否则配置不起作用。\ndatabases：配置redis服务默认创建的数据库实例个数，默认值是16\nRedis的安全配置requirepass：配置Redis的访问密码。默认不配置密码，即访问不需要密码验证。此配置项需要在prorected-mode=yes时起作用。使用密码登录客户端：\nredis-cli -h ip -p 6379 -a pwd\n\nredis的持久化：redis提供持久化策略，在适当的时机采用适当手段把内存中的数据持久化到磁盘中，每次redis服务启动时都可以把磁盘上的数据再次加载内存中使用。\nRedis的RDB配置RDB策略 ：在指定时间间隔内，redis服务执行指定次数的写操作，会自动触发一次持久化操作。\n1、save  ：配置复合的快照触发条件，即Redis在seconds秒内key改变changes次，Redis把快照内的数据保存到了磁盘中一次。默认的策略是：\n1分钟内改变1万次\n或者5分钟内改变了10次\n或者15分钟内改变了1次\n如果要禁止Redis的持久化功能，则把所有的save配置都注释掉。\n2、stop-writes-on-bgsave-error：当bgsave快照操作出错时停止写数据到磁盘，这样能保证内存珊瑚橘和磁盘数据的一致性，但如果不在乎这种一致性，要在bgsave快照操作出错时继续写操作，这里需要配置为no。\n3、rdbcompression：设置对于存储到磁盘中的快照是否进行压缩，设置为yes时，Redis会采用LZF算法进行压缩；如果不想消耗CPU进行压缩的话，可以设置为no，关闭此功能。\n4、rdbchecksum：在存储快照以后，还可以让Redis使用CRC4算法来进行数据校验，但这样会消耗一定的性能，如果系统比较在意性能的提升，可以设置为no，关闭此功能。\n5、dbfilename：Redis持久化数据生成的文件名，默认是dump.rdb，也可以自己配置。\n6、dir：Redis持久化数据生成文件保存的目录，默认是./即redis的启动目录，也可以自己配置。\nRedis的AOF策略：AOF策略：采用操作日志来记录进行每一次写操作，每次redis服务启动时，都会重新执行一遍操作日志中的指令。redis默认不开启，效率低。\nappendonly：配置是否开启AOF策略，默认为no即为关闭\nappendfilename：配置操作日志文件\n小结：根据数据的特点决定开启哪种持久化策略；一般情况，开启RDB足够了。\nRedis的事务：事务：把一组数据库命令放在一起执行，保证操作的原子性，要么同时成功，要么同时失败。\nRedis的事务：允许在把一组redis数据库命令放在一起执行，把命令进行序列化，然后一起执行，保证部分原子性\n1、单独的隔离操作：事务中的所有命令都会序列化、顺序地执行、事务在执行过程中，不会被其它客户端发来的命令请求所打断，除非使用watch命令监控某些键。\n2、不保证事务的原子性：redis同一事务中如果一条命令执行失败，其后的命令仍然可能会被执行，redis的事务没有回滚。Redis已经在系统内部进行功能简化，这样可以确保更快的运行速度，因为Redis不需要事务回滚的能力。\n1）multi：用来标记一个事务的开始。2）exec：用来执行事务队列中所有的命令。3）redis的事务只能保证部分原子性：​\ta）如果一组命令中，有在加入事务队列过程中发生错误的命令，则本事务中所有的命令都不执行，能够保证事务的原子性。\nmultiseta kk vvset k4 v4exec#这里上面所有的命令都不会凑效\n\n b）如果一组命令中，在压入队列过程中正常，但是在执行事务 队列命令时发生了错误，则只会影响发生错误的命令，不会影响其他命令的执行，这时就不能保证事务的原子性。\nmultiset k3 v3incr k1set k4 v4exec#压入队列的时候这些指令并没有执行，执行的时候会报错，这个时候就只会忽略报错的指令其他指令照常，这时候就不能保证事务的原子性了，只能说部分原子性。\n\n4）discard：清楚所有已经压入队列中的命令，并且结束整个事务。set k5 v5set k6 v6discard\n\n5） watch:监控某一个键，当事务在执行过程中，此键代表的值发生了变化，则本事务放弃执行，否则正常执行。set balance 100set balance2 1000set version 1watch versionmultidecrby balance 50incrby balance2 50exec\n\n6）unwatch：放弃监控所有的键。Redis消息的发布与订阅\nredis客户端订阅频道，消息的发布者往频道上发布消息，所有订阅此频道的客户端都能够接受到\n1）subscribe ch1 ch2 [ch3 ch4 …]：定义频道2）publish ch1 message：发布消息，这里是往ch1发送message3）psubcribe：订阅一个或者多个频道的消息，频道名支持通配符。\nsubscribe news.*\n\nRedis的主从复制","categories":["Redis"],"tags":["Redis"]},{"title":"RocketMQ学习","url":"/2023/09/20/learnnote/java-xue-xi-bi-ji/rocketmq-bi-ji/","content":"RocketMQ学习\n1.\t定义\n中间件（缓存中间件  redis memcache  数据库中间件 mycat  canal  消息中间件mq ）\n面向消息的中间件(message-oriented middleware) MOM能够很好的解决以上的问题。\n是指利用高效可靠的消息传递机制进行与平台无关（跨平台）的数据交流，并基于数据通信来进行分布式系统的集成。\n通过提供消息传递和消息排队模型在分布式环境下提供应用解耦，弹性伸缩，冗余存储，流量削峰，异步通信，数据同步等\n1.1\t大致流程发送者把消息发给消息服务器[MQ]，消息服务器把消息存放在若干主题中，在合适的时候，消息服务器会把消息转发给接受者。在这个过程中，发送和接受是异步的,也就是发送无需等待，发送者和接受者的生命周期也没有必然关系在发布pub/订阅sub模式下，也可以完成一对多的通信，可以让一个消息有多个接受者[微信订阅号就是这样的]\n\n2.\t为什么用MQ：\n1，要做到系统解耦，当新的模块进来时，可以做到代码改动最小;  能够解耦\n2，设置流程缓冲池，可以让后端系统按自身吞吐能力进行消费，不被冲垮; 能够削峰，限流\n3，强弱依赖梳理能把非关键调用链路的操作异步化并提升整体系统的吞吐能力;能够异步\nMq的作用  削峰限流 异步 解耦合\n\n3.\t现实中的业务\n\n4.\t常见的MQ产品：\nactiveMQ：Java写的（jms协议），性能一般，出现早，功能单一，吞吐量低\nRabbitMQ：erlang（amqp协议），性能好，功能丰富，吞吐量一般\nRocketMQ：Java（阿里），性能好，功能最丰富，吞吐量高\nKafka：scala写的，吞吐量大，功能单一，大数据领域\n\n4.1\t常见MQ产品比较：\n5.\tRocketMQ介绍：\nRocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，RocketMQ是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的晓溪发布与订阅服务。同时广泛应用于多个领域，包括异步通讯解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视屏、物联网、车联网等\n\n5.1\t具有以下特点：\n1、能够保证严格的消息顺序\n2、提供丰富的消息拉取模式\n3、高效的订阅者水平拓展能力\n4、实时的信息订阅机制\n5、亿级消息堆积能力\n\n5.2\tRocketMQ重要概念（重点）\nProducer：消息的发送者，生产者；举例：发件人\nConsumer：消息接收者，消费者；举例：收件人\nBroker：暂存和传输消息的通道**；举例：**快递\nNameServer：管理Broker；举例：各个快递公司的管理机构 相当于broker的注册中心，保留了broker的信息\nQueue：队列，消息存放的位置，一个Broker中可以有多个队列\nTopic：主题，消息的分类\nProducerGroup：生产者组 \nConsumerGroup：消费者组，多个消费者组可以同时消费一个主题的消息\n消息发送的流程是，Producer询问NameServer，NameServer分配一个broker 然后Consumer也要询问NameServer，得到一个具体的broker，然后消费消息\n\n\n6.\t生产和消费理解（重点）\n\n7.\t下载并配置rocketMQ\n7.1\t解压unzip rocketmq-all-4.9.2-bin-release.zip\n\n如果服务器没有unzip指令，就下载安装一个\nyum install unzip\n\n目录分析：\n\n\nbenchmark：包含一些性能测试的脚本；\nbin：可执行文件目录；\nconf：配置文件目录\nlib：第三方依赖；\nLICENSE：授权信息；\nNOTICE：版本公告；\n\n7.2\t配置环境变量vim /etc/profile\n\n在文件末尾添加\nexport NAMESRV_ADDR=阿里云公网IP:9876\n\n7.3\t修改nameServer的运行脚本进入bin目录下，修改runserver.sh文件，将71行和76行的Xms和Xmx等改下小一点\nvim runserver.sh\n\n\n保存退出\n7.4\t修改broker的运行脚本进入bin目录下，修改runbroker.sh，修改67行\n\n保存退出\n7.5\t修改broker的配置文件进入conf目录下，修改broker.conf文件\nbrokerClusterName = DefaultClusterbrokerName = broker-abrokerId = 0deleteWhen = 04fileReservedTime = 48brokerRole = ASYNC_MASTERflushDiskType = ASYNC_FLUSHnamesrvAddr=localhost:9876autoCreateTopicEnable=truebrokerIP1=阿里云公网IP\n\n添加参数解释\nnamesrvAddr：nameSrv地址可以写localhost因为nameSrv和broker在一个服务器\nautoCreateTopicEnable：自动创建主题，不然需要手动创建出来\nbrokerIP1：broker也需要一个公网IP，如果不指定，那么是阿里云的内网地址，我们再本地无法连接使用\n7.6\t启动首先在安装目录下创建一个logs文件夹，用于存放日志\nmkdir logs\n\n一次运行两条命令\n启动nameSrv\nnohup sh bin/mqnamesrv &gt; ./logs/namesrv.log &amp;\n\n启动broker这里的-c是指定使用的配置文件\nnohup sh bin/mqbroker -c conf/broker.conf &gt; ./logs/broker.log &amp;\n\n查看启动结果\n\n7.8\tRocketMQ控制台的安装RockerMQ-ConsoleRocketmq 控制台可以可视化MQ的消息发送！\n旧版本源码是在rocketmq-external里的rocketmq-console，新版本已经单独拆分成dashboard\n网址： https://github.com/apache/rocketmq-dashboard \n下载地址：\nhttps://github.com/apache/rocketmq-dashboard/archive/refs/tags/rocketmq-dashboard-1.0.0.zip \n下载后解压出来，在跟目录下执行\nmvn clean package -Dmaven.test.skip=true\n\n\n\n将jar包上传到服务器上去\n然后运行\nnohup java -jar ./rocket-dashboard-1.0.0.jar rocketmq.config.namesrvAddr=127.0.0.1:9876 &gt; ./rocketmq-4.9.3/logs/dashboard.log &amp;\n\n命令拓展：–server.port指定运的端口\n 指定namesrv地址\n--rocketmq.config.namesrvAddr=127.0.0.1:9876\n\n访问：  http://localhost:8001 \n运行访问端口是8001，如果从官网拉下来打包的话，默认端口是8080\n\n8\tRocketMQ安装之docker\n8.1\t下载RocketMQ需要的镜像docker pull rocketmqinc/rocketmq\n\ndocker pull styletang/rocketmq-console-ng\n\n8.2\t启动NameServer服务8.2.1\t创建NameServer数据存储路径mkdir -p /home/rocketmq/data/namesrv/logs /home/rocketmq/data/namesrv/store\n\n8.2.2\t启动NameServer容器docker run -d --name rmqnamesrv -p 9876:9876 -v /home/rocketmq/data/namesrv/logs:/root/logs -v /home/rocketmq/data/namesrv/store:/root/store -e \"MAX_POSSIBLE_HEAP=100000000\" rocketmqinc/rocketmq sh mqnamesrv\n\n8.3\t启动Broker服务8.3.1\t创建Broker数据存储路径mkdir -p /home/rocketmq/data/broker/logs /home/rocketmq/data/broker/store\n\n8.3.2\t创建conf配置文件目录mkdir /home/rocketmq/conf\n\n8.3.3\t在配置文件目录下创建broker.conf配置文件# 所属集群名称，如果节点较多可以配置多个brokerClusterName = DefaultCluster#broker名称，master和slave使用相同的名称，表明他们的主从关系brokerName = broker-a#0表示Master，大于0表示不同的slavebrokerId = 0#表示几点做消息删除动作，默认是凌晨4点deleteWhen = 04#在磁盘上保留消息的时长，单位是小时fileReservedTime = 48#有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；brokerRole = ASYNC_MASTER#刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；flushDiskType = ASYNC_FLUSH# 设置broker节点所在服务器的ip地址brokerIP1 = 你服务器外网ip\n\n8.3.4\t启动Broker容器docker run -d  --name rmqbroker --link rmqnamesrv:namesrv -p 10911:10911 -p 10909:10909 -v  /home/rocketmq/data/broker/logs:/root/logs -v /home/rocketmq/data/broker/store:/root/store -v /home/rocketmq/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf --privileged=true -e \"NAMESRV_ADDR=namesrv:9876\" -e \"MAX_POSSIBLE_HEAP=200000000\" rocketmqinc/rocketmq sh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf\n\n8.4\t启动控制台docker run -d --name rmqadmin -e \"JAVA_OPTS=-Drocketmq.namesrv.addr=你的外网地址:9876 \\-Dcom.rocketmq.sendMessageWithVIPChannel=false \\-Duser.timezone='Asia/Shanghai'\" -v /etc/localtime:/etc/localtime -p 9999:8080 styletang/rocketmq-console-ng\n\n8.5\t正常启动后的docker ps\n8.6\t访问控制台http://你的服务器外网ip:9999/\n\n\n","categories":["Java","消息队列"],"tags":["Java","RocketMQ"]},{"title":"SSM开发配置文档","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/ssm-jia-gou-kai-fa-wen-dang/","content":"SSM开发配置文档\n一、开发步骤\n\n新建项目，选择webapp模板；\n修改目录，添加缺失的test，java，resources（两套），如果目录没有属性标识记得修改属性；\n修改pom.xml文件，添加Spring套件和MyBatis套件的依赖等等；\n删除系统自动创建的web.xml文件，新建web.xml；\n添加Sql语句的日志输出配置文件，例如：SqlMapConfig.xml；\n添加服务器连接配置，例如：jdbc.properties；\n添加数据访问层的配置（Mapper），例如：ApplicationContext_mapper.xml；\n添加业务逻辑层的配置（Service），例如：ApplicationContext_service.xml；\n添加SpringMVC的配置，指定包扫描（因为要基于注解开发），添加视图解析器(如果是基于ajax开发那么可以忽略这一步，如果jsp那么就需要)。例如：springmvc.xml；\n在web.xml文件中设定好字符过滤器来不让其出现乱码现象，注册Spring框架、SpringMVC框架（所有的web请求都是基于servlet的）。\n\n\n1.新建项目，选择webapp模板\n\n\n2.修改目录，添加缺失的test，java，resources（两套），如果目录没有属性标识记得修改属性\n\n\n3.修改pom.xml文件，添加Spring套件和MyBatis套件的依赖等等pom.xml文件模板：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.example&lt;/groupId&gt;  &lt;artifactId&gt;SSM_Study_1&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;!--    junit版本管理，注意4.12或以上的版本才能接管spring--&gt;    &lt;junit.version&gt;4.12&lt;/junit.version&gt;&lt;!--    sprin版本管理--&gt;    &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt;&lt;!--    mybatis版本管理--&gt;    &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt;&lt;!--mysql版本管理--&gt;    &lt;mysql.version&gt;8.0.27&lt;/mysql.version&gt;&lt;!--    mybatis与spring整合的依赖--&gt;    &lt;mybatis.spring.version&gt;1.3.1&lt;/mybatis.spring.version&gt;&lt;!--阿里的数据库连接池--&gt;    &lt;druid.version&gt;1.1.12&lt;/druid.version&gt;&lt;!--    servlet版本管理--&gt;    &lt;servlet.version&gt;2.5&lt;/servlet.version&gt;&lt;!-- jackson的依赖--&gt;    &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt;&lt;!--    fastjson版本管理--&gt;    &lt;fastjson.version&gt;1.2.59&lt;/fastjson.version&gt;&lt;!--      jackson依赖管理--&gt;      &lt;jackson.version&gt;2.9.6&lt;/jackson.version&gt;&lt;!--      jsp相关版本管理--&gt;      &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;&lt;!--    spring相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    事务管理需要的spring--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    邮件处理--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    上下文关联处理--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    spring单元测试--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;${mybatis.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;!--mybatis与spring整合的--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    mybatis支持分页插件--&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt;      &lt;version&gt;1.2.15&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    分页插件本身--&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;      &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;      &lt;version&gt;5.3.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;${mysql.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;      &lt;version&gt;${servlet.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    阿里巴巴的数据库连接池--&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid&lt;/artifactId&gt;      &lt;version&gt;${druid.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;!--    &lt;dependency&gt;--&gt;&lt;!--      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt;&lt;!--      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;--&gt;&lt;!--      &lt;version&gt;${fastjson.version}&lt;/version&gt;--&gt;&lt;!--    &lt;/dependency&gt;--&gt;    &lt;!--    单元测试依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;${junit.version}&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;jstl&lt;/groupId&gt;          &lt;artifactId&gt;jstl&lt;/artifactId&gt;          &lt;version&gt;1.2&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;          &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;          &lt;scope&gt;provided&lt;/scope&gt;          &lt;version&gt;${jsp-api.version}&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;          &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;          &lt;version&gt;4.0.1&lt;/version&gt;          &lt;scope&gt;provided&lt;/scope&gt;&lt;!--使用别人提供的--&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;          &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;          &lt;version&gt;${jackson.version}&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;          &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;          &lt;version&gt;${jackson.version}&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;          &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;          &lt;version&gt;${jackson.version}&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;          &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;          &lt;version&gt;${jackson.version}&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;          &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;          &lt;version&gt;1.7.21&lt;/version&gt;      &lt;/dependency&gt;&lt;!--      文件上传使用的依赖--&gt;      &lt;dependency&gt;          &lt;groupId&gt;commons-io&lt;/groupId&gt;          &lt;artifactId&gt;commons-io&lt;/artifactId&gt;          &lt;version&gt;2.4&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;          &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;          &lt;version&gt;1.3.1&lt;/version&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;&lt;!--    识别所有配置文件--&gt;    &lt;resources&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;          &lt;include&gt;**/*.properties&lt;/include&gt;          &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;        &lt;filtering&gt;false&lt;/filtering&gt;      &lt;/resource&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;includes&gt;          &lt;include&gt;**/*.properties&lt;/include&gt;          &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;        &lt;filtering&gt;false&lt;/filtering&gt;      &lt;/resource&gt;    &lt;/resources&gt;  &lt;/build&gt;&lt;/project&gt;\n\n\n4.删除系统自动创建的web.xml文件，新建web.xml\n\n\n5.添加Sql语句的日志输出配置文件，例如：SqlMapConfig.xml\n这里就直接使用模板自己原本配置的模板\n\nSqlMapConfig.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD config 3.0//EN\"        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;!--    设置日志输出语句，显示相应操作的sql语名--&gt;    &lt;settings&gt;        &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;    &lt;/settings&gt;&lt;/configuration&gt;\n\n\n6.添加服务器连接配置，例如：jdbc.properties\n\njdbc.properties\njdbc.driverClassName=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=12345678\n7. 添加数据访问层的配置（Mapper），例如：ApplicationContext_mapper.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!--    读取属性文件--&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--    配置数据源--&gt;    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt;        &lt;property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/&gt;        &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;    &lt;/bean&gt;&lt;!--    配置SQLSessionFactoryBean--&gt;    &lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;&lt;!--        配置数据源--&gt;        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;!--        配置SqlMapConfig.xml--&gt;        &lt;property name=\"configLocation\" value=\"classpath:SqlMapConfig.xml\"/&gt;&lt;!--        注册实体类--&gt;        &lt;property name=\"typeAliasesPackage\" value=\"com.study.pojo\"/&gt;    &lt;/bean&gt;&lt;!--    注册mapper--&gt;    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;        &lt;property name=\"basePackage\" value=\"com.study.mapper\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n\n8.添加业务逻辑层的配置（Service），例如：ApplicationContext_service.xml\n\n&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"      xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"      xmlns:aop=\"http://www.springframework.org/schema/aop\"      xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&gt;&lt;!--    扫包--&gt;   &lt;context:component-scan base-package=\"com.study.service\"/&gt;&gt;&lt;!--    添加事务管理器--&gt;   &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;&gt;&lt;!--        切记切记，配置数据源--&gt;       &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;   &lt;/bean&gt;&gt;&lt;!--    配置切入点,注意这里导入的是后缀带tx的spring框架xmlns--&gt;   &lt;tx:advice id=\"myadvice\" transaction-manager=\"transactionManager\"&gt;       &lt;tx:attributes&gt;           &lt;tx:method name=\"*select*\" read-only=\"true\"/&gt;           &lt;tx:method name=\"*find*\" read-only=\"true\"/&gt;           &lt;tx:method name=\"*search*\" read-only=\"true\"/&gt;           &lt;tx:method name=\"*get*\" read-only=\"true\"/&gt;           &lt;tx:method name=\"*add*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*save*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*set*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*update*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*change*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*modify*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*delete*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*drop*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*clear*\" propagation=\"REQUIRED\"/&gt;           &lt;tx:method name=\"*\" propagation=\"SUPPORTS\"/&gt;       &lt;/tx:attributes&gt;   &lt;/tx:advice&gt;&gt;&lt;!--    配置切入点+绑定--&gt;   &lt;aop:config&gt;       &lt;aop:pointcut id=\"mycut\" expression=\"execution(* com.study.service..impl.*.*(..))\"/&gt;       &lt;aop:advisor advice-ref=\"myadvice\" pointcut-ref=\"mycut\"/&gt;   &lt;/aop:config&gt;&gt;&lt;/beans&gt;\n\n\n9.添加SpringMVC的配置，指定包扫描（因为要基于注解开发），添加视图解析器(如果是基于ajax开发那么可以忽略这一步，如果jsp那么就需要)。例如：springmvc.xml\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!--    添加包扫描--&gt;    &lt;context:component-scan base-package=\"com.study.controller\"/&gt;&lt;!--    添加mvc注解驱动--&gt;    &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;   &lt;!--这一步根据情况来，如果不是jsp开发可以把这个视图解析器给忽略掉--&gt;     &lt;!--    添加视图解析器--&gt;    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;        &lt;property name=\"prefix\" value=\"/admin/\"&gt;&lt;/property&gt;        &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;    &lt;/bean&gt;        &lt;/beans&gt;\n\n\n10.在web.xml文件中设定好字符过滤器来不让其出现乱码现象，注册Spring框架、SpringMVC框架（所有的web请求都是基于servlet的）\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"         version=\"4.0\"&gt;&lt;!--    添加编码过滤private String encoding;\tprivate boolean forceRequestEncoding = false;\tprivate boolean forceResponseEncoding = false;--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encode&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;UTF-8&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;init-param&gt;            &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;            &lt;param-value&gt;true&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encode&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;!--    添加springmvc--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;!--    添加spring--&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:ApplicationContext_*.xml&lt;/param-value&gt;    &lt;/context-param&gt;&lt;/web-app&gt;\n\n\n二、开发注意事项POJO实体类开发注意事项：1. 自动注入时，如果有主键的的注入那么POJO中构造体中参数的主键注入形参必须与SQL语句中主键所在位置相同不然就会报错。   例如：\n\n &lt;sql id=\"allColumns\"&gt;        user_id&lt;!--这个是主键--&gt;,user_name,user_sex,user_age,user_uid,user_password    &lt;/sql&gt;    &lt;sql id=\"testColumns\"&gt;        user_name,user_sex,user_age,user_uid,user_password    &lt;/sql&gt;&lt;!--User login(            @Param(\"userAccount\")            String userAccount,            @Param(\"userPassword\")            String userPassword    );--&gt;    &lt;select id=\"login\" resultType=\"user\"&gt;        select &lt;include refid=\"allColumns\"/&gt;        from user        &lt;choose&gt;            &lt;when test=\"userAccount!=null and userAccount!='' and userPassword!=null and userPassword!=''\"&gt;                where user_uid=#{userAccount} and user_password=#{userPassword}            &lt;/when&gt;            &lt;otherwise&gt;                where false            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/select&gt;\n\npublic User(Integer userId/*这个是主键*/,String userName, String userSex, Integer userAge, String userUid, String userPassword) {    this.userName = userName;    this.userSex = userSex;    this.userAge = userAge;    this.userUid = userUid;    this.userPassword = userPassword;    this.userId = userId;  }\n\n再比如：\n &lt;sql id=\"allColumns\"&gt;        user_name,user_sex,user_age,user_id&lt;!--这个是主键--&gt;,user_uid,user_password    &lt;/sql&gt;    &lt;sql id=\"testColumns\"&gt;        user_name,user_sex,user_age,user_uid,user_password    &lt;/sql&gt;&lt;!--User login(            @Param(\"userAccount\")            String userAccount,            @Param(\"userPassword\")            String userPassword    );--&gt;    &lt;select id=\"login\" resultType=\"user\"&gt;        select &lt;include refid=\"allColumns\"/&gt;        from user        &lt;choose&gt;            &lt;when test=\"userAccount!=null and userAccount!='' and userPassword!=null and userPassword!=''\"&gt;                where user_uid=#{userAccount} and user_password=#{userPassword}            &lt;/when&gt;            &lt;otherwise&gt;                where false            &lt;/otherwise&gt;        &lt;/choose&gt;    &lt;/select&gt;\n\npublic User(String userName, String userSex, Integer userAge, Integer userId/*这个是主键*/,String userUid, String userPassword) {    this.userName = userName;    this.userSex = userSex;    this.userAge = userAge;    this.userUid = userUid;    this.userPassword = userPassword;    this.userId = userId;  }\n\n\n","categories":["Java","Spring"],"tags":["Java","SpringMVC","Spring","MyBatis","SSM"]},{"title":"SpringBoot中AOP编程","url":"/2025/04/08/learnnote/java-xue-xi-bi-ji/springboot-zhong-aop-bian-cheng/","content":"SpringBoot中AOP编程一、AOP是什么AOP：Aspect Oriented Programming，翻译过来就是“面相切面编程”，它是对面相对象的一种补充和完善。\nAOP的使用场景：\n\n数据源切换\n事务管理\n权限控制\n日志打印\n\n根据其使用场景我能知道起始AOP的实现很像我们现实中需要对业务代码部分进行切入业务实现逻辑。\n它有以下特点：\n\n侵入性小，几乎可以不改动原来逻辑的情况下把新的逻辑加入业务。\n实现方便，使用几个注解就可以实现，使系统更容易拓展。\n更好的复用代码，比如事务日志打印，简单逻辑适合所有情况。\n\n二、AOP中注解的含义@Aspect：切面。表示一个横切进业务的一个对象。他里面包含切入点（Pointcut）和Advice（通知）。\n@Pointcut：切入点。表示需要切入的位置，比如某些类或者某些方法，也就是先定一个范围。\n@Before：Advice（通知）的一种，切入点的方法体执行之前执行。\n@Around：Advice（通知）的一种，环绕切入点执行也就是把切入点包裹起来执行。@After：Advice（通知）的一种，在切入点正常运行结束后执行。@AfterReturning：Advice（通知）的一种，在切入点正常运行结束后执行，异常则不执行@AfterThrowing：Advice（通知）的一种，在切入点运行异常时执行。\n三、Pointcut切入点的语法/** * 1、使用within表达式匹配 * 下面示例表示匹配com.leo.controller包下所有的类的方法 */@Pointcut(\"within(com.leo.controller..*)\")public void pointcutWithin(){}/** * 2、this匹配目标指定的方法，此处就是HelloController的方法 */@Pointcut(\"this(com.leo.controller.HelloController)\")public void pointcutThis(){}/** * 3、target匹配实现UserInfoService接口的目标对象 */@Pointcut(\"target(com.leo.service.UserInfoService)\")public void pointcutTarge(){}/** * 4、bean匹配所有以Service结尾的bean里面的方法， * 注意：使用自动注入的时候默认实现类首字母小写为bean的id */@Pointcut(\"bean(*ServiceImpl)\")public void pointcutBean(){}/** * 5、args匹配第一个入参是String类型的方法 */@Pointcut(\"args(String, ..)\")public void pointcutArgs(){}/** * 6、@annotation匹配是@Controller类型的方法 */@Pointcut(\"@annotation(org.springframework.stereotype.Controller)\")public void pointcutAnnocation(){}/** * 7、@within匹配@Controller注解下的方法，要求注解的@Controller级别为@Retention(RetentionPolicy.CLASS) */@Pointcut(\"@within(org.springframework.stereotype.Controller)\")public void pointcutWithinAnno(){}/** * 8、@target匹配的是@Controller的类下面的方法，要求注解的@Controller级别为@Retention(RetentionPolicy.RUNTIME) */@Pointcut(\"@target(org.springframework.stereotype.Controller)\")public void pointcutTargetAnno(){}/** * 9、@args匹配参数中标注为@Sevice的注解的方法 */@Pointcut(\"@args(org.springframework.stereotype.Service)\")public void pointcutArgsAnno(){}/** * 10、使用excution表达式 * execution( *  modifier-pattern?           //用于匹配public、private等访问修饰符 *  ret-type-pattern            //用于匹配返回值类型，不可省略 *  declaring-type-pattern?     //用于匹配包类型 *  name-pattern(param-pattern) //用于匹配类中的方法，不可省略 *  throws-pattern?             //用于匹配抛出异常的方法 * ) * * 下面的表达式解释为：匹配com.leo.controller.HelloController类中以hello开头的修饰符为public返回类型任意的方法 */@Pointcut(value = \"execution(public * com.leo.controller.HelloController.hello*(..))\")public void pointCut() {}\n\n需要注意：上面的匹配的类型中支持或(||)与(&amp;&amp;)非(!)运算。\n四、AOP代码实现首先配置pom.xml进行注解jar包的支持\n&lt;!-- aop aspect注解导包--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;    &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;\n\n然后在配置文件中启动注解支持，例如我的是myspringmvc-servlet.xml文件，这里需要注意的是注解要跟配置文件在一块，举个例子：如果需要切入Controller的配置就需要在myspringmvc-servlet.xml中添加，如果是切入应用的配置如Service则需要在applicationContext.xml中添加。\n&lt;!-- 开启Aop注解 --&gt;&lt;aop:aspectj-autoproxy  proxy-target-class=\"true\"&gt;&lt;/aop:aspectj-autoproxy&gt;\n\n\n\nAOP核心代码如下：\nThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;&gt;();/** * 10、使用excution表达式 * execution( *  modifier-pattern?           //用于匹配public、private等访问修饰符 *  ret-type-pattern            //用于匹配返回值类型，不可省略 *  declaring-type-pattern?     //用于匹配包类型 *  name-pattern(param-pattern) //用于匹配类中的方法，不可省略 *  throws-pattern?             //用于匹配抛出异常的方法 * ) * * 下面的表达式解释为：匹配com.leo.controller.HelloController类中以hello开头的修饰符为public返回类型任意的方法 */@Pointcut(value = \"execution(public * com.leo.controller.HelloController.hello*(..))\")public void pointCut() {}/** * 在方法执行之前执行 * * @param joinPoint */@Before(value = \"pointCut()\")public void beforeLog(JoinPoint joinPoint) {    System.out.println(\"进入LogAop的beforeLogger\");    startTime.set(System.currentTimeMillis());}/** * 在进入类之前执行，然后返回pjp.proceed()之前执行before，再执行方法体，在到after * * @param */@Around(value = \"pointCut()\")public Object aroundLog(ProceedingJoinPoint pjp) throws Throwable {    System.out.println(\"进入LogAop的aroundLogger\");    return pjp.proceed();}/** * 在方法执行返回之后执行 */@After(value = \"pointCut()\")public void afterLog() {    System.out.println(\"进入LogAop的afterLogger\");    long start = startTime.get();    System.out.println(\"方法体执行耗时：\" + (System.currentTimeMillis() - start) + \"ms\");    startTime.remove();}/** * 在返回之后执行 * @param o */@AfterReturning(value = \"pointCut()\",returning = \"o\")public void afterRunningLog(Object o){    System.out.println(\"进入LogAop的afterRunningLog\");    System.out.println(o.getClass());}/** * 在产生异常时执行 */@AfterThrowing(value = \"pointCut()\")public void afterThrowingLog(){    System.out.println(\"进入LogAop的afterThrowingLog\");}\n\n\n\n执行顺序：\n\n先进入@Around\n\n\n\n执行完pjp.proceed()之后，开始进入@Before方法\n\n\n\n执行完@Before中的方法后进入主方法\n\n\n\n执行完主方法体，又回到了@Around的返回值\n\n\n\n然后开始执行@After中内容\n\n\n\n最后到了@AfterReturning方法体中\n\n\n所以，正常的执行顺序是：@Around -&gt;@Before-&gt;主方法体-&gt;@Around中pjp.proceed()-&gt;@After-&gt;@AfterReturning\n如果存下异常那执行顺序是什么呢？以下模拟了一个异常。\n\n首先进入了@Around的方法\n\n\n\n进入了@After的方法\n\n\n\n最后进入了@AfterThrowing的方法\n\n\n因此如果异常在Around中pjp.proceed()之前，则执行顺序为：@Around -&gt; @After -&gt; @AfterThrowing\n同理，如果异常在Around中pjp.proceed()之后，则执行顺序为：@Around -&gt;@Before-&gt;主方法体-&gt;@Around中pjp.proceed()-&gt;@After-&gt;@AfterThrowing\n","categories":["Java","Spring"],"tags":["Java","AOP","SpringBoot"]},{"title":"SpringBoot","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/springboot-xue-xi-bi-ji/","content":"SpringBoot\n第一章\n\n为什么要使用SpringBoot\n因为Spring，SpringMVC需要使用的大量的配置文件（xml文件）\n还需要配置各种对象，把使用的对象放入到spring容器中才能使用对象\n需要了解其他框架配置规则。\n\nSpringBoot就相当于不需要配置文件的Spring+SpringMVC。常用的框架和第三方库都已经配置好了。\n拿来就可以使用 了。\n\nSpringBoot开发效率高，使用方便多了。\n\n\n1.1什么是JavaConfig\n\nJavaConfig：是Spring提供的试音Java类配置容器。配置SpringIOC容器的纯Java方法。在这个Java类这可以创建Java对象，把对象放入Spring容器中（注入到容器）\n\n优点：\n\n\n可以使用面向对象的方式，一个配置类可以继承配置类，可以重写方法\n避免繁琐的xml配置\n\n\n使用两个注解：\n\n@Configuration：放在一个类的上面，表示这个类是作为配置文件使用的。\n@Bean：申明对象，把对象注入到容器中\n\n\nMyTest.java\npackage com.study.config;import com.study.vo.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Configuration:表示当前类是作为配置文件使用的。就是用来配置容器的 * 位置：在类的上面 * SpringConfig这个类相当于beans.xml */@Configurationpublic class SpringConfig {    /**     * 创建方法，方法的返回值是对象。在方法的上面加入@Bean     * 方法的返回值独享就注入到容器中     * @Bean：把独享注入到Spring容器中。作用相当于&lt;bean&gt;     *     位置：方法的上面     *     *     说明：@Bean，不指定对象的名称，默认是方法名是  id     */    @Bean    public Student createStudent(){        Student s1 = new Student();        s1.setName(\"张三\");        s1.setAge(26);        s1.setSex(\"男\");        return s1;    }    /**     * 指定对象在容器中的名称（指定&lt;bean&gt;&lt;/bean&gt;的id属性）     * @Bean的name属性，指定对象的名称（id）     */    @Bean(name = \"lisiStudent\")    public Student makeStudent(){        Student s1 = new Student();        s1.setName(\"李四\");        s1.setAge(22);        s1.setSex(\"男\");        return s1;    }}\n\nSpringConfig.java\npackage com.study.config;import com.study.vo.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Configuration:表示当前类是作为配置文件使用的。就是用来配置容器的 * 位置：在类的上面 * SpringConfig这个类相当于beans.xml */@Configurationpublic class SpringConfig {    /**     * 创建方法，方法的返回值是对象。在方法的上面加入@Bean     * 方法的返回值独享就注入到容器中     * @Bean：把独享注入到Spring容器中。作用相当于&lt;bean&gt;     *     位置：方法的上面     *     *     说明：@Bean，不指定对象的名称，默认是方法名是  id     */    @Bean    public Student createStudent(){        Student s1 = new Student();        s1.setName(\"张三\");        s1.setAge(26);        s1.setSex(\"男\");        return s1;    }    /**     * 指定对象在容器中的名称（指定&lt;bean&gt;&lt;/bean&gt;的id属性）     * @Bean的name属性，指定对象的名称（id）     */    @Bean(name = \"lisiStudent\")    public Student makeStudent(){        Student s1 = new Student();        s1.setName(\"李四\");        s1.setAge(22);        s1.setSex(\"男\");        return s1;    }}\n1.2@ImporResource\n@ImportResource作用导入其他的xml配置文件，等于在xml\n&lt;import resources=\"其他配置文件\"/&gt;\n\n例如：\n@Configuration@ImportResource(value = \"classpath:applicationContext.xml\")public class SpringConfig {//......}\n\n1.3@PropertyResource\n@PropertyResource:读取properties属性配置文件。使用属性配置文件可以实现外部化配置，\n在程序代码之外提供数据。\n步骤：\n\n在resources目录下，创建properties文件，使用k=v的格式提供数据\n在PropertyResource指定properties文件的位置\n使用@Value(value=”${key}”)\n\n@Configuration@ImportResource(value = \"classpath:applicationContext.xml\")@PropertySource(value = \"classpath:config.properties\")@ComponentScan(basePackages = \"com.study.vo\")public class SpringConfig {//......}\n\n第二章\n2.1介绍\nSpringBoot是Spring中的一个成员，可以简化Spring，SpringMVC的使用。他的核心还是IOC容器。\n特点：\n\nCreate stand-alone Spring applications\n创建Spring应用\n\nEmbed Tomcat,Jetty or Undertow directly (no need to deploy WAR files)\n内嵌的tomcat，jetty，Undertow\n\nProvide opinionated ‘starter’ dependencies to simplify your build configuration\n提供了starter起步依赖，简化应用的配置。\n比如使用MyBatis框架，需要在Spring项目中，配置MyBatis的对象SqlSessionFactory，Dao的代理对象\n在SpringBoot项目中，在pom.xml里加入，加入一个mybatis-spring-boot-starter依赖\n\nAutomatically configure Spring and 3rd party libraries whenever possible\n尽可能去配置spring的第三方库。叫做自动配置（就是把Spring中的，第三方库中的对象都创建好，翻到容器中，开发人员可以直接使用）\n\nProvide production-ready features such as metrics,health checks,and externalized configuration\n提供了健康检查，统计，外观化配置\n\nAbsolutely no code generation and no requirement for XML configuration\n不用生成代码，不适用xml，做配置\n\n\n2.2创建Spring Boot项目\n2.2.1第一种方式，使用Spring提供的初始化器，就是向导创建SpringBoot应用使用的地址：https://start.spring.io\n如果国外的下载慢或者下载不了可以改成镜像下载：https://start.springboot.io\nSpringBoot项目的结构：\n\n\n\n2.3 注解使用\n@SpringBootApplication复合注解：由    @SpringBootConfiguration    @EnableAutoConfiguration    @ComponentScan            1.@SpringBootConfiguration    @Configuration    @Indexedpublic @interface SpringBootConfiguration {    @AliasFor(        annotation = Configuration.class    )    boolean proxyBeanMethods() default true;}说明：使用了@SpringBootConfiguration注解标注的类，可以作为配置文件使用的，    可以使用Bean申明对象，注入到容器\n\n2.@EnableAutoConfiguration\n启用自动配置，把java对象配置好，注入到Spring容器中。例如可以把mybatis的对象创建好，放入到容器中\n3.@ComponentScan\n@ComponentScan 扫描器，找到注解，根据注解的功能创建对象，给属性赋值等等。    默认扫描的包：@ComponentScan所在的类所在的包和子包。\n\n2.4SpringBoot的配置文件\n配置文件名称：application\n扩展名有：properties(k=v)；yml(k: v)\n使用application.properties，application.yml\n例1：application.properties设置 端口和上下文\n#设置端口号server.port=8081#设置访问应用上下文路径，contextpathserver.servlet.context-path=/myboot\n\n例2：application.yml\nserver:  port: 8083  servlet:    context-path: /myboot2\n\n@PropetySource注解（加载外部配置文件以及解决SpringBoot默认读取不了外部配置文件问题）\nPropertySource不仅支持加载类路径下的文件，还支持加载本地磁盘上的文件。\n/** * 用户···实体————读取本地磁盘上的配置文件 * * @Component  将本来标识为一个 Spring 组件，因为只有是容器中的组件，容器才会为 @ConfigurationProperties 提供此注入功能 * * @PropertySource 指明加载类路径下的哪个配置文件来注入值，既可以是类路径下，也可以上磁盘上 * * @ConfigurationProperties 表示 告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定； * * * prefix = \"user1\" 表示 将配置文件中 key 为 user 的下面所有的属性与本类属性进行一一映射注入值，如果配置文件中- * * * 不存在 \"user1\" 的 key，则不会为 POJO 注入值，属性值仍然为默认值 * &lt;p&gt; * 磁盘路径可以是相对路径，绝对路径，也可以通过系统属性值指定变量 * * 相对路径，文件在应用根目录下：@PropertySource(value = {\"file:userDisk.properties\"}) * * 相对路径，文件在应用根目录下：@PropertySource(value = {\"file:./userDisk.properties\"}) * * 绝对路径，在指定的路径下：@PropertySource(value = {\"file:D:\\\\project\\\\IDEA_project\\\\yuanyuan\\\\userDisk.properties\"}) * * 通过系统属性值指定变量：@PropertySource(value = {\"file:${user.dir}/userDisk.properties\"}) * * * user.dir：用户的当前工作目录 * * @author wangmaoxiong * Created by Administrator on 2018/7/11 0011. */@Component@PropertySource(value = {\"file:${user.dir}/userDisk.properties\"})@ConfigurationProperties(prefix = \"user2\")public class UserDisk {    private Integer id;    private String lastName;    private Integer age;    private Date birthday;    private List&lt;String&gt; colorList;    private Map&lt;String, String&gt; cityMap;    private Dog dog;\n\nPropertySource注解读取不了外部yml配置文件问题以及解决方案\nPropertySource默认只解析properties配置文件解析不了yml的外部配置文件，如果要读取则必须要重写配置读取配置文件的接口\n解决方案：\n如果要解析yml文件，需要指定factory只需要实现org.springframework.core下的 PropertySourceFactory 接口就OK了。\nYamlPropertySourceFactory.java\nimport org.springframework.beans.factory.config.YamlPropertiesFactoryBean;import org.springframework.core.env.PropertiesPropertySource;import org.springframework.core.env.PropertySource;import org.springframework.core.io.support.EncodedResource;import org.springframework.core.io.support.PropertySourceFactory;import java.io.IOException;import java.util.Properties;public class YamlPropertySourceFactory implements PropertySourceFactory {    @Override    public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException {        YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean();        factory.setResources(resource.getResource());        factory.afterPropertiesSet();        Properties ymlProperties = factory.getObject();        String propertyName = name != null ? name : resource.getResource().getFilename();        return new PropertiesPropertySource(propertyName,ymlProperties);    }}\n\n然后在我们的application启动类上添加@propertySources注解引入我们的外部文件：\n@PropertySources({        @PropertySource(\"file:config/jdbc-db.properties\"),        @PropertySource(value = \"file:config/redis.yml\",factory = YamlPropertySourceFactory.class)})\n\n@ImportResource导入Spring配置文件   1、@ImportResource 注 解用来导入 Spring 的配置文件，如核心配置文件 “beans.xml”，从而让配置文件里面的内容生效；\n   2、如果应用中仍然想采用以前 xml 文件的配置方式，如 “beans.xml” ，则使用 “@ImportResource” 注解轻松搞定。\n   3、将 @ImportResource 标注在一个配置类上，通常直接放置在应用启动类上，和 @SpringBootApplication 一起即可。\n   import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ImportResource;/** * 应用启动类 * * @ImportResource 必须放置在配置类上，通常放在启动类即可，用 value 指明导入类路径下的那个 Spring 配置文件 */@ImportResource(value = {\"classpath:beans.xml\"})@SpringBootApplicationpublic class CocoApplication {    public static void main(String[] args) {        SpringApplication.run(CocoApplication.class, args);    }}\n\n   4、然后就可以在类路径下提供原始的 beans.xml 配置文件：\n   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;!-- 放入到Sping容器中，这是以前Spring的内容，不再累述--&gt;&lt;bean id=\"userService\" class=\"com.lct.service.UserService\"/&gt;&lt;/beans&gt;\n\n   5、启动应用控制台会打印：loading XML bean definitions from class path resource [beans. xml] 表示加载成功。\n2.5多环境配置\n有开发环境，测试环境，上线的环境。\n每个环境有不同的配置信息，例如端口，上下文件，数据库url，用户名，密码等等\n使用多环境配置文件，可以方便的切换不同的配置。\n使用方式：创建多个配置文件，名称规则：application-环境mingcheng.properties(yml)\n创建开发环境的配置文件：application-dev.properties(application-dev.yml)\n创建测试者使用的配置：application-test.properties\napplication.yml 示例：注意：配置多环境yml 文件必须是application开头文件\nspring:\tprofiles:\t \tactive: @spring.profiles.active@\n\n\n\n2.6\n2.7使用JspSpringBoot不推荐使用jsp，而是使用模板技术代替jsp\n使用jsp需要配置：\n\n加入一个处理jsp的依赖。负责编译jsp文件\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;\n\n如果需要使用servlet，jsp的功能\n如：servlet的依赖、jsp的依赖、jstl的依赖。\n\n创建一个存放jsp的目录，一般叫做webapp\nindex.jsp\n\n需要在pox.xml指定jsp文件编译后的存放目录。\nMETA-INF/resources\n\n创建Controller，访问jsp\n\n在application.propertis文件中配置视图解析器\n\n\n2.8使用容器\n你想通过代码，从容器中获取对象。\n通过SpringApplication.run(Application.class,args);返回值获取容器。\n public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) {        return run(new Class[]{primarySource}, args);    }ConfigurableApplicationContext：接口，是ApplicationContext的子接口    public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable\n\nCommandLineRunner接口\n​\t开发中可能会有这样的情景。需要在容器启动后执行一些内容。比如读取配置文件，数据库连接之类的。SpringBoot给我们提供了两个接口来帮助我们实现这种需求。这两个接口分别是CommandLineRunner和ApplicationRunner。他们的实行时机为容器启动完成的时候。这两个接口中有一个run方法，我们只需要实现这个方法计科。这两个接口的不同之处在于：ApplicationRunner中run方法的参数为ApplicationArguments，而CommandLineRunner接口中run方法的参数为String数组\n2.9ComnandLineRunner接口、ApplicationRunner接口\n这个两个接口都有一个run方法，执行时间在容器(SpringApplication.run(…))对象创建好后，自动执行run()方法。\n可以完成自定义的在容器对象创建好的一些操作。\n@FunctionalTnterfacepublic interface CommandLineRunner{    void run(String... args) throws Exception;}@FunctionalInterfacepublic interface Application{    void run(ApplicationArguments args) throws Exception;}\n\n第三章\n讲三个内容：拦截器，Servlet，Filter\n3.1 拦截器\n拦截器是SpringMVC中一种对象，能拦截对Controller的请求。\n拦截器框架中有系统的拦截器，还可以自定义拦截器。实现对请求预先处理。\n实现自定义拦截器：\n\n创建类实现SpringMVC框架的HandlerInterceptor接口\n\npublic interface HandlerInterceptor {    default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        return true;    }    default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {    }    default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {    }}\n\n\n需在SpringMVC的配置文件中，申明拦截器\n\n&lt;mvc:interceptors&gt;\t&lt;mvc:interceptor&gt;    \t&lt;mvc:path=\"url\"/&gt;        &lt;bean class=\"拦截器类全限定名称\"/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;\n\n   SpringBoot中注册拦截器：\n@Configurationpublic class MyAppConfig implements WebMvcConfigurer {    //添加拦截器对象，注入到容器中    @Override    public void addInterceptors(InterceptorRegistry registry) {        //创建拦截器对象        HandlerInterceptor interceptor = new LoginInterceptor();        //指定拦截的请求uri地址        String path[] = {\"/user/**\"};        //指定不拦截的地址        String excludePath[] = {\"/user/login\"};        registry.addInterceptor(interceptor).addPathPatterns(path).excludePathPatterns(excludePath);    }}\n\nHandlerInterceptor.java\npublic class HandlerInteerceptor implements HandlerInterceptor {    @Override    public boolean preHandle(HttpServletRequest request,                             HttpServletResponse response,                             Object handler) throws Exception {        return false;    }}\n\n\n\n3.2 Servlet\n在SpringBoot框架中使用Servlet对象。\n使用步骤：\n\n创建Servlet类。创建类继承HttpServlet\n注册Servlet，让框架能找到Servlet\n\n例子：\n\n创建自定义的Servlet\n//创建Servlet类public class Myservlet extends HttpServlet{    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        doPost(req,resp);    }            @Override    protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {        //使用HttpServletResponse输出数据，应答结果        resp.setContentType(\"text/html;charset=utf-8\");        PrintWriter out = resp.getWriter();        out.println(\"===执行的是Servlet===\");        out.flush();        out.close();    }    }\n\n注册Servlet\n@Configurationpublic class WebApplictionConfig {        //定义方法，注册Servlet对象    @Bean    public ServletRegistrationBean servletRegistrationBean(){                //public ServletRegistrationBean(T servlet, String... urlMapping)        //第一个参数是 Servlet对象，第二个是url地址                //ServletRegistrationBean bean =         \t\t//new ServletRegistrationBean( new MyServlet(),\"/myservlet\");                ServletRegistrationBean bean = new ServletRegistrationBean();        bean.setServlet(new MyServlet());        bean.addUrlMappings(\"/login\",\"/test\");   //&lt;url-pattern&gt;                return bean;            }}\n\n3.3过滤器Filter\nFilter是Servlet规范中的过滤器，可以处理请求，对请求的参数，属性进行调整，常常在过滤器中处理字符编码在框架中使用过滤器：\n\n创建自定义过滤器\n注册Filter过滤器对象\n\n例子：\n//自定义过滤器public class MyFilter implements Filter {    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        System.out.println(\"执行了MyFilter，doFilter\");        filterChain.doFilter(servletRequest,servletResponse);    }}\n\n注册Filter：\n@Configurationpublic class WebApplicationConfig {    @Bean    public FilterRegistrationBean filterRegistrationBean(){        FilterRegistrationBean bean = new FilterRegistrationBean();        bean.setFilter(new MyFilter());        bean.addUrlPatterns(\"/user/*\");        return bean;    }}\n\n3.4字符集过滤器\nCharacterEncodingFilter：解决post请求中乱码问题\n在SpringMVC框架，在web.xml注册过滤器。配置他的属性。\n第一种方式：\n使用步骤：\n\n配置字符集过滤器\n@Configurationpublic class WebSystemConfig {    //注册Servlet    @Bean    public ServletRegistrationBean servletRegistrationBean(){        MyServlet myServlet = new MyServlet();        ServletRegistrationBean reg = new ServletRegistrationBean(myServlet,\"/myservlet\");        return reg;    }    //注册Filter    @Bean    public FilterRegistrationBean filterRegistrationBean(){        FilterRegistrationBean reg = new FilterRegistrationBean();        //使用框架中的过滤器类        CharacterEncodingFilter filter = new CharacterEncodingFilter();        filter.setEncoding(\"utf-8\");        //指定request，response都使用encoding的值        filter.setForceEncoding(true);        reg.setFilter(filter);        reg.addUrlPatterns(\"/*\");        return reg;    }}\n\n修改application.properties文件，让自定义的过滤器起作用\n#SpringBoot中默认已经配置了CharacterEncodingFilter。编码默认ISO-8859-1#设置enabled=false 作用是关闭系统中配置好的过滤器，使用自定义的CharacterEncodingFilterserver.servlet.encoding.enabled=false\n\n第二种方式：\n修改application.properties文件\n#让系统的CharacterEncodingFilter生效server.servlet.encoding.enabled=true#指定使用编码的方式server.servlet.encoding.charset=utf-8#强制request，response都使用charset属性的值server.servlet.encoding.force=true\n\n第四章\n使用MyBatis框架操作数据，在SpringBoot框架集成MyBatis使用步骤：\n\nmybatis起步依赖：完成mybatis对象自动配置，对象放在容器中\n\npom.xml指定把src/main/java目录中的xml文件包含到classpath中\n\n创建实体类Student\n\n创建Dao接口StudentMapper（StudentDao），创建一个查询学生的方法\n\n创建Mapper（Dao）接口对应的Mapper文件，xml文件，写sql语句\n\n创建Service层对象，创建StudentService接口和他的实现类。去dao对象的方法。完成数据库的操作\n\n创建Controller对象，访问Service。\n\n写application.properties文件\n配置数据库的连接信息。\n\n\n第一种方式：@Mapper@Mapper：放在dao接口的上面，每一个接口都需要使用这个注解\n/** * 告诉MyBatis这是dao接口，创建此接口的代理对象。 */@Mapperpublic interface UserMapper {    User selectById(@Param(\"userId\") Integer id);}\n\n第二种方式 @MapperScan@SpringBootApplication@MapperScan(basePackages = \"com.study4.springboot_4.mapper\")public class SpringBoot4Application {}\n\n第三种方式：Mapper文件和Dao接口分开管理现在Mapper文件放在resources目录下\n\n在resources目录中创建子目录（自定义的），例如mapper\n把mapper文件放到mapper目录中\n在application.properties文件中，指定mapper文件的目录\n\n#指定mapper文件的位置mybatis.mapper-locations=classpath:mapper/*.xml#mybatis日志输出mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n\n\n在pom.xml中指定把resources目录中\n\n&lt;resource&gt;    &lt;directory&gt;src/main/resources&lt;/directory&gt;    &lt;includes&gt;        &lt;include&gt;**/*.properties&lt;/include&gt;        &lt;include&gt;**/*.xml&lt;/include&gt;    &lt;/includes&gt;&lt;/resource&gt;\n\n第四个 事务Spring框架中的事务：\n\n管理事务的对象：事务管理器（接口，接口有很多的实现类）\n例如：使用JDBC或MyBatis访问数据库，使用的事务管理器：DataSourceTransactionManager\n\n声明式事务：在xml配置文件或者使用注解说明事务控制的内容\n控制事务：隔离级别，传播行为，超时时间\n\n事务处理方式：\n\nspring框架中的@Transactional\naspectj框架可以在xml配置文件中，声明事务控制的内容\n\n\n\nSpringBoot中使用事务：上面的两种方式都可以。\n\n在业务方法的上面加入@Transactional，加入注解后，方法有事务功能了。\n明确的在主启动类的上面，加入@EnableTransactionManager\n\n例子：\n/*** @Transactional：表示方法的有事务支持* \t\t默认：使用库的隔离级别，REQUIRED 传播行为；超时时间 -1* \t\t抛出运行时异常，回滚事务*/@Transactional@Overridepublic int addUser(User user) {    System.out.println(\"业务方法addUser\");    int rows = userMapper.insert(user);    System.out.println(\"执行sql语句\");    //抛出一个运行时异常，目的是回滚事务    //int m = 10/0;    return rows;}\n\n\n\nMyBatis代码自动生成插件&lt;!--            mybatis代码自动生成插件--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.6&lt;/version&gt;                &lt;configuration&gt;&lt;!--                    配置文件的位置:在项目的根目录下，和src是平级的--&gt;                    &lt;configurationFile&gt;GeneratorMapper.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;\n\n第五章 接口架构风格——RESTful\nAPI之主要目的是提供应用程序与开发人员以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。提供API所定义的功能的软件称作此API的实现。API是一种接口，故而是一种抽象。\n应用程序接口（英语：Application Programming Interface，简称：API），又称为应用编程接口，就是软件系统不同组成部分衔接的约定。由于近年来软件的规模日益庞大，常常需要把复杂的系统划分成小的组成部分，编程接口的设计十分重要。程序设计的实践中，编程接口的设计首先要使软件系统的职责得到合理划分。良好的接口设计可以降低系统各部分的相互依赖，提高组成单元的内聚性，降低组成单元间的耦合程度，从而提高系统的维护性和扩展性。\n接口（API）：可以指访问Servlet，controller的url，调用其他程序的 函数\n架构风格：api组织方式（样子）\n就是一个传统的：http://localhost:9001/study/addUser?name=白姬&amp;age=12\n​\t\t\t\t\t\t\t在地址上提供了访问的资源名称addUser，在其后使用了get方式传递参数。\nRESTful架构风格\n\nREST（中文：表现层状态转移）\nREST（英文：Representational State Transfer，简称REST）\n一种互联网软件架构设计的风格，但它并不是标准，它只是提出了一组客户端和服务端交互时的架构历年和设计原则，基于这种理念和原则设计的接口可以更简洁，更有层次，REST这个词，是Roy Fielding在他2000年的博士论文中提出的。\n​        任何的技术都可以实现这种理念，如果一个架构符合REST原则，就称它为RESTFul架构\n​        比如我们要访问一个http接口：http://localhost:8080/boot/order?id=1021&amp;status=1\n​        采用RESTFul风格则http地址为：http://localhost:8080/boot/order/1021/1\n\n\n​\t\t表现层状态转移：\n​\t\t\t\t表现层就是视图层，显示资源的，通过视图页面，jsp等等显示操作资源的结果。\n​\t\t\t\t状态：资源变化\n​\t\t\t\t转移：资源可以变化的。资源能创建，new状态，资源创建后可以查询资源，能看到资源的内容，这个资源内容，可以被修改，修改后资源和之前的不一样。\n\nREST中的要素：\n用REST表示资源和对资源的操作。在互联网中，表示一个资源或者一个操作。\n资源使用url表示的，在互联网，使用的图片，视屏，文本，网页等等都是资源。\n资源是用名词表示。\n\n\n​\t\t对资源：\n​\t\t\t\t查询资源：看，通过url找到资源。\n​\t\t\t\t创建资源：添加资源\n​\t\t\t\t更新资源：更新资源，编辑\n​\t\t\t\t删除资源：去除\n​\t\t资源使用url表示，通过名词表示资源。\n​\t\t\t在url中使用名词表示资源，以及访问资源的信息，在url中，使用“/”分隔资源的信息\n​\t\t\thttp://localhost:8080/myboot/student/1001\n​\t\t使用http中的动作（请求方式），表示对资源的操作（CURD）\n​\t\t\t       GET：查询资源\n​\t\t\t\t\t\t\thttp://localhost:8080/myboot/student/1001\n​\t\t\t\t\t\t\thttp://localhost:8080/myboot/student/1001/1\n​\t\t\t\t\t\t\t处理多个资源：使用复数形式\n​\t\t\t\t\t\t\thttp://localhost:8080/myboot/students/1001/1002\n​\t\t    \tPOST：创建资源 –sql insert\n​\t\t\t\t\t\t\thttp://localhost:8080/myboot/student\n​\t\t\t\t\t\t\t在post请求中传递数据\n&lt;form action=\"http://localhost:8080/myboot/student\" method=\"post\"&gt;    姓名：&lt;input type=\"test\" name=\"name\"/&gt;    年龄：&lt;input type=\"text\" name=\"age\"/&gt;&lt;/form&gt;\n\n​\t\t\t       PUT：更新资源 –sql update\n&lt;form action=\"http://localhost:8080/myboot/student/1\" method=\"post\"&gt;    姓名：&lt;input type=\"test\" name=\"name\"/&gt;    年龄：&lt;input type=\"text\" name=\"age\"/&gt;    \t &lt;input type=\"hidden\" name=\"_method\" value=\"PUT\"/&gt;&lt;/form&gt;\n\n\n\n​\t\t\tDELETE：删除资源 –sql delete\n&lt;a href=\"http://localhost:8080/myboot/student/1\"&gt;删除1的数据&lt;/a&gt;\n\n需要的分页，排序等参数，依然放在url的后面，例如：\nhttp://localhost:8080/myboot/student?page=1&amp;pageSize=20\n\n一句话说明REST：\n使用url表示资源，使用http动作操作资源。\n\n注解\n@PathVariable：从url中获取数据\n@GetMapping：支持的get请求方式，等同于@RequestMapping(method=RequestMethod.GET)\n@PostMapping：支持post请求方式，等同于@RequestMapping(method=RequestMethod.POST)\n@PutMapping：支持put请求方式，等同于@RequestMapping(method=RequestMethod.PUT)\n@DeleteMapping：支持delete请求方式，等同于@RequestMapping(method=RequestMethod.DELETE)\n\n\n​\t\t@RestController：复合注解，是@Controller和@ResponseBody组合。\n​\t\t\t\t\t在类的上面使用@RestController，表示当前类者的所有方法都加入了@ResponseBody \n\nPostman：测试工具\n是哟Postman：可以测试get，post，put，delete等请求\n\n\n常见问题解决\n1. Mapper.xml中出现多嵌套类的注入解决 &lt;resultMap id=\"usermap\" type=\"com.xiaobei.xiaobei_server.pojo.User\"&gt;        &lt;id property=\"id\" column=\"id\"/&gt;        &lt;result property=\"userName\" column=\"user_name\"/&gt;        &lt;result property=\"userAccount\" column=\"user_account\"/&gt;        &lt;result property=\"userPassword\" column=\"user_password\"/&gt;        &lt;result property=\"health_startTime\" column=\"health_startTime\"/&gt;        &lt;result property=\"health_endTime\" column=\"health_endTime\"/&gt;        &lt;result property=\"health_playTime\" column=\"health_playTime\"/&gt;        &lt;association property=\"playCardMessage\" javaType=\"com.xiaobei.xiaobei_server.pojo.PlayCardMessage\" resultMap=\"playCardMessage\"/&gt;    &lt;/resultMap&gt;&lt;resultMap id=\"playCardMessage\" type=\"com.xiaobei.xiaobei_server.pojo.PlayCardMessage\"&gt;        &lt;result property=\"temperature\" column=\"health_temperature\"/&gt;        &lt;result property=\"coordinates\" column=\"health_coordinates\" /&gt;        &lt;result property=\"location\" column=\"health_location\"/&gt;        &lt;result property=\"healthState\" column=\"health_healthState\"/&gt;        &lt;result property=\"dangerousRegion\" column=\"health_dangerousRegion\"/&gt;        &lt;result property=\"dangerousRegionRemark\" column=\"health_dangerousRegionRemark\"/&gt;        &lt;result property=\"contactSituation\" column=\"health_contactSituation\"/&gt;        &lt;result property=\"goOut\" column=\"health_goOut\"/&gt;        &lt;result property=\"goOutRemark\" column=\"health_goOutRemark\"/&gt;        &lt;result property=\"remark\" column=\"health_remark\"/&gt;        &lt;result property=\"familySituation\" column=\"health_familySituation\"/&gt;    &lt;/resultMap&gt;\n\n定义好之后然后使用resultMap定义返回值就行，==不管数组还是单个对象的返回都用resultMap==，因为这里有多重嵌套的类。\n2. 各种注入类注解使用规范\n@Controller 控制器（注入服务）\n用于标注控制层，相当于struts中的action层\n\n@Service 服务（注入dao）\n用于标注服务层，主要用来进行业务的逻辑处理\n\n@Repository（实现dao访问）\n用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件\n\n@Component （把普通pojo实例化到spring容器中，相当于配置文件中的 ）\n泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。Component注解也会当做配置类，但是并不会为其生成CGLIB代理Class，所以在生成Driver对象时和生成Car对象时调用car()方法执行了两次new操作，所以是不同的对象。当时Configuration注解时，生成当前对象的子类Class，并对方法拦截，第二次调用car()方法时直接从BeanFactory之中获取对象，所以得到的是同一个对象。一般用@Configguration是更优的\n\n3. 前端传入时如何获取以及格式化问题1.问题描述1.数据库里的日期为date类型，java如何进行接收？2.前端传过来的时间，后端如何接收？3.后端如何将时间存入数据库？4.写入数据库的时间会比传入的时间提前一天？2.解决方法2.1两个注解解决接收问题@DateTimeFormat(pattern = \"yyyy-MM-dd\")@JsonFormat(pattern=\"yyyy-MM-dd\",timezone=\"GMT+8\")private Date award_date;//这里是你自己的时间类型的字段，在它上面加上这两个注解即可\n\n\n\n@DateTimeFormat入参注解；格式化接收前端的时间字符串为正确格式\n@JsonFormat出参注解；格式化从数据库库里面查询出来的时间为正确格式\npattern参数可以自由定制。\ntimezone参数用于调整时区\n\n2.2一个参数解决时间提前问题  这只要是由于时区的问题，所以时间上面会提前8小时，自己把它加上去就好了。可以直接在连接数据库的语句后面添加参数serverTimezone=GMT%2B8  我这里加载在末尾，拼接完整的如下所示：\nurl: jdbc:mysql://127.0.0.1:3308/stusystem?characterEncoding=utf8&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=GMT%2B8\n\n参数里的GMT%2B8实际上就是GMT+8,只不过在拼接的时候得用%2B才行。\n注入注解使用问题\n注意：在使用对应的类的时候不能使用new的形式创建，否则对应类内部的注入注解将会全部失效。\n常见SpringBoot配置\nspring:  application:    name: security6 #配置应用名称  datasource:    url: jdbc:mysql://localhost:3306/security6?useUnicode=true&amp;characterEncoding=UTF-8 #配置数据源url    driver-class-name: com.mysql.cj.jdbc.Driver #配置数据源的数据库驱动    username: root #数据库的账号    password: 12345678 #数据库的密码server:  port: 8080 #服务器的端口  tomcat: #Tomcat相关配置    max-connections: 8192 #最大连接数    accept-count: 100 #等待队列长度    threads:      max: 500 #最大工作线程数      min-spare: 10 #最小空闲线程数\n\n针对4C8G的Tomcat配置，可以参考建议值：tomcat:accept-count: 1000max-connections: 10000max-threads: 800min-spare-threads: 100\n\n\n\n\n\n","categories":["Java","Spring"],"tags":["Java","SpringBoot"]},{"title":"SpringCloud学习笔记","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/springcloud-xue-xi-bi-ji/","content":"SpringCloud学习笔记\n1.Spring Cloud Eureka简介注册发现中心\nEureka来源于古希腊词汇，意为“发现了”。在软件领域，Eureka是Netflix在线影片公司开源的一个服务注册与发现的 组件，和其他Netflix公司的服务组件（例如负载均衡、熔断器、网关等）一起，被Spring Cloud社区整合为 Spring Cloud Netflix模块。\nEureka是Netflix贡献给Spring Cloud的一个框架！Netflix给Spring Cloud贡献了很多框架，后面我们会学习到！\n2.Spring Cloud Eureka和Zookeeper的区别2.1什么是CAP原则（面试）\n在分布式 微服务里面CAP定理\n问：为什么zookeeper不适合做注册中心？\nCAP原则又称CAP定理，指的是在一个分布式系统中，\n一致性（Consistency）：三个机器中数据中一致的\n可用性（Availability）：当有一个节点挂掉了整个集群可以继续对外提供服务\n分区容错性（Partition tolerance） （这个特性是不可避免的）：由于机房或者分区等原因会导致各个机器中的数据短暂不一致\nCAP原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。\nCP、AP\nzk遵循CP原则\neureka注重AP高可用\neureka默认端口号为8761\n\n@EnableEurekaServer注解：开启eureka的注册中心的功能（在SpringBoot启动函数上面添加）\n\nDS replicas：集群相关信息\nIndtances currently registered with Eureka：当前在eureka里面注册哪些实例 真实的例子 具体的东西 class new Object\nStatus：实例 的状态和ID\nSpringCloud中的常用配置\n\n\n集群的深入理解\n如果是主从模式 主机该怎么选择？\n如果是主从模式 数据是怎么同步的？  \n\n分布式数据一致性协议： Paxos raft\nEureka概念的理解\n服务的注册\n当项目启动时（eureka的客户端——，就会向eureka-server发送自己的元数据（原始数据）（运行的ip，端口port，健康的状态监控等，因为使用的是http/Restful请求风格），eureka-server会在自己内部保留这些元数据（内存中）。（有一个服务列表）（restful风格，以http动词的请求方式，完成对url资源的操作）\n\n服务的续约\n项目启动成功了，除了向eureka-server注册自己成功，还会定时的向eureka-server汇报自己，心跳，表示自己还活着。（修改一个时间）\n\n服务的下线（主动下线）\n当项目关闭时，会给eureka-server报告，说明自己要下机了。\n\n服务的剔除（被动下线，主动剔除）\n\n当项目超过了指定时间没有向eureka-server汇报自己，那么eureka0server就会认为此节点死掉了，会把它剔除掉，也不会放流量和请求到此节点 了。\n\nEureka运作原理的特点\nEureka-server对外提供的是restful风格的服务\n以http动词的形式对url资源进行操作 get、post、put、delete\nhttp服务+特定的请求方式url地址\n只要利用这些restful我们就能对项目实现注册和发现\n只不过，eureka已经帮我们使用java语言写了client，让我们的项目只要依赖client就能实现注册和发现！\n只要你会发起Http请求，那你就有可能自己实现服务的注册和发现。不管你是什么语言！\n\nEureka的yml配置文件：\nserver:\tport: 8761  #eureka的默认端口8761spring:\tapplication:\t\tname: eureka-server #应用名称 不要使用特殊字符（必须要写应用名称）eureka: #eureka的配置分为三类 sever client 实例的 eureka-server既是服务端有事客户端\tserver:\t\teviction-interval-timer-in-ms: 10000 #服务端间隔多少毫秒做定期删除的操作\t\trenewal-percent-threshold: 0.85  #续约百分比 超过85%的应用没有和你续约 那么eureka会保护服务 不会剔除\tinstance: #实例的配置\t\tinstance-id: ${eureka.instance.hostname}:${spring.application.name}:${server.port} \t\thostname: locahost #主机名称或者服务的ip\t\tprefer-ip-address: true # 以ip的形式显示具体的服务信息\t\tlease-renerwal-interval-in-seconds: 5 #服务实例的续约的时间间隔\tclient:\t\tservice-url:\t\t\tdefaultZone: http://localhost:8761/eureka,...(可以注册多个，用“,”隔开)\t\tregister-with-eureka: false  #先将server自己注册自己的开关（目前为关掉，默认为true  ）\t\tfetch-registry: true #要不要去注册中心里获取其他服务地址\t\t\n\nyml使用技巧：\n 比如defaulZone里面\n#如果EUREKA_SERVER_URL能获取到值就采用这个，否则就使用“:”后面的默认设定defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761}\n\n\nSpring Cloud RibbonRibbon概述\nSpring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具，它基于Netflix Ribbon实现。通过Spring Cloud的封装，可以让我们轻松地将面向服务的REST模板请求自动转换成客户端负载均衡的服务调用。轮询hash权重…\n简单的说Ribbon就是netfix公司的一个开源项目，主要功能是提供客户端负载均衡算法和服务 调用。Ribbon客户端组件提供了一套完善的配置项，比如连接超时，重试等。\n在Spring Cloud构建的微服务系统中，Ribbon作为服务 消费者的 负载均衡器，有两种使用方式，一种是和RestTemplate相结合，另一种是和OpenFeign相结合。OpenFeign已经默认集成了Ribbon，关于OpenFeign的内容将会在下一章进行详细讲解。Ribbon有很多子模块，但很多模块没有用于生产环境！\n\nribbon:\teager-load:\t\tenabled: true #ribbon 借助eureka拉取服务列表\teureka:\t\tenabled: true\thttp:  #  我们使用ribbon 用的restTemplate发请求 java.net.HttpUrlConnection 发的请求  很方便  但是它不支持连接池\t\tclient: false  #发请求的工具很多 httpClient 它支持连接池 效率好 如果你想改请求的工具 记得加上这个依赖即可\tokhttp: # 这个也是请求工具 移动端用的比较多 轻量 的请求\t\tenabled: false\n\n\n\n\n\n\n\n负载均衡\n负载均衡，英文名称为Load Balance（LB）http://  lb://（负载均衡协议），其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如Web服务器、企业核心应用服务器和 其它主要任务服务器等，从而协同完成工作任务。\n负载均衡构建在原有网络结构之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性。\n\n@LoadBalanced注解(如果加了Eureka组件就户需要单独导入Ribbon了，Eureka自带)\n使用这个注解加在RestTemplate();那么RestTemplate的 操作都会由ribbon来 操作\n@Bean @LoadBalanced public RestTemplate restTemplate(){     return new RestTemplate(); }\n\n思考ribbon是这么将http://provider/hello 路径请求成功的http://127.0.0.1:8080/hello1.拦截这个请求2.截取主机名称3.借助eureka来做服务发现list&lt;&gt;4.通过负载均衡算法 拿到一个服务ip port5.reConstructURL6.发起请求\n只要你给restTemplate加了ribbon的注解 项目中这个对象发起的请求 都会走ribbon的代理\n如果你想使用原生的restTemplate 就需要重新创建一个对象\n\n按什么顺序启动服务好\n\n最好先启动服务，再启动注册中心，然后再启动客户端（consumer）\n因为consumer会每隔一段时间拉取注册中心的服务列表，而注册中心一下不会更列表，如果先启动consumer那么就会一开始拉取不到后面的服务（因为服务未开启注册中心的列表中没有任何服务）\n\nFeign(里面默认自带了Ribbon！！！不用导)Feign是申明性（注解）Web服务客户端。它使编写Web服务客户端更加容易。要使用Feign，请创建一个接口并对其进行注解。它具有可插入注解支持，包括Feign注解和JAX-RS注解。Feign还致辞可插拔编码器和解码器。Spring Cloud添加了对SpringMVC注解的支持，并支持使用HttpMessageConverters，SpringWeb中默认使用的注解。SpringCloud集成了Ribbon和Eureka以及SpringCloud LoadBalancer，以在使用Feign时提供负载平衡的http客户端。\nFeign是一个远程调用的组件（接口，注解）http调用的\nFeign集成了Ribbon Ribbon里面集成了eureka\nFeign中yml配置\n# feign只是帮你封装了远程调用的功能  底层还是ribbon  所以我们需要去修改ribbon的时间ribbon:  ReadTimeout: 3000 # 给3s超时时间  ConnectTimeout: 3000 # 链接服务的超时时间\n\n\nFeign调用参数处理（开发重点）说在前面\nFeign传参确保消费者和提供者的参数列表一致 包括返回值 方法签名要一致\n1.通过URL传参数，GET请求，参数列表使用@PathVariable(“”)\n2.如果GET请求 ，每个继承参数必须加@RequestParam(“”)\n3.如果是POST请求，而且是对象集合等参数，必须加@RequestBody或者@RequestParam\n\nFeign日志打印\n在SpringBoot启动中添加打印日志输出Bean\n@SpringBootApplication@EnableEurekaClient@EnableFeignClients  //开启feign的客户端功能 才可以帮助我们发起调用public class Study41Application { public static void main(String[] args) {     SpringApplication.run(Study41Application.class, args); } /**     * 打印feign日志信息 级别     * @return     */    @Bean    public Logger.Level level(){        return Logger.Level.FULL;    }}\n\n在yaml文件中配置：\nlogging:  level:    com.study4_1.study4_1.feign.UserOrderFeign: debug  #我需要打印这个接口下面的日志            \nSpring Cloud Hystrix什么叫服务雪崩：\n\n在一个分布式的系统中如果A服务请求B服务B可能要调用C服务，这个过程叫做链式调用\nABC是三个不同的Tomcat。\n1.用户去请求A服务，A的tomcat会分配一个线程支持用户的访问\nA发现需要完成用户的操作，需要去调用B\n2.A去请求B，B的tomcat也会分配一个线程支持A的访问。B发现需要完成A的操作需要调用C。\n3.B去调用C，但是C宕机了，B并不知道还是一如既往的去访问C。导致A和B的线程都没有回收，此时有大量请求进入A服务或者B服务。AB会报错503 Service Unavailable。\n在分布式的链路中只要有一个服务宕机那么就可能导致一整个服务链瘫痪\n服务雪崩的核心本质是什么？\n线程没有及时回收\n熔断，熔断！\n直接return，业务是不能完成。但是可以缓解服务器压力\n1.调整等待时间这样可以缓解压力，但是很有局限性不灵活，有的服务可能需要多的时间去执行\n2.在上游服务中直到下一个服务的状态如果是ok的 就正常访问，如果是宕机了，那么就return。这样就可以缓解服务雪崩。\n我们可以容忍服务挂掉，我们需要做对应的调整，我们可以设置一个被选方案（备胎）\n\n熔断器，也叫断路器！（正常情况下 断路器是关的 只有出了问题才打开）用来保护微服务不雪崩的方法。思想和我们上面画的拦截器一样。\nHystrix是Netfix公司开源的一个项目，它提供了熔断器功能，能够阻止分布式系统中出现联动故障。Hystrix是通过隔离服务的访问点阻止联动故障的，并提供了故障的解决方案，从而提高了整个分布式系统的弹性。微博 弹性云扩容 Docker K8s\nHystrix快速入门设置拦截器：\n\n如何开启Hystrix：\n2.0版本前只要导入Hystrix然后在yml用如下配置就行\nfeign:  hystrix:    enabled: true\n\n但是超过2.0后此yaml配置改为了：\nfeign:  circuitbreaker:    enabled: true\n\n然后注意在SpringBoot启动类中加入：\n@EnableHystrix启动注解\n\n\nHystrix常用yaml配置：hystrix:\tcommand:  #default是全局控制，也可以换成单个方法控制，把default换成方法名即可\t\tcircuitBreaker:\t\t\tenabled: true  #开启断路器\t\t\trequestVolumeThreshold: 3 #失败次数(阈值) 10次\t\t\tsleepWindowInMilliseconds: 20000 #窗口时间\t\t\terrorThesholdPerventage: 60 #失败率\t\texecution:\t\t\tisolation:\t\t\t\tStrategy: thread #隔离方式thread线程隔离集合 和SEMAPHORE信号量隔离级别\t\t\t\tthread:\t\t\t\t\ttimeoutInMilliseconds: 3000 #调用超时时长\t\tfallback:\t\t\tisolation:\t\t\t\tsemaphore:\t\t\t\t\tmaxConcurrentRequests: 1000 #信号量隔离级别最大并发数ribbon:\tReadTiemout: 5000 #要结合feign的底层ribbon调用的时长\tConnectTimeout: 5000\t#隔离方法 两种隔离方式 thread线程池 按照group(10个线程)划分服务提供者，用户请求的线程和做远程的线程不一样#好处 当B服务调用失败了 或者请求B服务的量太大了 不会对C服务造成影响 用户访问比较大的情况下使用比较好 异步的方式# 缺点 线程间开销大，对机器性能影响# 应用场景 调用第三方服务 并发量大的情况下# SEMAPHORE 信号量隔离 每次请求进来 有一个原子计数器 做请求次数的++ 当请求完成以后 --\n\nhystrix本质是代理的feign的请求才能完成熔断的效果\n链路追踪的由来\n在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同生产最后的请求结果，每一个请求都会开成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引导起整个请求最后的失败。（不建议微服务中链路调用超过3次）\n\n分布式链路调用的监控\nsleuth+zipkin(zipkin就是一个可视化的监控控制台)\nZipkin是Twitter的一个开源项目，允许开发者收集Twitter各个服务上的监控数据，并提供查询接口。\n该系统让开发者可通过一个Web前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等 可方便的监测系统中存在的瓶颈\n\nZipkin(可视化平台)\nSpringCloud从F版以后已经不需要自己构建Zipkon server了，只需要调用jar包即可\nhttps://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkon-server/\nhttps://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkon-server/2.12.9/\n\n\nSleuth快速入门eureka-server\nconsumer-user-service\nprovider-order-service\n1.添加依赖consumer-user-service和provider-order-service都要加\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2.修改配置文件consumer-user-service和provider-order-service都要该配置文件\nspring:\tzipkin:\t\tbase-url: http://localhost:9411\tsleuth:\t\tsampler:\t\t\tprobability: 1  #配置采样率 默认的采样比例为：0.1 即10%，所设置的值介于0到1之间，1则表示全部采集\t\t\trate: 10 #为了使用速率限制采样器，选择每秒间隔接受的 trace量，最小数字为0，最大值为2,147,483,647（int）默认为10。\n\n\n\n\n\nAdmin监控\n导包之后记得在SpringBoot启动上面加上注解：\n@EnableAdminServer//要配合EnableEurekaClient使用，因为要EnableClient拉取EnableServer(注册端)的服务列表\n\n监控端需要加入的依赖：\n\n&lt;dependency&gt;    &lt;groupId&gt;de.codecentric&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;&lt;/dependency&gt;\n监控端如果想监控自己实际详细内容yml配置\n\nmanagement:  endpoints:    web:      exposure:        include: '*'   #暴露所有的监控端点（就是暴露Admin的所有详细的内容），如果一个服务需要被将空 那么就要将自身的一些情况（一些信息接口）暴露出去\n\n\n被监控端需要加入actuator依赖（不加的监控端点显示离线监控，但是能知道端点存活）：\n\n&lt;!--        暴露自身检查端点 endpoints--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;\n想要被监控端展示实际详细内容yml配置：\n\nmanagement:  endpoints:    web:      exposure:        include: '*'   #暴露所有的监控端点（就是暴露Admin的所有详细的内容），如果一个服务需要被将空 那么就要将自身的一些情况（一些信息接口）暴露出去\n\n\nSpring Cloud Gateway(网关)\n先说什么是海关？\n你出国或者回国都得经过海关才能进出自己的国家否则不准，网关也是这个意思。\n\n网关可以承担的作用： \n1.路由转发\n2.安全控制 保护每个服务 不需要将每个服务暴露出去\n3.负载均衡\n什么是网关网关是微服务最边缘的服务，直接暴露给用户，用来做用户和微服务的桥梁\n1.没有网关：客户端直接访问我们的微服务，会需要在客户端配置很多的ip：port，如果user-servie并发比较大，则无法完成负载均衡\n2.有网关：客户访问网关，网关来访问微服务，（网关可以和注册中心整合，通过服务名称找到目标的ip：port）这样只需要使用服务名称即可访问微服务，可以实现负载均衡 ，可以实现token拦截，权限验证，限流等操作\n你们项目里面 用的什么网关？ gateway(SpringCloud官方网关)  zuul他是Spring Cloud官方提供的用来取代zuul(netflix)的新一代网关组件\n（zuul：1.0，,2.0，zuul的本质，一组过滤器，根据自定义的过滤器，根据自定义的过滤器顺序来执行，本质就是web组件 web三大组件（监听器 过滤器 servlet）  拦截 springmvc）\nZuul1.0  使用的是BIO（Blocking  IO） tomcat7.0以前都是BIO性能一般\nZuul12.0 性能好NIO\nAIO  异步非阻塞io  a+nio = aio = async + no blocking  io\nGateway的核心是过滤器，按照先后执行顺序来执行过滤操作 order 0 1 2\nweb三大组件servlet\nlistener\nfilter过滤器（啥都拦截 ）\ninterceptor 拦截器 他是springmvc的，主要拦截进入controller的请求的\n总结：Gateway的核心逻辑也就是  路由转发+执行过滤器链\nSpring Cloud Gateway三大核心概念Route（路由）（重点  和 eureka结合做动态路由）路由信息的组成：\n由一个ID、一个目的URL、一组断言工厂、一组Filter组成、\n如果路由断言为真，说明请求URL和配置路由匹配。\nPredicate（断言）（就是一个返回bool的表达式）Java8中的断言函数。lambda四大接口 供给型，消费型，函数型，断言型\nSpring Cloud Gateway 中的断言函数输入类型是Spring5.0框架中的SererWebExchange。Spring Cloud Gateway的断言函数允许开发者去定义匹配来自于Http Request中的任何信息比如请求头 和参数。\nFilter（过滤）（重点）一个标准的Spring WebFilter。 web三大组件（servler listener filter）mvc interceptor\nSpring Cloud Gateway 中的Filter分为两种类型的Filter，分别是Gareway Filter和Global Filter。过滤器Filter将会对请求和相应进行修改处理。\n一个是针对某一个路由的filter  对某一个接口做限流\n一个是针对全局filter    token   ip黑名单\nGateway快速入门1.不用选择SpringWeb，Gareway用的自带的Netty！！！！（只要加入gareway依赖就行，其他都不用加）！！！！！！\n配置网关只要在application.yml或者properties里面设置就行\nGateway网关yml配置文件方式配置路由cloud:  gateway:    enabled: true   # 只要加了依赖  默认开启    routes:      - id: login-service-route  #  这个是路由的id 保持唯一即可        uri: http://localhost:8081  # uri统一资源标识符  url统一资源定位符        predicates:          - Path=/doLogin  #  匹配规则  只要你匹配上了/doLogin 就往uri转发 并且将路径带上\t\t  #- Path=/doLogin/**  \n\nGateway网关代码方式配置路由@Configurationpublic class RouteConfig {    @Bean    public RouteLocator customRouteLocator(RouteLocatorBuilder builder){        return builder.routes()                .route(\"login_service\",r-&gt; r.path(\"/guochuang\").uri(\"http://www.bilibili.com/\"))                .build();    }}\n\nyml配置文件方式与java代码配置方式不冲突，两者可以一起用\n如果你的uri后面给了一个访问地址  和匹配地址相同  那么就不会再拼接 \n动态路由\n动态路由需要结合注册发现中心（Eureka）\n\n动态路由先要在Gateway中使用EurekaClient拉取EurekaServer的服务注册表，然后以后访问就可以使用http://…/[服务名称]/url确切拼接路径名\ncloud:  gateway:    enabled: true   # 只要加了依赖  默认开启    discovery:      locator:        enabled: true  # 开启动态路由 开启通用应用名称 找到服务的功能        lower-case-service-id: true #开启服务名称小写\n\n第二种动态路由写法方式（推荐这种，这种不需要在访问路径加服务名称就可以直接访问）cloud:  gateway:    enabled: true   # 只要加了依赖  默认开启    routes:      - id: login-service-route  #  这个是路由的id 保持唯一即可        #uri: http://localhost:8081  # uri统一资源标识符  url统一资源定位符        uri: lb://login-service        predicates:          - Path=/doLogin  #  匹配规则  只要你匹配上了/doLogin 就往uri转发 并且将路径带上\t\t  #- Path=/doLogin/**  \n\n\n\n\n\nPredicate 断言工厂的使用【了解】在gateway启动时会去加载一些路由断言工厂（判断一句话是否正确 一个boolean表达式）\n断言是给某一个路由来设定的，比如：\ncloud:  gateway:    enabled: true   # 只要加了依赖  默认开启    routes:      - id: login-service-route  #  这个是路由的id 保持唯一即可        #uri: http://localhost:8081  # uri统一资源标识符  url统一资源定位符        uri: lb://login-service        predicates:          - Path=/doLogin  #  匹配规则  只要你匹配上了/doLogin 就往uri转发 并且将路径带上\t\t  #- Path=/doLogin/**            - After=2022-03-22T09:42:59.521+08:00[Asua/Shanghai] #设定这个条件，就是说这个时间之后才可以访问这个路由，这就是断言的一种体现\n\n能够添加断言条件的有这些\n比如：\n\n默认不能作用在动态路由上\nFilter过滤器工厂（重点）\n概述gateway里面的过滤器和Servlet里面的过滤器，功能差不多，路由过滤器可以用于修改进入Http请求的返回Http响应\n\n分类按生命周期分两种pre  在业务逻辑之前\npost  在业务逻辑之后\n按种类分也是两种GatewayFilter  需要配置某个路由，才能过滤。如果需要使用全局路由，需要配置Default Filters。\n可以记录接口的访问次数，限流操作\nGlobalFilter  全局过滤器，不需要配置路由，系统初始化作用到所有路由上\n全局过滤器  统计请求次数  限流  token的校验  ip黑名单拦截   跨域本质（filter）\n144  开头的电话  限制一些ip的访问\nGlobalFilter过滤器使用：\n/** * 定义了一个过滤器 * 如果有多个过滤器那么我们还要定义顺序， */@Componentpublic class MyGlobalFilter implements GlobalFilter, Ordered {    /**     * 这个就是过滤的方法     * 责任链模式     * 网关里面有使用   mybatis的 二级缓存变种责任链模式     * @param exchange     * @param chain     * @return     */    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        //针对 请求的过滤 拿到请求  header  url   参数   ......         ServerHttpRequest request = exchange.getRequest();         // HttpServletRequest   这个是web里面的        //ServerHttpRequest  webFlux里面 响应式里面的         String path = request.getURI().getPath();        System.out.println(path);        HttpHeaders headers = request.getHeaders();        System.out.println(headers);        String methodName = request.getMethod().name();        System.out.println(methodName);        String hostName = request.getRemoteAddress().getHostName();        String ipv4 = request.getHeaders().getHost().getHostString();        System.out.println(hostName);        //响应相关的数据        ServerHttpResponse response = exchange.getResponse();        //用了微服务 肯定是前后端分离的  前后端分离  一般前后通过json        //{\"code\":200,\"msg\":\"ok\"}        // 设置编码  响应头里面置        response.getHeaders().set(\"content-type\",\"application/json;charset=utf-8\");        // 组装业务返回值        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(4);        map.put(\"code\", HttpStatus.UNAUTHORIZED.value());        map.put(\"msg\",\"你未授权\");        ObjectMapper objectMapper = new ObjectMapper();        //把一个map转成yige字节        byte[] bytes = new byte[0];        try {            bytes = objectMapper.writeValueAsBytes(map);        } catch (JsonProcessingException e) {            e.printStackTrace();        }        //通过buffer工厂将字节数组包装成一个数据包        DataBuffer wrap = response.bufferFactory().wrap(bytes);        return response.writeWith(Mono.just(wrap));        //放行  到下一个过滤器了        //return chain.filter(exchange);    }    /**     * 指定顺序 的方法     * 越小越先执行     * @return     */    @Override    public int getOrder() {        return 0;    }}\n\nIP地址访问过滤器实例：/** * 网关里面 过滤器 * ip拦截 * 请求都有一个源头 * 电话 144  027  010 * 请求-------&gt;gateway------&gt;service * 黑名单 black_list * 白名单 * 根据数量 * 像业务的服务  一般黑名单 * 一般像数据库 用白名单 */@Componentpublic class IPCheckFilter implements GlobalFilter, Ordered {    /**     * 网关的并发比较高  不要在网关里面直接操作mysql     * 后台系统可以查询数据库  用户量  并发量不大     * 如果并发量大  可以查redis 或者  在内存中写好     *     */    public static final List&lt;String&gt; BLACK_LIST = Arrays.asList(\"127.0.0.1\",\"144.128.232.147\");    /**     * 拿到ip     * 2.校验ip是否和服规范     * 3.放行/拦截     *     * @param exchange     * @param chain     * @return     */    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        ServerHttpRequest request = exchange.getRequest();        String ip = request.getHeaders().getHost().getHostString();        //查询数据库   看这个ip是否存在黑名单里面   mysql等数据库的并发        // 只要是能存储数据地方都叫数据库  redis   mysql        if(!BLACK_LIST.contains(ip)){            return chain.filter(exchange);        }        //拦截        ServerHttpResponse response = exchange.getResponse();        response.getHeaders().set(\"content-type\",\"application/json;charset=utf-8\");        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(4);        map.put(\"code\", 438);        map.put(\"msg\",\"你是黑名单\");        ObjectMapper objectMapper = new ObjectMapper();        byte[] bytes = new byte[0];        try {            bytes = objectMapper.writeValueAsBytes(map);        } catch (JsonProcessingException e) {            e.printStackTrace();        }        DataBuffer wrap = response.bufferFactory().wrap(bytes);        return response.writeWith(Mono.just(wrap));    }    @Override    public int getOrder() {        return -5;    }}\n\n因为Http是无状态的，所以如果要分布式微服务则需要建立token。\n用户登录token注册例子：\n@RestControllerpublic class LoginController {    @Autowired    public StringRedisTemplate redisTemplate;        @GetMapping(\"doLogin\")    public String doLogin(String name, String pwd){        System.out.println(name);        System.out.println(pwd);        //这里假设去做了登录        User user = new User(1, name, pwd, 18);        //token        String token = UUID.randomUUID().toString();        //存起来        redisTemplate.opsForValue().set(token,user.toString(),Duration.ofSeconds(7200))        return token;    }}\n\n一般放在请求头里面  一般key  Authorization        value  bearer token\nToken拦截（Token保存在Redis里面）：\npublic class TokenCheckFilter implements GlobalFilter, Ordered {    /**     * 指定好放行的路径     */    public static final List&lt;String&gt; ALLOW_URL = Arrays.asList(\"/login-service/doLogin\",\"/myUrl\");    @Autowired    private StringRedisTemplate redisTemplate;    /**     * 前提是？ 和前端约定好  一般放在请求头里面  一般key   Authorization   value  beare token     * 1.拿到请求url     * 2.判断放行     * 3.拿到请求头     * 4.拿到token     * 5.校验     * 6.放行/拦截     *     * @param exchange     * @param chain     * @return     */    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        ServerHttpRequest request = exchange.getRequest();        String path = request.getURI().getPath();        if(!ALLOW_URL.contains(path)){            return chain.filter(exchange);        }        // 检查        HttpHeaders headers = request.getHeaders();        List&lt;String&gt; authorization = headers.get(\"Authorization\");        if(!CollectionUtils.isEmpty(authorization)){            String token = authorization.get(0);            if(StringUtils.hasText(token)){                //  约定好的有前缀的  bearer token                String realToken = token.replaceFirst(\"bearer\", \"\");                if(StringUtils.hasText(realToken)&amp;&amp;redisTemplate.hasKey(token)){                    return chain.filter(exchange);                }            }        }        //拦截        ServerHttpResponse response = exchange.getResponse();        response.getHeaders().set(\"content-type\",\"application/json;charset=utf-8\");        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();        //返回401        map.put(\"code\", HttpStatus.UNAUTHORIZED.value());        map.put(\"msg\",\"未授权\");        ObjectMapper objectMapper = new ObjectMapper();        byte[] bytes = new byte[0];        try {            bytes = objectMapper.writeValueAsBytes(map);        } catch (JsonProcessingException e) {            e.printStackTrace();        }        DataBuffer wrap = response.bufferFactory().wrap(bytes);        return response.writeWith(Mono.just(wrap));    }    @Override    public int getOrder() {        return 0;    }}\n\n关于限流，面试不会直接问，而是间接来问  问  不卖超比如：如果在抢购过程中，用户量请求非常大，怎么确保商品不会卖超\nRedis单线程（IO为什么快，因为我们现在的处理器是多核心数的，redis底层使用的是IO的多路复用）\n一般人只会在意商品卖超，而忘记了限流的重要性\nMq（限流，削峰，异步，解耦合）\nMq+Redis+分布式锁\nSpring Cloud Alibaba\n项目介绍Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必须组件，方便开发者通过Spring Cloud编程模型轻松使用这些组件来开发分布式应用服务。\n依托Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将Spring Cloud应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。\n组件\nNacos一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。\nNacos致力于发现、配置和管理微服务。Nacos提供了一组简单易用的特征集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。\nNacos帮助您更敏捷和容易地构建、交付和管理微服务平台、Nacos是构建以“服务”为中心的现代应用架构（例如微服务范式、云原生 范式）的服务基础设施。\nNacos的核心概念\n服务（Service）服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos支持主流的服务生态，如Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud  RESTful Service。\n服务注册中心（Service Registry）服务注册中心，它是服务实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查API来验证它是否能够处理请求。\n服务元数据（Service Metadata）服务元数据是指包括服务端点（endpoints）、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据\n服务提供方（Service Provider）是指提供可复用和可调用服务的应用方\n服务消费方（Service Consumer）是指会发起对某个服务调用的应用方\n配置（Configuration）—配置文件中心在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在、目的是让静态的系统工件或者交付物（如WAR，JAR包等）更好地和实际的物理运行环境进行适配、配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。\n配置管理（Configuretion Management）在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。\n名字服务（Naming Service）提供分布式系统中所有对象（Object）、实体（Entity）的“名称”到关联的元数据之间的映射管理服务，例如ServiceName -&gt; Endpoints Info，Distributed Lock Name -&gt; Lock Owner/Status Info，DNS Domain Name -&gt; IP List服务发现和DNS就是名字服务的2大场景。\n配置服务（Configuration Service）在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。\nNacosServer的安装和启动NacosServer相对于EurekaServer，只不过EurekaServer使我们自己搭建的一个项目，而NacosServer是别人已经提供好了。\n安装：先在官网下载好Nacos，Nacos是一个jar包，直接启动即可。然后就是配置好里面的配置文件，现在conf文件里面修改properties内的数据库连接这些：\n\n\nNacos默认为集群配置，如果是想设置成单个若没有改启动模式为单个那么会报错，修改的地方直接在start文件里面改就行：\n\nJava编写配置：首先要导入Nacos的依赖，Spring官方可能没有依赖的直接选择项，可以切换依赖来源网站为：http://www.start.alibaba.com\n\n然后进行Nacos依赖选择：\n\nNacos的基本yml配置：server:  port: 8081spring:  application:    name: nacos-client-b  cloud:    nacos:      server-addr: localhost:8848      username: nacos      password: nacos      discovery:  # 这里是和注册相关的配置        namespace: 2666d147-6a14-403f-bc7e-1bf7faae7bff        group: A_GROUP  # 往哪个组里面注册        service: user-service  # 这个才是注册列表的名字 如果不写 默认是取${spring.application.name}\n\nnamespace是最重要的，这个用来区分项目项，group可以详细对项目下进行分组\nNacos整合Gateway网关Gateway要依赖SpringCloud，所以一定要确认SpringCloud和SpringBoot和SpringCloudAlibaba之间的版本关系！！！！！！\n这里使用方法是差不多的，首先加上合适的依赖后：\nyml相关的配置文件：\nserver:  port: 80spring:  application:    name: gateway  cloud:    nacos:      server-addr: localhost:8848      username: nacos      password: nacos      discovery:        namespace: 2666d147-6a14-403f-bc7e-1bf7faae7bff        group: A_GROUP        username: gateway    gateway:      discovery:        locator:          enabled: true #开启动态路由          lower-case-service-id: true\n\n然后就是启动类加上网关开启的配置：\n@SpringBootApplication@EnableDiscoveryClientpublic class NacosGatewayApplication {    public static void main(String[] args) {        SpringApplication.run(NacosGatewayApplication.class, args);    }}\n\n完成~。\n常用Nacos中yaml文件配置代码：\n\nNacos配置文件中心配置文件中心作用 \n如果生成环境修改了配置文件项目学需要下架重新打包，重新发布。\n方便管理，以及配置文件中心修改后可以及时更新而且项目本源不用重启(类似于热部署更新)，爽！！！\n只要配置文件修改了对应的服务就可以动态感知到不需要重启\n\n配置文件中心配置方式Nacos端需要先在Nacos端创建好配置文件的组：\n\nData id：对应的存储id\nGroup：对应的组别\nJava端：\nserver:  port: 8082spring:  application:    name: nacos-config-a  cloud:    nacos:      server-addr: localhost:8848      username: nacos      password: nacos      config:        prefix: nacos-config-a  # 读哪个配置文件        file-extension: yml  #  文件类型#      config:#        namespace:#        group:# 项目在启动的时候去哪里找它对应的配置文件呢？# 新版本的的Cloud默认禁止bootstrap，需要在依赖中加入 spring-cloud-starter-bootstrap\n\n这里如果bootstrap无效，可能是你SpringBoot与SpringBootCloud Alibaba的版本对应有问题。\nSpringBoot的2.4版本后strap与原本的SpringBoot分离了，所以需要重新加入一个依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;    &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt;\n\n然后就是Java内容的引用：\n\n@RefreshScope注解的作用是让这个类里面的所有Value注解都能随着配置文件中心的属性而变化。\n配置文件的读取方式（重点）Nacos配置中心通过namespace、dataId和group来唯一确定一条配置。\n\nNamespace：即命名空间。默认的命名空间为public，我们可以在Nacos控制台中新建命名空间；\n\ndataId：即配置文件名称\n\nGroup：即配置分组，默认为DEFAULT_GROUP，可以通过其中：dataId是最关键的配置字段：格式如下：\n${prefix}           -    ${spring.profiles.active}\n${file-extension}\n说明：\n\nprefix默认为spring.application.name的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置；\n\nspring.profiles.active即为当前环境对应的profile。注意，当spring.profiles.active为空时，对应的连接符-也将不存在，dataId的拼接格式变成${prefix}.${file-extension};\n\nfile-extension为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension来配置\n这就是上面我们为什么能获得到配置的原因了。\n注意：在写dataId的时候一定要添加文件类型后缀\nEg：nacos-config-dev.yml\n\n\n多配置文件读取：server:  port: 8083spring:  application:    name: nacos-config-test  cloud:    nacos:      config:        server-addr: localhost:8848        username: nacos        password: nacos        namespace: dcc36983-39b3-485a-b2f5-5f27bb6f1744  # 目前读取多配置文件的方式只支持在同一个命名空间下        file-extension: yml        extension-configs: #  可以读多个配置文件  需要在同一个命名空间下面  可以是不同的组          - dataId: user-center-dev.yml            group: A_GROUP            refresh: true  #是否支持刷新  这里支持动态刷新          - dataId: member-center-dev.yml            group: B_GROUP            regresh: false # 是否支持刷新  这里不去动态 刷新\n\n\n公共配置文件配置：server:  port: 8083spring:  application:    name: nacos-config-test  cloud:    nacos:      config:        server-addr: localhost:8848        username: nacos        password: nacos        namespace: dcc36983-39b3-485a-b2f5-5f27bb6f1744  # 目前读取多配置文件的方式只支持在同一个命名空间下        file-extension: yml        prefix: user-center        shared-configs:    #  共享配置文件          #- application-dev.yml   # 这里可以写共享的文件名称  只能在DEFAULT_GROUP          - dataId: application-dev.yml  #  这两种写法都可以            grou: C_GROUP            refresh: true\n\n\nNacos常用配置：\n\n\n两端的配置文件写什么内容本地的bootstrap.yml（应用名称，配置文件中心（注册中心地址），读取的配置文件名称信息）\n远端的配置文件（端口，数据源，redis，mq，mybatis，Swagger…）\n为了方便去动态刷新和修改\n项目结构单体结构：\n\n\n分布式聚合项目：\n\n\n分布式聚合项目优化方案1：\n\n其中将原本的mapper、service、web整合成了core或者enter。\n模块清晰，轻耦合\n\n分布式聚合项目优化方案2：\n\n\n之间的依赖关系明显比方案一少，清晰。\n\n分布式微服务父项目配置案例&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;modules&gt;    &lt;/modules&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.3.7.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!--lookup parent from repository--&gt;    &lt;/parent&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;nnlg-server&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;project&gt;pom&lt;/project&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;        &lt;spring-cloud.version&gt;2021.0.3&lt;/spring-cloud.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;    &lt;/build&gt;&lt;/project&gt;\n\n","categories":["Java","Spring"],"tags":["Java","SpringCloud"]},{"title":"Spring Security框架","url":"/2023/05/14/learnnote/java-xue-xi-bi-ji/springsecurity-xue-xi/","content":"Spring Security框架\n第一章了解Spring Security\nSpring Security是基于Spring的安全框架。它提供全面的安全性解决方案，同时在Web请求和方法调用级处理身份确认和授权。在Spring Framework基础上，Spring Security充分利用了依赖注入（DI）和面向切面编程（AOP）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。是一个轻量级的安全框架。他与SpringMVC有很好地集成。\n1.1Spring Security 核心功能（1）认证（你是谁，用户/设备/系统）\n（2）验证（你能干什么，也叫权限控制/授权，允许执行的操作）\n1.2Spring Security 原理基于 Filter，Servlet，AOP实现身份认证和权限验证\n第二章 实例驱动学习\n导入依赖：&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;\n\nSpringSecurity完整流程SpringSecurity的原理其实就是一个过滤链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\n图中只展示了核心过滤器，其他的非核心过滤器并没有在图中展示。\nUsernamePasswordAuthenticationFilter：负责处理我们登录页面填写了用户名密码后的登录请求。入门案例的认证工作主要有它负责。\nExceptionTranslationFilter：处理过滤器中抛出的任何AccessDeniedException和AuthenticationException。\nFilterSecurityInterceptor：负责权限的过滤器。\n=\n初始默认密码登录在初次导入框架使用的时候，Security会默认生成一个密码：\n\n这个密码在默认访问任意接口的时候都需要你进行登录操作，登录时账号就为：user，密码就是上面生成的随机密码。\n修改默认密码修改默认密码后就不会再随机生成密码了，并且也不会展示，修改密码需要在application配置文件里面设置：\nspring:  security:    user:      name: cbq  #账号      password: cbq  #密码\n\n\n\n关闭验证关闭验证只需要在SpringBoot启动类注解里面添加排除项即可：\n//排除Security的配置，让他不启用@SpringBootApplication(exclude = {SecurityAutoConfiguration.class})public class SecurityStudyApplication {    public static void main(String[] args) {        SpringApplication.run(SecurityStudyApplication.class, args);    }}\n\n\n\n使用内存中的用户信息这里一定要注意！！！！\n\n在Spring Security 5.7.0-M2，我们弃用了 WebSecurityConfigurerAdapter ，因为我们鼓励用户转向使用基于组件的安全配置。\n\n如果是使用了5.7以下的那么就按照以下方法来！！！\n使用：WebSecurityConfigurerAdapter控制安全管理的内容。\n需要做的使用：继承WebSecurityConfigurerAdapter，重新方法。实现自定义的认证信息。\n注解：\n1、@Configuration：表示当前类是一个配置类（相当于是Spring的xml配置文件），在这个类方法的返回值是Java对象，这些对象放入到Spring容器中。\n2、@EnableWebSecurity：表示启动Spring Security安全框架的功能。\n3/@Bean：把方法返回值的对象，放入到Spring容器中。\n这里注意Security5中密码必须要加密，不然报错。\n\njava.lang.IllegalArgumentException: There is no PasswordEncoder mapped foor the id \"null\"\n\n\n\n\n如果使用了新版Security那么：\n@Configurationpublic class SecurityConfiguration {       @Bean    public UserDetailsService userDetailsService(){        UserDetails user1 = User.builder().                username(\"cbq1\").                password(\"123456\")                .roles(\"student\")                .build();        UserDetails user2 = User.builder()                .username(\"cbq2\")                .password(\"123456\")                .roles(\"teacher\")                .build();        InMemoryUserDetailsManager memoryUserDetailsManager = new InMemoryUserDetailsManager();        memoryUserDetailsManager.createUser(user1);        memoryUserDetailsManager.createUser(user2);        return memoryUserDetailsManager;    }}\n\n注意：在这些例子中，我们为了可读性使用了User.withDefaultPasswordEncoder()。这不适合生产项目，我们建议在生产项目中使用散列密码。请按照参考文档所说的用Spring Boot命令行工具来做。\n基于角色Role的身份认证，同一个用户可以有不同的角色。同时可以开启对方法级别的认证。以下是WebSecurity.java配置文件：\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.provisioning.InMemoryUserDetailsManager;@Configuration@EnableWebSecurity@EnableMethodSecurity(prePostEnabled = true) //这个作用是用于开启基于角色访问，不然的话无效public class MyWebSecurityConfig {    //在方法中配置 用户和密码的信息，作为登录的数据    @Bean    public InMemoryUserDetailsManager userDetailsManager(){        UserDetails user1 = User.withDefaultPasswordEncoder()                .username(\"cbq\")                .password(\"cbq\")                .roles(\"normal\")                .build();        UserDetails user2 = User.withDefaultPasswordEncoder()                .username(\"cbq1\")                .password(\"cbq1\")                .roles(\"normal\")                .build();        UserDetails user3 = User.withDefaultPasswordEncoder()                .username(\"cbq2\")                .password(\"cbq2\")                .roles(\"normal\",\"admin\")                .build();        return new InMemoryUserDetailsManager(user1,user2,user3);    }}\n\n这里开了三个用户，一共两个角色，一个normal，一个admin。一个用户可以拥有多个角色。基于角色的访问需要配合@PreAuthorize注解使用，详细如下，这里@PreAuthorize注解标注了哪个接口只能哪几个角色能访问。\nimport org.springframework.security.access.prepost.PreAuthorize;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"hello\")public class HelloSecurityController {    @RequestMapping(\"world\")    @PreAuthorize(value = \"hasAnyRole('admin','normal')\")    public Object sayHello(){        return \"拥有admin和normal\";    }    @RequestMapping(\"hhh\")    @PreAuthorize(value = \"hasAnyRole('admin')\")    public Object hhh(){        return \"admin角色才可以访问\";    }}\n\n\n\n关于authorities设置权限与roles设置角色的坑\n在实验中发现，如果同时使用roles设置用户的角色，用authoritites设置用户的权限，谁写在最后那么就用谁作为最终的权限标志。比如以下例子：\n\n@Beanpublic UserDetailsService userDetailsService(){    UserDetails user1 = User.builder().            username(\"cbq1\").            password(passwordBCryptEncoder().encode(\"123456\"))            .roles(\"student\")            .authorities(\"student:add\",\"student:delete\")            .build();    UserDetails user2 = User.builder()            .username(\"cbq2\")            .password(passwordBCryptEncoder().encode(\"123456\"))        \t.authorities(\"student:add\",\"student:delete\")            .roles(\"teacher\")            .build();    InMemoryUserDetailsManager memoryUserDetailsManager = new InMemoryUserDetailsManager();    memoryUserDetailsManager.createUser(user1);    memoryUserDetailsManager.createUser(user2);    return memoryUserDetailsManager;}\n\n在上述代码中，user1角色的权限最终为student:add与student:delete。user2角色的权限最终为ROLE_teacher角色标志。\n基于JDBC的用户认证从数据库Mysql中获取用户的身份信息（用户名称，密码，角色）\n在Spring Security框架对象用户信息的表示类是UserDetails.\nUserDetails是一个接口，高度抽象的用户信息类(相当于项目中的User类)\nUser类：是UserDetails接口的实现类，构造方法有三个参数：\nusername，password，authorities\n需要向Spring Security提供User对象，这个对象的数据来自数据库中的查询。\n实现UserDetailsService接口，重写UserDetails loadUserByUsername(String var1)在方法中获取数据库中的用户信息，也就是执行数据库的查询，条件是用户名称。\n密码加密存储实际项目中我们不会把密码明文存储在数据库表中。\n在SpringSecurity中明文加密为：NoOpPasswordEncoder.getInstance();\n默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PordEncoder。\n我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\n我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\n我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\n第三章 权限控制\n基于访问路径进行访问权限控制\n拦截相应没有访问权限访问页面的用户，注意authorizeRequests与authorizeHttpRequests不能混用，不然报错。\n\nimport jakarta.annotation.Resource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.web.SecurityFilterChain;@Configuration@EnableWebSecurity@EnableMethodSecurity(prePostEnabled = true)public class MyWebSecurityConfig {    @Resource    private UserDetailsService userDetailsService;    @Bean    SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {        //配置web授权访问,\"/login\",\"/register\",\"/upLogin\"这些统统无需权限        httpSecurity.authorizeHttpRequests().requestMatchers(\"/login\",\"register\",\"/upLogin\").permitAll()                //成功的链接,也就是后续访问的链接放在这个里,我这里是成功页需要USER权限才能访问                .requestMatchers(\"/success\").hasAnyRole(\"USER\").and()        /**         * 自定义登陆页面是loginSelf.html页(这里看你模板引擎怎么配),表单提交的处理链接是\"/upLogin\"         * 就是&lt;form action=\"/upLogin\"&gt;&lt;/form&gt;这样,这个\"/upLogin\"不需要自己处理,就自己决定         * usernameParameter和passwordParameter,就是表单提交所带的参数,         * 这里我是\"username\"和\"password\";         */                .formLogin().loginPage(\"/loginSelf\").loginProcessingUrl(\"upLogin\")                .usernameParameter(\"username\").passwordParameter(\"password\");        return httpSecurity.build();    }}\n\n以下为新版本\nimport org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {//        http.authorizeRequests() //授权请求//                .anyRequest()//任何请求//                .denyAll();//拒绝        http.authorizeRequests()                //.regexMatchers(\"/student/**\") //这种匹配方式可以不用学                //.antMatchers(\"/student/**\")  //这种匹配方式可以不用学                .mvcMatchers(\"/student/**\") //匹配这个url                //.hasRole(\"\") //是否有单个角色                //.hasAnyRole(\"\") //是否有任意角色                //.access(\"hasAuthority('student:query') or hasRole('admin')\") //另外一种权限设置                .hasAnyAuthority(\"student:add\") //拥有这个权限的用户可以访问这个/student/** ,是否其中至少一个权限                .mvcMatchers(\"/teacher/**\") //匹配url                .hasAuthority(\"ROLE_teacher\") //拥有这个权限的用户可以访问/teacher/**                .anyRequest() //任何请求                .authenticated(); //都需要登录 ,注意，没有配置mvc的只要登录成功就可以访问        http.formLogin().permitAll(); //允许表单登录    }}\n\n匹配路径url的写法有三种，判断权限有五种。\n基于方法来进行访问权限控制\n基于方法粒度的权限校验一定要记得在Security配置类中加上@EnableGlobalMethodSecurity注解设置prePostEnabled=true参数，否则直接使用注解配置权限将会无效！！！\n\nimport org.springframework.context.annotation.Bean;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.provisioning.InMemoryUserDetailsManager;//@Configuration 这里不需要加Configuration是因为下面这个注解已经带有Config注解了@EnableGlobalMethodSecurity(prePostEnabled = true) //开启全局方法安全public class SecurityUserConfig {    @Bean    public UserDetailsService userDetailsService(){        UserDetails u1 = User.builder()                .username(\"cbq1\")                .password(passwordEncoder().encode(\"123456\"))                .roles(\"student\")                .build();        UserDetails u2 = User.builder()                .username(\"cbq2\")                .password(passwordEncoder().encode(\"123456\"))                .authorities(\"teacher:update\",\"teacher:query\")                .build();        InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();        inMemoryUserDetailsManager.createUser(u1);        inMemoryUserDetailsManager.createUser(u2);        return inMemoryUserDetailsManager;    }    @Bean    public PasswordEncoder passwordEncoder(){        return new BCryptPasswordEncoder();    }}\n\n配置完之后即可使用了：\nimport org.springframework.security.access.prepost.PreAuthorize;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"teacher\")public class TeacherController {    @GetMapping(\"add\")    @PreAuthorize(\"hasRole('teacher')\") //预授权    public Object add(){        return \"添加成功\";    }    @GetMapping(\"delete\")    @PreAuthorize(\"hasRole('teacher')\")    public Object delete(){        return \"删除成功\";    }    @GetMapping(\"update\")    @PreAuthorize(\"hasRole('teacher') or hasAuthority('teacher:update')\")    public Object update(){        return \"更新成功\";    }}\n\n\n\n第四章 利用处理器返回JSON设置登录成功返回json\n设置登录成功返回json创建一个类并且实现AuthenticationSuccessHandler接口，\n\nimport com.example.springsecuritystudy3.vo.HttpResult;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @description: 只要认证成功那么久返回json * @author 长白崎 * @date 2023/7/17 5:11 * @version 1.0 */@Slf4j@Componentpublic class AppAuthenticationSuccessHandler implements AuthenticationSuccessHandler {    @Resource    private ObjectMapper objectMapper;    @Override    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {        HttpResult httpResult = HttpResult.builder()                .code(1)                .msg(\"登录成功\")                .build();        String responseJson = objectMapper.writeValueAsString(httpResult);        response.setCharacterEncoding(\"UTF-8\");        response.setContentType(\"application/json;charset=utf-8\");        PrintWriter writer = response.getWriter();        writer.println(responseJson);        writer.flush();    }}\n\n实现接口之后只需要Security配置类当中配置好即可。\nimport lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import javax.annotation.Resource;@Configuration@Slf4jpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Resource    AppAuthenticationSuccessHandler appAuthenticationSuccessHandler;    @Resource    AppAuthenticationFailureHandler appAuthenticationFailureHandler;    @Override    protected void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()                .anyRequest()                .authenticated();        //设置登录成功处理器        http.formLogin()                .successHandler(appAuthenticationSuccessHandler) //配置登录成功事件                .failureHandler(appAuthenticationFailureHandler) //配置登录失败事件                .permitAll();    }}\n\n设置退出登录成功返回json\n设置退出登录成功返回json创建一个类并且实现LogoutSuccessHandler接口，\n\nimport com.example.springsecuritystudy3.vo.HttpResult;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @description: 退出登录成功 * @author 长白崎 * @date 2023/7/17 5:41 * @version 1.0 */@Componentpublic class AppLogoutSuccessHandler implements LogoutSuccessHandler {    @Resource    ObjectMapper objectMapper;    @Override    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {        HttpResult httpResult = HttpResult.builder()                .code(0)                .msg(\"退出登录成功\")                .build();        String json = objectMapper.writeValueAsString(httpResult);        response.setCharacterEncoding(\"UTF-8\");        response.setContentType(\"application/json;charset=utf-8\");        PrintWriter printWriter = response.getWriter();        printWriter.println(json);        printWriter.flush();    }}\n\n设置登录失败返回json\n设置登录失败返回json创建一个类并且实现AuthenticationSuccessHandler接口，\n\nimport com.example.springsecuritystudy3.vo.HttpResult;import com.fasterxml.jackson.databind.ObjectMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Slf4j@Componentpublic class AppAuthenticationFailureHandler implements AuthenticationFailureHandler {    @Resource    ObjectMapper objectMapper;    @Override    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {        HttpResult httpResult = HttpResult.builder()                .code(0)                .msg(\"登录失败\")                .build();        String json = objectMapper.writeValueAsString(httpResult);        response.setCharacterEncoding(\"UTF-8\");        response.setContentType(\"application/json;charset=utf-8\");        PrintWriter printWriter = response.getWriter();        printWriter.println(json);        printWriter.flush();    }}\n\n设置访问拒绝返回json\n设置访问拒绝返回json创建一个类并且实现AuthenticationSuccessHandler接口，\n\nimport com.example.springsecuritystudy3.vo.HttpResult;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.web.access.AccessDeniedHandler;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @description: 访问拒绝处理 * @author 长白崎 * @date 2023/7/17 5:40 * @version 1.0 */@Componentpublic class AppAccessDenyHandler implements AccessDeniedHandler {    @Resource    ObjectMapper objectMapper;    @Override    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {        HttpResult httpResult = HttpResult.builder()                .code(2)                .msg(\"您没有权限访问\")                .build();        String json = objectMapper.writeValueAsString(httpResult);        response.setCharacterEncoding(\"UTF-8\");        response.setContentType(\"application/json;charset=utf-8\");        PrintWriter printWriter = response.getWriter();        printWriter.println(json);        printWriter.flush();    }}\n\n实现接口之后只需要Security配置类当中配置好即可。import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import javax.annotation.Resource;@Configuration@Slf4jpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Resource    AppAuthenticationSuccessHandler appAuthenticationSuccessHandler;    @Resource    AppAuthenticationFailureHandler appAuthenticationFailureHandler;    @Resource    AppLogoutSuccessHandler appLogoutSuccessHandler;    @Resource    AppAccessDenyHandler appAccessDenyHandler;    @Override    protected void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()                .anyRequest()                .authenticated();        //设置登录成功处理器        http.formLogin()                .successHandler(appAuthenticationSuccessHandler) //配置登录成功处理器                .failureHandler(appAuthenticationFailureHandler) //配置登录失败处理器                .permitAll();        http.logout().logoutSuccessHandler(appLogoutSuccessHandler); //配置退出成功处理器        http.exceptionHandling().accessDeniedHandler(appAccessDenyHandler); //配置访问拒绝处理器    }}\n\n通过实现UserDetails接口来定义用户\nimport com.example.springsecuritystudy4.entity.User;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;public class SecurityUser implements UserDetails {    private final User user;    private List&lt;SimpleGrantedAuthority&gt; authorityList;    public SecurityUser(User user) {        this.user = user;    }    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {        return authorityList;    }    public void setAuthorityList(List&lt;SimpleGrantedAuthority&gt; authorityList) {        this.authorityList = authorityList;    }    @Override    public String getPassword() {        String pwd = user.getPassword();        user.setPassword(null);        return pwd;    }    @Override    public String getUsername() {        return user.getUsername();    }    @Override    public boolean isAccountNonExpired() {        return user.getAccountNoExpired().equals(1);    }    @Override    public boolean isAccountNonLocked() {        return user.getAccountNoLocked().equals(1);    }    @Override    public boolean isCredentialsNonExpired() {        return user.getCredentialsNoExpired().equals(1);    }    @Override    public boolean isEnabled() {        return true;    }}\n\n\n\n\n\n第五章 基于数据库的认证\n1、第一步则是先要实现UserDetails接口\n主要用于定制化将数据库数据对接Security框架。\n\nimport com.example.springsecuritystudy4.entity.User;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;public class SecurityUser implements UserDetails {    private final User user;    private List&lt;SimpleGrantedAuthority&gt; authorityList;    public SecurityUser(User user) {        this.user = user;    }    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {        return authorityList;    }    public void setAuthorityList(List&lt;SimpleGrantedAuthority&gt; authorityList) {        this.authorityList = authorityList;    }    @Override    public String getPassword() {        String pwd = user.getPassword();        user.setPassword(null);        return pwd;    }    @Override    public String getUsername() {        return user.getUsername();    }    /*代表账号是否已经过期（true账号没有过期，false账号已经过期）*/    @Override    public boolean isAccountNonExpired() {        return user.getAccountNoExpired().equals(1);    }        /*代表账号是否被锁定(true没有锁定，false锁定）*/    @Override    public boolean isAccountNonLocked() {        return user.getAccountNoLocked().equals(1);    } /*代表凭证是否已经过期（true账号没有过期，false账号已经过期）*/    @Override    public boolean isCredentialsNonExpired() {        return user.getCredentialsNoExpired().equals(1);    } /*代表账号是否可用*/    @Override    public boolean isEnabled() {        return true;    }}\n\n2、实现UserDetailsService接口\n实现UserDetailService接口的作用主要就是定制化用户登录时的数据获取方式以及对比方式等。\n\nimport com.example.springsecuritystudy4.entity.User;import com.example.springsecuritystudy4.service.RoleMenuService;import com.example.springsecuritystudy4.service.UserService;import com.example.springsecuritystudy4.vo.SecurityUser;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;@Servicepublic class SecurityUserDetailServiceImpl implements UserDetailsService {    @Resource    private UserService userService;    @Resource    private RoleMenuService roleMenuService;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {        User byUserName = userService.getByUserName(username);        if(byUserName==null)            throw new UsernameNotFoundException(\"该用户不存在\");        List&lt;String&gt; queryPermissionsByUserId = roleMenuService.queryPermissionsByUserId(byUserName.getUid());        SecurityUser securityUser = new SecurityUser(byUserName);        List&lt;SimpleGrantedAuthority&gt; authorityList = new ArrayList&lt;&gt;();        queryPermissionsByUserId.stream().forEach((value)-&gt; authorityList.add(new SimpleGrantedAuthority(value)));        securityUser.setAuthorityList(authorityList);        return securityUser;    }}\n\n\n\n第六章 WebSecurity配置中关于其中登录页面等其他页面定制化\nimport lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;@Slf4j@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Bean    public PasswordEncoder passwordEncoder(){        return new BCryptPasswordEncoder();    }    @Override    protected void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()                .anyRequest()                .authenticated();        http.formLogin()                .loginPage(\"/toLogin\") // 配置登录页面                .usernameParameter(\"uname\") // 用户名参数                .passwordParameter(\"pwd\") // 密码参数                .loginProcessingUrl(\"/login/doLogin\")  //单击登录后进入url                .failureForwardUrl(\"/toLogin\") // 登录失败                .successForwardUrl(\"/toIndex\") //登录成功                .permitAll();  //配置登录        http.logout().logoutSuccessUrl(\"/toLogin\");  //配置退出成功登录页面        http.csrf().disable(); //关闭跨域请求保护    }}\n\n\n\n\n\n第七章 验证码整合\n\n 验证码生成工具可以使用hutool依赖库进行。\n\n验证码生成接口代码import cn.hutool.captcha.CaptchaUtil;import cn.hutool.captcha.CircleCaptcha;import cn.hutool.captcha.generator.MathGenerator;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import javax.imageio.ImageIO;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Controllerpublic class CaptchaController {    @GetMapping(value = \"code/getCaptchaCode\")    public void getCaptchaCode(HttpServletRequest httpServletRequest,                               HttpServletResponse httpServletResponse) throws IOException {        //ShearCaptcha shearCaptcha = CaptchaUtil.createShearCaptcha(200, 100, 4, 5);        CircleCaptcha circleCaptcha = CaptchaUtil.createCircleCaptcha(200, 100, 4, 1000);        circleCaptcha.setGenerator(new MathGenerator());        String code = circleCaptcha.getCode();        log.info(\"生成的图片验证码为：{}\",code);        //将验证码存储到session中        httpServletRequest.getSession().setAttribute(\"CAPTCHA CODE\",code);        httpServletResponse.setContentType(\"image/png\");        //将图片写到响应流里        ImageIO.write(circleCaptcha.getImage(),\"PNG\",httpServletResponse.getOutputStream());    }}\n\n写好验证码之后即可在WebSecurity实现配置类中将验证码接口放开：\nimport com.example.springsecuritystudy4.filter.ValidateCodeFilter;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.annotation.Resource;@Slf4j@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Bean    public PasswordEncoder passwordEncoder(){        return new BCryptPasswordEncoder();    }    @Override    protected void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()                .mvcMatchers(\"/code/getCaptchaCode\") //将验证码接口放开                .permitAll()                .anyRequest()                .authenticated();        http.formLogin()                .loginPage(\"/toLogin\") // 配置登录页面                .usernameParameter(\"uname\") // 用户名参数                .passwordParameter(\"pwd\") // 密码参数                .loginProcessingUrl(\"/login/doLogin\")  //单击登录后进入url                .failureForwardUrl(\"/toLogin\") // 登录失败                .successForwardUrl(\"/toIndex\") //登录成功                .permitAll();  //放开        http.logout().logoutSuccessUrl(\"/toLogin\");  //配置退出成功登录页面        http.csrf().disable(); //关闭跨域请求保护    }}\n\n\n\n利用过滤器来验证验证码\n过滤器需要继承实现OncePerRequestFilter接口。以下为实现例子\n\nimport lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Slf4j@Componentpublic class ValidateCodeFilter extends OncePerRequestFilter {    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {        // TODO 判断路径 是否是/login/doLogin        String requestURL = request.getRequestURI();        if(!requestURL.equals(\"/login/doLogin\")){ //不是登录请求，直接放行            doFilter(request,response,filterChain);        }    }    private void validateCode(HttpServletRequest request,HttpServletResponse response,FilterChain filterChain) throws ServletException, IOException {        //TODO 1、从前端获取验证码        String code = request.getParameter(\"code\");        //TODO 2、从session中获取验证码        String captchaCode = (String) request.getSession().getAttribute(\"CAPTCHA_CODE\");        //TODO 3、判断二者是否相等        if(StringUtils.isEmpty(code)){            request.getSession().setAttribute(\"captcha_code_error\",\"请输入验证码\");            return;        }        if(StringUtils.isEmpty(captchaCode)){            request.getSession().setAttribute(\"captcha_code_error\",\"验证码错误\");        }        request.getSession().setAttribute(\"CAPTCHA_CODE\",\"\");        this.doFilter(request,response,filterChain);    }}\n\n写好过滤器后即可在配置类里面使用过滤器：\n import com.example.springsecuritystudy4.filter.ValidateCodeFilter;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.annotation.Resource;@Slf4j@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Resource    ValidateCodeFilter validateCodeFilter;    @Bean    public PasswordEncoder passwordEncoder(){        return new BCryptPasswordEncoder();    }    @Override    protected void configure(HttpSecurity http) throws Exception {        //在用户名密码认证过滤器前添加验证码过滤器        http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class);        http.authorizeRequests()                .mvcMatchers(\"/code/getCaptchaCode\")                .permitAll()                .anyRequest()                .authenticated();        http.formLogin()                .loginPage(\"/toLogin\") // 配置登录页面                .usernameParameter(\"uname\") // 用户名参数                .passwordParameter(\"pwd\") // 密码参数                .loginProcessingUrl(\"/login/doLogin\")  //单击登录后进入url                .failureForwardUrl(\"/toLogin\") // 登录失败                .successForwardUrl(\"/toIndex\") //登录成功                .permitAll();  //放开        http.logout().logoutSuccessUrl(\"/toLogin\");  //配置退出成功登录页面        http.csrf().disable(); //关闭跨域请求保护    }}\n\n\n\n\n\n第八章 SpringSecurity+JWT实现前后端分离\n\n这里JWT相关的工具类代码就不多展示了。这边可以在网上找到很多的JWTUtils模板。\n\n静态文件展示：\n对于前端我们写一个用于测试的几个页面。\n\n1、登录页面：&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;        &lt;title&gt;登录&lt;/title&gt;        &lt;script src=\"./script/jquery-3.7.1.min.js\"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input id=\"act\" type=\"text\"&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;&lt;input id=\"psd\" type=\"password\"&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;td&gt;&lt;button id=\"login\"&gt;登录&lt;/button&gt;&lt;button&gt;注册&lt;/button&gt;&lt;/td&gt;        &lt;/table&gt;    &lt;/body&gt;    &lt;script&gt;    var act = document.getElementById(\"act\");    var psw = document.getElementById(\"psd\");        $(\"#login\").click(function(){            var act = $('#act').val();            var psw = $('#psd').val();            $.ajax('login',{                method: 'POST',                contentType: 'application/json',                dataType: 'json',                data: JSON.stringify({uid: act,password: psw}),                success:function (result){                    alert(JSON.stringify(result))                    console.log(result)                },                error:function (result){                    alert(result.data)                }            })        });&lt;/script&gt;&lt;/html&gt;\n\n2、主页：&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;    &lt;title&gt;管理页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;测试成功&lt;/td&gt;            &lt;td&gt;测试成功&lt;/td&gt;            &lt;td&gt;测试成功&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;测试成功&lt;/td&gt;            &lt;td&gt;测试成功&lt;/td&gt;            &lt;td&gt;测试成功&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;测试成功&lt;/td&gt;            &lt;td&gt;测试成功&lt;/td&gt;            &lt;td&gt;测试成功&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n\n文件目录展示：\n\n配置SpringSecurity：1.1、得到UserDetails方式（实现UserDetailsService接口的方式）：import com.cbq.springsecuritystudy6.entity.User;import com.cbq.springsecuritystudy6.service.RoleService;import com.cbq.springsecuritystudy6.service.UserService;import com.cbq.springsecuritystudy6.vo.SecurityUser;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;/** * @description: 定制化用户登录数据获取方式 * @author 长白崎 * @date 2023/9/19 11:28 * @version 1.0 */@Servicepublic class SecurityUserDetailServiceImpl implements UserDetailsService {    @Resource    UserService userService;    @Resource    private RoleService roleService;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {        User userFromUid = userService.getUserFromUid(username);        if(userFromUid==null){            throw new UsernameNotFoundException(\"该用户不存在\");        }        List&lt;String&gt; rolePermission = roleService.queryPermissionsByUserUid(username);        SecurityUser securityUser = new SecurityUser(userFromUid);        ArrayList&lt;SimpleGrantedAuthority&gt; authorityArrayList = new ArrayList&lt;&gt;();        rolePermission.stream().forEach((v)-&gt; authorityArrayList.add(new SimpleGrantedAuthority(v)));        securityUser.setAuthorityList(authorityArrayList);        return securityUser;    }}\n\n1.2、得到UserDetails方式（实现UserDetails接口的方式）（推荐）：import com.cbq.springsecuritystudy6.entity.User;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;public class SecurityUser implements UserDetails {    private final User user;    private List&lt;SimpleGrantedAuthority&gt; authorityList;    /**     * 利用构造方法来注入User     * @param user     */    public SecurityUser(User user) {        this.user = user;    }    /**     * 获取权限列表     * @return     */    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {        return authorityList;    }    /**     * 设置权限列表     * @param authorityList     */    public void setAuthorityList(List&lt;SimpleGrantedAuthority&gt; authorityList) {        this.authorityList = authorityList;    }    public User getUser() {        return user;    }    @Override    public String getPassword() {        String pws = user.getPassword();        user.setPassword(null);        return pws;    }    @Override    public String getUsername() {        return user.getUid();    }    /**     * 账号是否未过期     * @return     */    @Override    public boolean isAccountNonExpired() {        return true;    }    /**     * 账号是否未锁定     * @return     */    @Override    public boolean isAccountNonLocked() {        return true;    }    /**     * 账号是否未过期     * @return     */    @Override    public boolean isCredentialsNonExpired() {        return true;    }    /**     * 账号是否可用     * @return     */    @Override    public boolean isEnabled() {        return true;    }}\n\n2、通过拦截器接口实现JWT的拦截认证：\n这里就用Map来模拟Redis了。\n\nimport com.auth0.jwt.JWT;import com.auth0.jwt.interfaces.Claim;import com.auth0.jwt.interfaces.DecodedJWT;import com.cbq.springsecuritystudy6.utils.JWTUtils;import com.cbq.springsecuritystudy6.vo.SecurityUser;import lombok.extern.slf4j.Slf4j;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Objects;@Slf4j@Componentpublic class JwtCheckFilter extends OncePerRequestFilter {    //模拟Redis    public static Map&lt;String,Object&gt; redis = new HashMap&lt;&gt;();    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {        //获取token        String authorization = request.getHeader(\"Authorization\");        //如果token不存在可能是其他白名单的请求，这里直接放行        if(!StringUtils.hasText(authorization)){            //放行            filterChain.doFilter(request,response);            return;        }        DecodedJWT token = JWTUtils.getToken(authorization);        //获取uid        Claim uid = token.getClaim(\"uid\");        System.out.println(uid.asString());        //判断是否为非法token        if(!JWTUtils.verify(authorization) &amp;&amp; JWTUtils.isExpired(authorization)){            try {                throw new RuntimeException(\"非法Token\");            }catch (Exception e){            }        }        String redisKey = \"login:\"+uid.asString();        //从redis里面获取对象        SecurityUser securityUser =(SecurityUser) redis.get(redisKey);        //如果redis里面没有相应的token，那么说明token非法        if(Objects.isNull(securityUser)){            throw new RuntimeException(\"您未登录\");        }        //TODO 获取权限信息封装到Authentication中        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(securityUser,null,securityUser.getAuthorities());        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);        //放行        filterChain.doFilter(request,response);    }}\n\n\n\n3、实现WebSecurityConfigurerAdapter接口对Security进行配置：import com.cbq.springsecuritystudy6.filter.JwtCheckFilter;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.annotation.Resource;@Slf4j@Configuration@EnableGlobalMethodSecurity(prePostEnabled = true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter {    @Resource    MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;    @Resource    JwtCheckFilter jwtCheckFilter;    @Bean    public PasswordEncoder passwordEncoder() {        return new BCryptPasswordEncoder();    }    @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception {        return super.authenticationManagerBean();    }    @Override    protected void configure(HttpSecurity http) throws Exception {        //关闭csrf        http.csrf().disable();        //这里是将之前自定义实现拦截器的接口解将其放到用户账号密码认证拦截器的前面        http.addFilterBefore(jwtCheckFilter, UsernamePasswordAuthenticationFilter.class);        //这里因为是基于JWT的前后端分离项目了，所以没必要用SESSION进行认证之类的，所以直接取消掉        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);        http.authorizeRequests()                .antMatchers(\"/**/**.html\").denyAll()//这里配置主要是用于阻止用户直接通过url访问html静态资源，提高安全性。                .antMatchers(\"/login/**\").permitAll()//这里是将login登录接口相关的全部放开                .anyRequest()                .authenticated();        http.formLogin()                .loginPage(\"/login/index.html\")//这里配置登录页面                .permitAll();    }}\n\n\n好了，到这所有的Security配置基本完成了。现在就是相关的访问接口的实现和对接。\n\n实现登录的相关API接口等：Controller层\n LoginController\n\nimport com.cbq.springsecuritystudy6.entity.User;import com.cbq.springsecuritystudy6.service.LoginService;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@RestController@RequestMapping(\"login\")public class LoginController {    @Resource    private LoginService loginService;    @PostMapping(\"login\")    public Object login(@RequestBody User user){        return loginService.toLogin(user.getUid(),user.getPassword());    }}\n\nUserController\n\nimport org.springframework.security.access.prepost.PreAuthorize;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(\"user\")public class UserController {    @ResponseBody    @GetMapping(\"query\")    @PreAuthorize(\"hasAuthority('root:query') or hasRole('ROOT')\")    public Object query(){        System.out.println(\"成功访问查询页面\");        return \"成功访问查询页面\";    }    @ResponseBody    @GetMapping(\"delete\")    @PreAuthorize(\"hasRole('ROOT')\")    public Object delete(){        return \"删除成功\";    }    @GetMapping(\"index\")    public Object toIndex(){        return \"forward:/home/index.html\";    }}\n\n\n\nService层\nLoginService\n\nimport com.cbq.springsecuritystudy6.entity.User;import com.cbq.springsecuritystudy6.filter.JwtCheckFilter;import com.cbq.springsecuritystudy6.mapper.UserMapper;import com.cbq.springsecuritystudy6.service.LoginService;import com.cbq.springsecuritystudy6.service.RoleService;import com.cbq.springsecuritystudy6.utils.JWTUtils;import com.cbq.springsecuritystudy6.vo.SecurityUser;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.*;@Servicepublic class LoginServiceImpl implements LoginService {    @Resource    UserMapper userMapper;    @Resource    RoleService roleService;    @Resource    ObjectMapper objectMapper;    @Override    public Object toLogin(String uid, String password) {        Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();        //通过Security生成Token        List&lt;String&gt; strings = roleService.queryPermissionsByUserUid(uid);        SecurityUser securityUser = new SecurityUser(User.builder().build());        List&lt;SimpleGrantedAuthority&gt; authorityList = new ArrayList&lt;&gt;();        strings.forEach((v)-&gt;{authorityList.add(new SimpleGrantedAuthority(v));});        securityUser.setAuthorityList(authorityList);        //装置至Redis        JwtCheckFilter.redis.put(\"login:\"+uid,securityUser);        //TODO 成功        Map&lt;String, String&gt; tokenMap = new HashMap&lt;&gt;();        tokenMap.put(\"uid\", uid);        String token = JWTUtils.createToken(tokenMap);        result.put(\"code\", 200);        result.put(\"msg\", \"登录成功\");        result.put(\"token\", token);        return result;    }}\n\n\nUserService\n\nimport com.cbq.springsecuritystudy6.entity.User;import com.cbq.springsecuritystudy6.mapper.UserMapper;import com.cbq.springsecuritystudy6.service.UserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Servicepublic class UserServiceImpl implements UserService {    @Resource    UserMapper userMapper;    @Override    public User getUserFromUid(String uid) {        User user = userMapper.getUserByUid(uid);        return user;    }    @Override    public User userLogin(String uid, String password) {        User user = userMapper.getUser(uid, password);        return user;    }}\n\n\nRoleService\n\nimport com.cbq.springsecuritystudy6.mapper.RoleMapper;import com.cbq.springsecuritystudy6.service.RoleService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class RoleServiceImpl implements RoleService {    @Resource    private RoleMapper roleMapper;    @Override    public List&lt;String&gt; queryPermissionsByUserUid(String uid) {        List&lt;String&gt; strings = roleMapper.queryRolePermissionsByUserId(uid);        return strings;    }}\n\n\n\nMapper\nUserMapper\n\nimport org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;import java.util.List;public interface RoleMapper {    /**     * 通过UID查询对应的用户权限的详细权限列表     * @param uid     * @return     */    @Select(\"select role_menu.code from user,role,role_menu where user.role_uid=role.uid and role.uid=role_menu.role_uid AND user.uid=#{uid}\")    public List&lt;String&gt; queryRolePermissionsByUserId(@Param(\"uid\") String uid);}\n\n\nRoleMapper\n\nimport com.cbq.springsecuritystudy6.entity.User;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.annotations.Select;public interface UserMapper {    /**     * 通过账号和密码查询账号实体     * @param uid     * @param password     * @return     */    @Select(\"select * from user where uid=#{uid} and password=#{password}\")    public User getUser(@Param(\"uid\")String uid,@Param(\"password\")String password);    /**     * 通过账号查询账号实体     * @param uid     * @return     */    @Select(\"select * from user where uid=#{uid}\")    public User getUserByUid(@Param(\"uid\")String uid);}\n","categories":["Java","Spring"],"tags":["Java","Spring Security"]},{"title":"WebRTC进阶","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/webrtc/","content":"WebRTC进阶\nWebTRC支持点对点通信，但是WebRTC仍然需要服务端：\n\n协调通讯过程中客户端之间需要交换元数据。\n如一个客户端找到另一个客户端以及通知另一个客户端开始通讯。\n需要处理NAT（网络地址转换）或防火墙，这是公网上通讯首要处理的问题。\n所以我们需要了解服务端的知识：信令、Stun、trun、ice。\n\n一、什么是信令\n信令就是协调通讯的过程，为了建立一个webRTC的通讯过程，客户端需要交换如下信息：\n\n会话控制信息，用来开始和结束通话，即开始视频、结束视频这些操作指令。\n处理错误的消息。\n元数据，如各自的音视频解码方式、带宽。\n网络数据，对方的公网IP、端口、内网IP及端口。\n\n\n信令处理过程需要客户端能够来回传递消息，这个过程在WebRTC里面是没有实现的，需要自己创建。一旦信令服务建立好了,两个客户端之间建立了连接,理论上他们就可以进行点对点通讯了,这样可以减轻信令服务的压力和消息传递的延迟。\n\n\n因为信令是我们自己定义的,所以安全性问题跟WebRTC无关,需要自己处理。一旦黑客掌握了你的信令,那他就是控制会话的开始、结束、重定向等等。最重要的因素在信令安全中还是要靠使用安全协议,如HTTPS,WSS(如TLS),他们能确保未加密的消息不能被截取。为确保信令安全,强烈推荐使用TLS。\n\n二、TURN和STUN\n\n元数据是通过信令服务器中转发给另一个客户端,但是对于流媒体数据,一旦会话建立,首先尝试使用点对点连接。简单一点说就是:每个客户端都有一个唯一的地址,他能用来和其他客户端进行通讯和数据交换。\n\n\n现实生活中客户端都位于一个或多个NAT之后,或者一些杀毒软件还阻止了某些端口和协议,或者在公司还有防火墙或代理等等,防火墙和NAT或许是同一个设备,如我们家里用的路由器。\n\n\nWebRTC就是通过 ICE 这套框架来处理复杂的网络环境的,如果想启用这个功能,你必须让你的应用程序传 ICE 服务器的URL：ICE试着找最好的路径来让客户端建立连接,他会尝试所有可能的选项,然后选择最合适的方案,ICE首先尝试P2P连接,如果失败就会通过Turn服务器进行转接。\n\n\n换一个说法就是:STUN服务器是用来取外网地址的。TURN服务器是在P2P失败时进行转发的\n\n\nstun和turn服务的作用主要处理打洞与转发，配合完成ICE协议。首先尝试使用P2P，如果失败将求助于TCP，使用turn转发两个端点的音视频数据，turn转发的是两个端点之间的音视频数据不是信令数据。因为turn服务器是在公网上，所以他能被各个客户端找到，另外turn服务器转发的是数据流，很占用带宽和资源。\n\n三、ICE技术\n\n基于IP的语音、数据、视频等业务在NGN（Next Generation Network）网络中所面临的一个实际困难就是如何有效地穿透各种NAT（Network Address Translator）/FW(Fire Wall)的问题。对此，SIP（会话初始化协议）以往的解决方法由ALGs（(Application Layer Gateway Service)）、STUN、TURN等方式。\n\n\n现在有一种新的媒体会话信令穿透NAT/FW的解决方案-交互式连通建立方式ICE。它通过综合利用现有协议，以一种更有效的方式来组织会话建立过程，使之在不增加任何延迟同时比STUN等单一协议更具有健壮性、灵活性。多媒体会话信令协议是在准备建立媒体流传输的代理之间交互信息的协议，例如SIP、RTSP（real time streaming protocol）等。\n\n\n媒体流与信令流截然不同，它们所采用的网络通道也不一致。由于协议自身设计上的原因，使得媒体流无法直接穿透网络地址转换/防火墙(NAT/FW)。因为它们生存期的目标只是为了建立一个在信息中携带IP地址的分组流，这在遇到NAT/FW 时会带来许多问题。而且这些协议的目标是通过建立P2P(Peer to Peer)媒体流以减小时延，而协议本身很多方面却与NAT存在兼容性问题，这也是穿透 NAT/FW的困难所在。\n\n四、ICE简介\n\n交互式连通建立方式ICE(Interactive Connectivity Establishment)并非一种新的协议，它不需要对STUN、TURN或RSIP进行扩展就可适用于各种NAT。\n\n\nICE是通过综合运用上面某几种协议，使之在最适合的情况下工作，以弥补单独使用其中任何一种所带来的固有缺陷。对于SIP来说，ICE只需要定义一些SDP(Session Description Protocol)附加属性即可，对于别的多媒体信令协议也需要制定一些相应的机制来实现。\n\n五、多媒体信令\n\n媒体流穿透NAT的过程是独立于某种具体的信令协议的。通信发生在两个客户端－会话发起者和会话响应者。初始化信息(Initiate Message)包含了描述会话发起者媒体流的配置与特征，并经过信令调停者(也叫信令中继)，最后到达会话响应者。\n\n\n假设会话响应者同意通信，接受信息(Accept Message)将产生并反馈至会话初始者，媒体流建立成功。此外，信令协议还对媒体流参数修改以及会话终止消息等提供支持。对于SIP，会话发起者即UAC(User Agent Client)，会话响应者即UAS(User Agent Server)，初始化消息对应SDP请求里面的INVITE，接受消息对应于SDP应答里面的200 OK，终止消息对应于BYE。\n\n六、流程\n1、收集传输地址\n会话发起者需要收集的对象包括：\n\n本地传输地址(Local Transport Address)\n来源传输地址(Derived Transport Address)。\n\n\n本地传输地址：\n\n通常由主机上一个物理(或虚拟)接口绑定一个端口而获得。会话发起者还将访问提供UNSAF(Unilateral self-address fixing)的服务器，例如STUN、TURN或TEREDO。\n对于每一个本地传输地址，会话者都可以从服务器上获得一组来源传输地址。\n\n\n显然，实现物理或虚拟连通方式越多，ICE将工作得越好。但为了建立对等通信，ICE通常要求至少有一个来源地址由位于公网上的中继服务器(如TURN)所提供的，而且需要知道具体是哪一个来源传输地址。\n\n2、启动STUN\n会话发起者获得一组传输地址后，将在本地传输地址启动STUN服务器，这意味着发送到来源地址的STUN服务将是可达的。与传统的STUN不同，客户端不需要在任何其它IP或端口上提供STUN服务，也不必支持TLS， ICE用户名和密码已经通过信令协议进行交换。客户端将在每个本地传输地址上同时接受STUN请求包和媒体包，所以发起者需要消除STUN消息与媒体流协议之间的歧义。\n\n\n在RTP和RTCP中实现这个并不难，因为RTP与RTCP包总是以0b10(v=2)打头，而STUN是0b00。对于每个运行STUN服务器的本地传输地址，客户端都必须选择相应的用户名和密码。用户名要求必须是全局唯一的，用户名和密码将被包含在初始化消息里传至响应者，由响应者对STUN请求进行鉴别。\n\n3. 确定传输地址的优先级\nSTUN服务器启动后，下一步就是确定传输地址的优先级。优先级反映了UA在该地址上接收媒体流的优先级别，取值范围在0到1之间，通常优先级按照被传输媒体流量来确定。\n\n\n流量小者优先，而且对于相同流量者的Ipv6地址比Ipv4地址具有更高优先级。因此物理接口产生的本地Ipv6传输地址具有最高的优先级，然后是本地Ipv4传输地址，然后是STUN、RSIP、TEREDO来源地址，最后是通过VPN接口获得的本地传输地址。\n\n4. 构建初始化信息(Initiate Message)\n初始化消息由一系列媒体流组成，每个媒体流都有一个缺省地址和候选地址列表。缺省地址通常被Initiate消息映射到SIP信令消息传递地址上，而候选地址列表用于提供一些额外的地址。对于每个媒体流来说，任意Peer之间实现最大连通可能性的传输地址是由公网上转发服务器(如TURN)提供的地址，通常这也是优先级最低的传输地址。客户端将可用的传输地址编成一个候选地址列表(包括一个缺省地址)，并且为每个候选元素分配一个会话中唯一的标识符。该标识符以及上述的优先级都被编码在候选元素的id属性中。一旦初始化信息生成后即可被发送。\n\n5. 响应处理：连通性检查和地址收集\n会话应答方接收到初始化信息Initiate Message后，会同时做几个事情：首先，执行 收集传输地址 中描述的地址收集过程。这些地址可以在呼叫到达前预收集，这样可以避免增加呼叫建立的时间。当获得来源地址以后，应答方会发送STUN Bind请求，该请求要求必须包含Username属性和Password属性，属性值为从 “alt”中得到的用户名和密码。\n\n\nSTUN Bind请求还应包括一个Message-Integrity属性，它是由Initiate Message中候选元素的用户名和密码计算得来的。此外，STUN Bind请求不应有Change-Request或Response-Address属性。当一个客户端收到Initiate Message时，它将通过其中缺省地址和端口发送媒体流。如果STUN Bind请求消息引起错误应答，则需要检查错误代码。\n\n\n如果是401，430，432或500，说明客户端应该重新发送请求。如果错误代码是400，431和600，那么客户端不必重试，直接按超时处理即可。\n\n6. 生成接受信息(Accept Message)\n应答者可以决定是接受或拒绝该通信，若拒绝则ICE过程终止，若接受则发送Accept消息。Accept消息的构造过程与Initiate Message类似。\n\n7. 接受信息处理\n接受过程有两种可能。如果Initiate Message的接受者不支持ICE，则Accept Message将只包含缺省的地址信息，这样发起方就知道它不用执行连通性检查了。然而如果本地配置信息要求发起者通过TURN服务器发包来进行连通性检查，这将意味着那些直接发给响应者的包会被对方防火墙丢弃。\n\n\n为解决这个问题，发起者需要重新分配一个TURN来源地址，然后使用Send命令。一旦Send命令被接受，发起者将发送所有的媒体包到TURN服务器，由服务器转发至响应者。如果Accept Message包含候选项，则发起方处理Accept Message的过程就与响应方处理Initiate Message很相似了。\n\n8. 附加ICE过程\nInitiate或Accept消息交换过程结束后，双方可能仍将继续收集传输地址，这通常是由于某些STUN事务过长而未结束引起，另一种可能是由于Initiate/Accept消息交换时提供了新的地址。\n\n9. ICE到SIP的映射\n使用ICE方式穿透NAT，必须映射ICE定义的参数到SIP消息格式中，同时对其SDP属性进行简单扩展—在SDP的Media块中定义一个新的属性“alt”来支持ICE。它包含一个候选IP地址和端口，SDP的接受端可以用该地址来替换m和c中的地址。Media块中可能会有多个alt属性，这时每个alt应该包括不重复的IP地址和端口。\n\n七、写在最后\nICE方式的优势是显而易见的，它消除了现有的UNSAF机制的许多脆弱性。例如传统的STUN有几个脆弱点：\n\n 一个是发现过程需要客户端自己去判断所在NAT类型，这实际上不是一个可取的做法。而应用ICE之后，这个发现过程已经不需要了。\n\n\n另一点脆弱性在于STUN、TURN等机制都完全依赖于一个附加的服务器，而ICE利用服务器分配单边地址的同时，还允许客户端直接相连，因此即使STUN或TRUN服务器中有任何一个失败了，ICE方式仍可让呼叫过程继续下去。\n\n\n此外，传统的STUN最大的缺陷在于它不能保证在所有网络拓扑结构中都正常工作，最典型的问题就是Symmetric NAT。对于TURN或类似转发方式工作的协议来说，由于服务器的负担过重，很容易出现丢包或者延迟情况。而ICE方式正好提供了一种负载均衡的解决方案，它将转发服务作为优先级最低的服务，从而在最大程度上保证了服务的可靠性和灵活性。\n\n\n此外，ICE的优势还在于对Ipv6的支持，目前Cisco等公司正在设计基于ICE方式的NAT/FW解决方案。\n\n\n由于广泛的适应能力以及对未来网络的支持，ICE作为一种综合的解决方案将有着非常广阔的应用前景。\n\n","categories":["WebRTC"],"tags":["WebRTC"]},{"title":"Web项目实战","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/web-xiang-mu-de-kai-fa/","content":"Web项目实战web项目的开发：如何分析，设计，编码，测试。\n2.CRM项目：\nCRM项目就是客户关系管理项目。客户关系管理（CRM）是利用信息科学技术，实现市场营销、销售、服务等活动自动化，使企业能更高效地为客户提供满意、周到的服务，以提高客户满意度、忠诚度为目的的一种管理经营方式。客户关系管理既是一种管理理念，又是一种软件技术。以客户为中心的管理理念是CRM实施的基础。Crm项目的背景分为起源背景和发展背景两部分。\n\n3.CRM的技术架构：\n视图层（View）：展示数据，跟用户交互。\n​\t\t\t\t\t\t\tHTML，CSS，JavaScript，jQuery，bootstrap（ext|easyUI），jsp\n控制层（Controller）：控制业务处理流程（接收请求，接收参数，封装参数；根据不同的请求调用业务层去处理业务；根据处理结果，返回响应信息）\n​\t\t\t\t\t\t\t\t\t（Servlet，）SpringMVC（，webwork，Struts）\n业务层（Service）：处理业务逻辑。（处理业务的步骤以及操作的原子性）\n​\t\t\t\t\t\t\t\tJAVASE（工作流：activiti | JBPM）\n​\t\t\t\t\t\t\t\t1，添加学生\n​\t\t\t\t\t\t\t\t2，记录操作日记\n持久层（Dao/Mapper）：操作数据库。\n​\t\t\t\t\t\t\t\t\t\t（jdbc，）MyBatis（，Hibernate）\n整合层：维护类资源，维护数据库资源\n​\t\t\tSpring（IOC，AOP）（，ejb，corba）\n\n4.软件公司的组织结构：\n研发部（程序员，美工，DBA），测试部（），实施部，运维部，市场部\n\n搭建开发环境：\n创建项目：crm-project\n设置JDK。\n创建工程：crm\n补全目录结构：\n设置编码格式：UTF-8\n\n添加jar包：添加依赖——参考课件。\n\n添加配置文件：\n\n\n","categories":["Web","软件工程"],"tags":["软件工程"]},{"title":"zookeeper学习","url":"/2025/04/18/learnnote/java-xue-xi-bi-ji/zookeeper-xue-xi/","content":"zookeeper学习\n","categories":["zookeeper"],"tags":["zookeeper","java"]},{"title":"什么是幂等性","url":"/2025/03/01/learnnote/java-xue-xi-bi-ji/shi-me-shi-mi-deng-xing/","content":"什么是幂等性\n\n幂等性，就是套个高大上名字的普通概念，根本不是什么新概念，甚至你开发时经常会实现所谓的幂等性\n\n幂等性通俗概念：调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果。就是不论调用多少次你对我的影响以及你的影响都是不变的，部长随着次数的变化而变化。\n简单举个例子：天然幂等性：加上对象Person中有个name属性，有个\nsetName(String name) {    this.name = name;}\n\n的方法，那这个方法就是天然幂等的，你输入相同的“小明”参数，不论你重复调用多少次都是将名字设置为“小明”，其对对象Person的影响都是一样的。这就是天然幂等性。\n非幂等性：还是拿对象Person举例子，假设对象中有个age属性，有个\nincreaseAge(){    this.age++;}\n\n方法，我们按正常的步骤一次一次调用是不会有问题的，如果调用者没有掌控好逻辑，一次流程重复调用好几次，这时候影响效果和一次是有非常大区别，代码编写者以为它只会调用一次，结果出现了意外调用了很多次，恰好方法不具有幂等性，于是就会出现和预期不一样的效果。这个方法本身是不具备幂等性的，我可以修改这个方法，让其传入一个标识符，每一次重复的请求会有相同的标识符，方法内部可以更具标识符查数据库是不是已经处理过，如果处理过就不重复处理。这样方法就具备了幂等性。\n再举个实际点的例子：客户在进行一笔转账交易，后端划分了两个系统来处理这个转账的流程：\n①系统A负责收集转账人和接收人还有金额的信息然后传给系统B进行转账，将控制逻辑留在系统A。\n②系统B读取系统A传过来的信息，负责更改数据库的金额。如果操作成功，就回复系统A成功，如果失败就回复系统A失败。\n③系统A可以接受系统B操作成功或失败的回复，但是我们知道，系统A这个交易流程是有等待时间的，如果等待超时，它不确认是否是转账成功或失败，于是系统A会重试调用直到得到一个明确的回复。\n这是系统大致的交易流程。这个流程是有问题的，系统B提供的操作接口不是幂等性的。\n逻辑漏洞：假设系统B操作成功了，但是由于系统B回复的时候遇到网络抖动、网络阻塞、网络风暴等，这个成功的消息没有及时被系统A接收，系统A再重试让系统B转账，结果会导致：用户点击一次转账，后台为他转了很多笔。这是非常危险的。\n解决办法：我们可以为每一笔用户发起的转账请求赋予一个全局唯一的ID，把这个ID在调用系统B的时候一起传输进去，第一次系统B处理的时候正常处理，处理完之后把转账成功还是失败的状态与ID一起存入数据库，下次重复请求会查找数据库，查出来数据为空则代表第一次请求，查出来状态为成功，则直接返回成功，查出来状态为失败，则再操作一次。这样能确保不会出现上述逻辑错误\n总结：很多方法具有天然的幂等性，有的方法不具备，我们需要业务逻辑层来实现幂等性。我们开发的过程中考虑全面了就能自然的实现幂等性，幂等性根本就不是什么新的知识。\n","categories":["Java"],"tags":["Java","幂等性","后端"]},{"title":"WebRTC实现前端代码","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/yong-websocket-jie-he-webrtc-shi-xian-de-yuan-cheng-shi-ping-tong-hua/","content":"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;RTC视频通话测试页面&lt;/title&gt;    &lt;meta charset=\"UTF-8\"&gt; &lt;!-- for HTML5 --&gt;    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;    &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;style type=\"text/css\"&gt;    body {        background: #000;    }    button {        height: 40px;        line-height: 40px;        width: 500px;        top: 100px;        padding: 0 15px;        contain: content;        background: #ccc;        border: none;        border-radius: 10px;        margin-bottom: 10px;        overflow: hidden;    }    .wrap {        width: 100vw;        height: 100vh;        display: flex;        justify-content: center;        align-items: center;    }    .video-box {        border-radius: 20px;        background: pink;        position: relative;        width: 800px;        height: 600px;        overflow: hidden;    }    .remote-video {        width: 800px;        height: 600px;        border: 1px solid black;        overflow: hidden;    }    .local-video {        width: 320px;        height: 240px;        position: absolute;        right: 0;        bottom: 0;        border-radius: 20px 0 0 0;        overflow: hidden;    }    video {        width: 100%;        height: 100%;    }&lt;/style&gt;&lt;div class=\"wrap\"&gt;    &lt;div&gt;        &lt;div class=\"video-box\"&gt;            &lt;div class=\"local-video\"&gt;                &lt;video id=\"local-video\" autoplay style=\"\"&gt;&lt;/video&gt;            &lt;/div&gt;            &lt;div class=\"remote-video\"&gt;                &lt;video id=\"remote-video\" autoplay&gt;&lt;/video&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;button type=\"button\" onclick=\"startVideo();\"&gt;开启本机摄像和音频&lt;/button&gt;            &lt;button type=\"button\" onclick=\"connect();\"&gt;建立连接&lt;/button&gt;            &lt;button type=\"button\" onclick=\"hangUp();\"&gt;挂断&lt;/button&gt;            &lt;button type=\"button\" onclick=\"refreshPage();\"&gt;刷新页面&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;    // ===================以下是socket=======================    var user = Math.round(Math.random() * 1000) + \"\"    //var socketUrl = \"ws://localhost:8080/msgServer/\" + user;    var socketUrl = \"ws://172.29.40.176:8080/msgServer/\"+ user;    var socket = null    var socketRead = false    window.onload = function() {        socket = new WebSocket(socketUrl)        socket.onopen = function() {            console.log(\"成功连接到服务器...\")            socketRead = true        }        socket.onclose = function(e) {            console.log('与服务器连接关闭: ' + e.code)            socketRead = false        }        socket.onmessage = function(res) {            var evt = JSON.parse(res.data)            console.log(evt)            if (evt.type === 'offer') {                console.log(\"接收到offer,设置offer,发送answer....\")                onOffer(evt);            } else if (evt.type === 'answer' &amp;&amp; peerStarted) {                console.log('接收到answer,设置answer SDP');                onAnswer(evt);            } else if (evt.type === 'candidate' &amp;&amp; peerStarted) {                console.log('接收到ICE候选者..');                onCandidate(evt);            } else if (evt.type === 'bye' &amp;&amp; peerStarted) {                console.log(\"WebRTC通信断开\");                stop();            }        }    }    // ===================以上是socket=======================    var localVideo = document.getElementById('local-video');    var remoteVideo = document.getElementById('remote-video');    var localStream = null;    var peerConnection = null;    var peerStarted = false;    var mediaConstraints = {        'mandatory': {            'OfferToReceiveAudio': false,            'OfferToReceiveVideo': true        }    };    //----------------------交换信息 -----------------------    function onOffer(evt) {        console.log(\"接收到offer...\")        console.log(evt);        setOffer(evt);        sendAnswer(evt);        peerStarted = true    }    function onAnswer(evt) {        console.log(\"接收到Answer...\")        console.log(evt);        setAnswer(evt);    }    function onCandidate(evt) {        var candidate = new RTCIceCandidate({            sdpMLineIndex: evt.sdpMLineIndex,            sdpMid: evt.sdpMid,            candidate: evt.candidate        });        console.log(\"接收到Candidate...\")        console.log(candidate);        peerConnection.addIceCandidate(candidate);    }    function sendSDP(sdp) {        var text = JSON.stringify(sdp);        console.log('发送sdp.....')        console.log(text); // \"type\":\"offer\"....        // textForSendSDP.value = text;        // 通过socket发送sdp        socket.send(text)    }    function sendCandidate(candidate) {        var text = JSON.stringify(candidate);        console.log(text); // \"type\":\"candidate\",\"sdpMLineIndex\":0,\"sdpMid\":\"0\",\"candidate\":\"....        socket.send(text) // socket发送    }    //---------------------- 视频处理 -----------------------    function startVideo() {        navigator.mediaDevices.enumerateDevices()        .then(function (devices) {            devices.forEach(function (device) {                //打印设备类型，设备名称，设备ID                console.log(device.kind+\":\"+device.label+\" id=\"+device.deviceId);                //根据设备名称，去获取特定的摄像头                if(device.label.indexOf(\"Logitech\")!=-1){                }            })        });        if (navigator.mediaDevices.getUserMedia) {            //最新的标准API            navigator.mediaDevices.getUserMedia({                video: true,                audio: true            }).then(function(stream) { //success                localStream = stream;                localVideo.srcObject = stream;                //localVideo.src = window.URL.createObjectURL(stream);                localVideo.play();                localVideo.volume = 0;            }).catch(function(error) { //error                console.error('发生了一个错误: [错误代码：' + error.code + ']');                return;            });        } else if (navigator.webkitGetUserMedia) {            //webkit核心浏览器            navigator.webkitGetUserMedia({                video: true,                audio: true            },function(stream) { //success                localStream = stream;                localVideo.srcObject = stream;                //localVideo.src = window.URL.createObjectURL(stream);                localVideo.play();                localVideo.volume = 0;            }, error)        } else if (navigator.mozGetUserMedia) {            //firfox浏览器            navigator.mozGetUserMedia({                video: true,                audio: true            }, function(stream) { //success                localStream = stream;                localVideo.srcObject = stream;                //localVideo.src = window.URL.createObjectURL(stream);                localVideo.play();                localVideo.volume = 0;            }, error);        } else if (navigator.getUserMedia) {            //旧版API            navigator.getUserMedia({                video: true,                audio: true            }, function(stream) { //success                localStream = stream;                localVideo.srcObject = stream;                //localVideo.src = window.URL.createObjectURL(stream);                localVideo.play();                localVideo.volume = 0;            }, error);        }            }    function refreshPage() {        location.reload();    }    //---------------------- 处理连接 -----------------------    function prepareNewConnection() {        var pc_config = {            \"iceServers\": []        };        var peer = null;        try {            peer = new RTCPeerConnection(pc_config);        } catch (e) {            console.log(\"建立连接失败，错误：\" + e.message);        }        // 发送所有ICE候选者给对方        peer.onicecandidate = function(evt) {            if (evt.candidate) {                console.log(evt.candidate);                sendCandidate({                    type: \"candidate\",                    sdpMLineIndex: evt.candidate.sdpMLineIndex,                    sdpMid: evt.candidate.sdpMid,                    candidate: evt.candidate.candidate                });            }        };        console.log('添加本地视频流...');        peer.addStream(localStream);        peer.addEventListener(\"addstream\", onRemoteStreamAdded, false);        peer.addEventListener(\"removestream\", onRemoteStreamRemoved, false);        // 当接收到远程视频流时，使用本地video元素进行显示        function onRemoteStreamAdded(event) {            console.log(\"添加远程视频流\");            // remoteVideo.src = window.URL.createObjectURL(event.stream);            remoteVideo.srcObject = event.stream;        }        // 当远程结束通信时，取消本地video元素中的显示        function onRemoteStreamRemoved(event) {            console.log(\"移除远程视频流\");            remoteVideo.src = \"\";        }        return peer;    }    function sendOffer() {        peerConnection = prepareNewConnection();        peerConnection.createOffer(function(sessionDescription) { //成功时调用            peerConnection.setLocalDescription(sessionDescription);            console.log(\"发送: SDP\");            console.log(sessionDescription);            sendSDP(sessionDescription);        }, function(err) { //失败时调用            console.log(\"创建Offer失败\");        }, mediaConstraints);    }    function setOffer(evt) {        if (peerConnection) {            console.error('peerConnection已存在!');            return;        }        peerConnection = prepareNewConnection();        peerConnection.setRemoteDescription(new RTCSessionDescription(evt));    }    function sendAnswer(evt) {        console.log('发送Answer,创建远程会话描述...');        if (!peerConnection) {            console.error('peerConnection不存在!');            return;        }        peerConnection.createAnswer(function(sessionDescription) { //成功时            peerConnection.setLocalDescription(sessionDescription);            console.log(\"发送: SDP\");            console.log(sessionDescription);            sendSDP(sessionDescription);        }, function() { //失败时            console.log(\"创建Answer失败\");        }, mediaConstraints);    }    function setAnswer(evt) {        if (!peerConnection) {            console.error('peerConnection不存在!');            return;        }        peerConnection.setRemoteDescription(new RTCSessionDescription(evt));    }    //-------- 处理用户UI事件 -----    // 开始建立连接    function connect() {        if (!localStream) {            window.alert(\"请首先捕获本地视频数据.\");        } else if (peerStarted || !socketRead) {            window.alert(\"请刷新页面后重试.\");        } else {            sendOffer();            peerStarted = true;        }    }    // 停止连接    function hangUp() {        console.log(\"挂断.\");        stop();    }    function stop() {        peerConnection.close();        peerConnection = null;        peerStarted = false;    }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["WebRTC"],"tags":["WebRTC","HTML","前端"]},{"title":"项目中的实体类分类的区别和作用","url":"/2023/02/24/learnnote/java-xue-xi-bi-ji/xiang-mu-zhong-de-shi-ti-lei-fen-lei-de-qu-bie-he-zuo-yong/","content":"项目中的实体类分类的区别和作用\n在一个Java的SpringBoot中，一般我们需要用到许多的实体类\n一般在一个大型项目中，又会把实体类分成不同阶段使用的类\n\nPO层POJO全称为：Plain Ordinary Java Object，即简单普通的java对象。一般用在数据层映射到数据库表的类，类的属性与表字段一一对应。\nPO全称为：Persistant Object，即持久化对象。可以理解为数据库中的一条数据，也可以理解为POJO经过持久化后的对象。\nDO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体，一般也和数据库对应\nBO层全称为：Business Object，即业务对象。一般用在业务层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递。一般是处理多个对象的工具类或者service\nVO层全称为：Value Object，有的也称为View Object，即值对象或页面对象。一般用于web层向view层封装并提供需要展现的数据\nDTO层全称为：Data Transfer Object，即数据传输对象。一般用于向数据层外围提供仅需的数据，如查询一个表有50个字段，界面或服务只需要用到其中的某些字段，DTO就包装出去的对象。可用于隐藏数据层字段定义，也可以提高系统性能，减少不必要字段的传输损耗。\n总结VO，BO，PO，DTO这样分层还是很有意义的。尤其在团队成员较多的情况下，结构更加一目了然，同时也能很大程度避免多端系统数据所需不一致时，有人修改属性影响其他页面。但也完全没有必要教条主义，把这些全部用上，需要根据所开发的业务复杂度来取舍，如果本身业务逻辑不负责，照搬全上反而让开发变的更复杂。\n命名规范• 数据对象：xxxPO，xxx即为数据表名。(也可DO)• 数据传输对象：xxxDTO，xxx为业务领域相关的名称。• 展示对象：xxxVO，xxx一般为网页名称。• 业务对象：xxxBO，xxx是业务名称。\n分层使用和转换controller层接受前端的VO,DTO接受service层BO向前端发送VO,DTO\nservice层接受controller层VO,DTO,BO,PO接受dao层的PO向controller层返回BO,PO\nDAO层接受service层的VO,DTO,BO,PO从数据库查询PO向service层返回PO\n","categories":["面向对象编程"],"tags":["SpringBoot","后端","面相对象编程"]},{"title":"ArchLinux安装","url":"/2024/06/23/learnnote/linux-xue-xi/archlinux-an-zhuang/","content":"ArchLinux安装\n加载完archLinux之后，输入快捷安装指令：\narchinstall\n\n\n\n\n\n\n\n\n\n","categories":["Linux"],"tags":["ArchLinux安装"]},{"title":"Linux学习(CentOS)","url":"/2023/02/24/learnnote/linux-xue-xi/linux-xue-xi/","content":"Linux学习\n目录作用\n/\t根目录\n/bin\t存放必要的指令\n/boot\t存放内核以及启动所需的文件\n/dev\t存放设备文件\n/etc\t存放系统配置文件\n/home\t普通用户的宿主目录，用户数据存放在其主目录中\n/lib\t存放必要的运行库\n/mnt\t存放临时的映射文件系统，通常用来挂载使用。\n/proc\t存放存储进程和系统信息\n/root\t超级用户的主目录\n/sbin\t存放系统管理程序\n/tmp\t存放临时文件\n/usr\t存放应用程序，命令程序文件、程序库、手册和其它文档、\n/var\t系统默认日志存放目录\n\nLinux常用命令\n​\t\t默认进入系统，我们会看到这样的字符：[root@localhost~]#，其中#代表当前是root用户登录，如果是$表示当前为普通用户。\n​\t\t我们了解Linux由很多目录文件构成，那我们来学习第一个Linux命令：\n​\t\tcd 命令，cd\t/home；解析：进入/home目录\n​\t\tcd /root 进入/root目录；cd ../返回上一级目录；cd ./当前目录；（.和..可以理解为相对路径：例如：cd /home/test ，cd加完整的路径，可以理解为绝对路径）\n更多的指令：\n\nls ./\t\t查看当前目录所有的文件和目录。\n\n\nls -a 查看所有的文件，包括隐藏文件以.开头的文件。\n\n​\t\t\n\npwd\t显示当前所在的目录。\n\n\nmkdir\t创建目录，用法 mkdir test，命令后接目录的名称。\n\n\nrmdir\t删除空目录\n\n\nrm\t删除文件或者目录，用法\trm -rf test.txt（-r表示递归，-f表示强制）。\n\n\ncp 拷贝文件，用法，cp old.txt\t/tmp/new.txt，常用来备份；如果拷贝目录需\t要加-r参数。\n\n\nmv\t重命名或者移动文件或者目录，用法，mv old.txt new.txt\n\n\ntouch\t创建文件，用法，touch test.txt，如果文件存在，则表示修改当前文\t\t\t件时间。\n\n\nUseradd\t创建用户，用法 useradd wugk，userdel删除用户。\n\n\nGroupadd\t创建组，用法groupadd wugk1，groupdel删除组。\n\n\nfind [目录下开始查找] -name “test.txt”\n\n\ncat test.txt\t\t打开文件（Linux默认的文本编辑器）\n\n\nvi\t修改某个文件，vi有三种模式：（ESC退出编辑）\n命令行模式、文本输入模式、末行模式。\n:w为保存的意思，:wq为保存退出\n默认vi打开一个文件，首先是命令行模式，然后按i进入文本输入模式，可以在文件里写入字符等信息。\n写完后，按ESC进入命令行模式，然后输入:进入末行模式，例如输入:wq表示保存退出。\n如果想直接退出，不保存，可以执行:q!，q!感叹号表示强制退出。\n\n\ncat\t查看文件内容，分页查看，cat是全部查看，如果篇幅很多，只能看到最后的篇幅。可以使用cat和more同时使用，例如：cat test.txt |more 分页显示text内容，|符号是管道符，用于把|前的输出作为后面命令的输入。\n\n\necho\t回显，用法 echo ok，会显示ok，输入什么就打印什么。\necho ok &gt; test.txt；把ok字符覆盖test.txt内容，&gt;表示追加并覆盖的意思。\n&gt;&gt;两个大于符号，表示追加，echo ok &gt;&gt; test.txt，表示向test.txt文件追加OK字符。不覆盖原文件里的内容。\n\n初学者常见的命令就如上所示，当然还有很多深入的命令需要学习。\n\n\nls -l [文件名]\t查看文件属性\n- rw- r– r– 1 root root12 Jul 31 04:24 test.txt\n第一位表示文件类型，-表示文件，d表示目录；后面每三位为一组。\n第一组：2-4位表示文件所有者的权限，即用户user权限，简称u\n第二组：5-7位表示文件所有者所属组成员的权限，group权限，简称g\n第三组：8-10位表示所有者所属之外的用户的权限，other权限，简称o\n从上面这个文件，我们可以看出test.txt文件对应的权限为：\nroot哟怒具有读和写的权限，root组具有读的权限，其他人具有读的权限。\n为了能更简单快捷的使用和熟悉权限，rwx权限可以用数字来表示，分别表示r（4）、w（2）、x（1）。\ntest.txt权限可以表示为：644\n\n\nchmod [组]+[权限] [文件]\t修改文件权限的指令\n比如：chmod o+w test.txt\n​\t\tchmod o-w test.txt\n​\t\tchmod u=rwx,g=rw,o=r test.txt\n​\t\tchomod 644 test.txt\n\n\nchown -R abc:abc test.txt\n修改权限组为abc abc\n-rw-r–r– a abc abc …………………..\n\n将最近的后台任务调到前台：\nfg\n\n命令进程号码N的命令进程放到前台执行\nfg N\n\n将命令进程号码为N的命令进程放到后台执行\nbg N\n\n查看当前在后台执行的命令，可查看命令进程号码\njobs\n\n压缩命令\ntar -zcvf 压缩文件名称 .tar.gz #被压缩文件名\n\nzip -r mydata.zip mydata #压缩mydata目录\n\n注意unzip指令cnetos不自带需要先安装unzip才行\nunzip安装：\nyum install zip unzip\n解压缩命令\ntar -zxvf 压缩文件名.tar.gz\n\nunzip 文件夹名称.zip\n\n注意unzip指令cnetos不自带需要先安装unzip才行\nunzip安装：\nyum install zip unzip\n\n\n查看防火墙状态\nsystemctl status firewalld.service\n\n运行上述命令后，如果看到有绿色字样标注的“active（running）”，说明防火墙是开启状态。\n\n开启防火墙\nsystemctl start firewalld.service\n关闭防火墙\nsystemctl stop firewalld.service\n\n关闭后，可查看防火墙状态，当显示disavtive（dead）的字样，说明CentOS 7防火墙已经关闭。但要注意的是，上面的命令只是临时关闭了CentOS 7防火墙，当重启操作系统后，防火墙服务还是会再次启动。如果想要永久关闭防火墙则还需要禁用防火墙服务。\n\n禁用防火墙服务\nsystemctl disable firewalld.service\n查看防火墙规则\nfirewall-cmd –list-all\n查看开放端口\nfirewall-cmd --list-ports\n\n\n查询端口是否开放\nfirewall-cmd –query-port=8080/tcp\n\n这里的8080指的就是需要查看的指定端口\n\n重启防火墙\nfirewall-cmd –reload\n开放指定端口\nfirewall-cmd –permanent –add-port=8080/tcp\n\n以上例子为开放端口8080\n(修改配置后需要重启防火墙)\n参数解释：firewall-cmd: 是Linux提供的操作firewall的一个工具；–permanent：表示设置为持久；–add-port：表示添加的端口。\n\n移除某个防火墙开启的端口\nfirewall-cmd –permanent –remove-port=8080/tcp\n\n(修改配置后需要重启防火墙)\n\n查看防火墙帮助\nfirewall-cmd --help\n查看 root 用户登录成功的IP及次数\ngrep \"Accepted password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more\n\n看看是否有不熟悉的IP地址\n\n查看尝试暴力破解 root 账户的IP及次数\ngrep \"Failed password for root\" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more\n查看尝试暴力破解用户名的IP及次数\ngrep \"Failed password for invalid user\" /var/log/secure | awk '{print $13}' | sort | uniq -c | sort -nr | more\n图像转边命令行\nsystemctl set-default multi-user.target\n\n输入之后再输入reboot重启即可。\n\n命令行转变图形\nsystemctl set-default graphical.target\n\n输入之后再输入reboot重启即可。\n\n添加环境变量1、打开终端，使用root用户或者具有sudo权限的用户登录到系统中。\n2、编辑/etc/profile文件，例如使用vim编辑器：\nsudo vim /etc/profile\n\n3、在文件末尾添加你需要设置的环境变量，例如添加JAVA_HOME环境变量：\nexport JAVA_HOME=/usr/local/jdk1.8.0_281export PATH=$JAVA_HOME/bin:$PATH\n\n4、保存并退出文件，然后配置生效：\nsource /etc/profile\n\nsource /etc/environment #使配置立即生效。\n\n5、验证环境变量是否设置成功：\necho $JAVA_HOME\n\n\n\n修改文件名称mv a.txt a1.txt\n\n\n\n\n\nvim操作\n全部删除：按esc键后，先按gg（到达顶部），然后dG全部复制：按esc键后，先按gg，然后ggyG全选高亮显示：按esc键后，先按gg，然后ggvG或者ggVG\n单行复制：按esc键后, 然后yy单行删除：按esc键后, 然后dd粘贴：按esc键后, 然后p\n","categories":["Linux"],"tags":["Linux"]},{"title":"Shell学习","url":"/2023/02/24/learnnote/linux-xue-xi/shell-xue-xi/","content":"Shell学习\necho说明：#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。echo 命令用于向窗口输出文本。\n#!/bin/bashecho \"Hello World!\"\n\n\n\n\n\n\n\nShell 变量在 Shell 编程中，变量是用于存储数据值的名称。\n定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：\nshellyour_name=\"runoob\"\n\n\n\n注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\n\n只包含字母、数字和下划线： 变量名可以包含字母（大小写敏感）、数字和下划线 _，不能包含其他特殊字符。\n不能以数字开头： 变量名不能以数字开头，但可以包含数字。\n避免使用 Shell 关键字： 不要使用Shell的关键字（例如 if、then、else、fi、for、while 等）作为变量名，以免引起混淆。\n使用大写字母表示常量： 习惯上，常量的变量名通常使用大写字母，例如 PI=3.14。\n避免使用特殊符号： 尽量避免在变量名中使用特殊符号，因为它们可能与 Shell 的语法产生冲突。\n避免使用空格： 变量名中不应该包含空格，因为空格通常用于分隔命令和参数。\n\n有效的 Shell 变量名示例如下：\nRUNOOB=\"www.runoob.com\"LD_LIBRARY_PATH=\"/bin/\"_var=\"123\"var2=\"abc\"\n\n无效的变量命名：\n# 避免使用if作为变量名if=\"some_value\"# 避免使用 $ 等特殊符号variable_with_$=42?var=123user*name=runoob# 避免空格variable with space=\"value\"\n\n等号两侧避免使用空格：\n# 正确的赋值variable_name=value# 有可能会导致错误variable_name = value\n\n除了显式地直接赋值，还可以用语句给变量赋值，如：\nfor file in `ls /etc`或for file in $(ls /etc)\n\n以上语句将/etc下目录的文件名循环出来。\n使用变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\nyour_name=\"qinjx\"echo $your_nameecho ${your_name}\n\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\nfor skill in Ada Coffe Action Java; do\techo \"I am good at ${skill}Script\"done\n\n如果不给skill变量加花括号，写成echo \"I am good at $skillScript\"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n推荐给所有变量加上花括号，这是个好的编程习惯。\n已定义的变量，可以被重新定义，如：\nyour_name=\"tom\"echo $your_nameyour_name=\"alibaba\"echo $your_name\n\n这样写法是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”,使用变量的时候才加美元符($)。\n只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。\n下面的例子尝试更改只读变量，结果报错：\n#!/bin/bashmyUrl=\"https://www.google.com\"readonly myUrlmyUrl=\"https://www.runoob.com\"\n\n运行脚本，结果如下：\n/bin/sh: NAME: This variable is read only.\n\n删除变量使用 unset 命令可以删除变量。语法：\nunset variable_name\n\n变量被删除后不能再次使用。unset 命令不能删除只读变量。\n#!/bin/shmyUrl=\"https://www.runoob.com\"unset myUrlecho $myUrl\n\n以上实例执行将没有任何输出。\n变量类型Shell 支持不同类型的变量，其中一些主要的类型包括：\n字符串变量： 在 Shell中，变量通常被视为字符串。\n你可以使用单引号 ' 或双引号 \" 来定义字符串，例如：\nmy_string='Hello, World!'或者my_string=\"Hello, World!\"\n\n整数变量： 在一些Shell中，你可以使用 declare 或 typeset 命令来声明整数变量。\n这样的变量只包含整数值，例如：\ndeclare -i my_integer=42\n\n这样的声明告诉 Shell 将 my_integer 视为整数，如果尝试将非整数值赋给它，Shell会尝试将其转换为整数。\n数组变量： Shell 也支持数组，允许你在一个变量中存储多个值。\n数组可以是整数索引数组或关联数组，以下是一个简单的整数索引数组的例子：\nmy_array=(1 2 3 4 5)\n\n或者关联数组：\ndeclare -A associative_arrayassociative_array[\"name\"]=\"John\"associative_array[\"age\"]=30\n\n环境变量： 这些是由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境。\n例如，PATH 变量包含了操作系统搜索可执行文件的路径：\necho $PATH\n\n特殊变量： 有一些特殊变量在 Shell 中具有特殊含义，例如 $0 表示脚本的名称，$1, $2, 等表示脚本的参数。\n$#表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等。\n\nShell 传递参数我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 $n，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数。\n例如可以使用 $1、$2 等来引用传递给脚本的参数，其中 $1 表示第一个参数，$2 表示第二个参数，依此类推。\n实例以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名（包含文件路径）：\n#!/bin/bash# author:长白崎# url:www.changbaiqi.topecho \"Shell 传递参数实例！\";echo \"执行的文件名：$0\";echo \"第一个参数为：$1\";echo \"第二个参数为：$2\";echo \"第三个参数为：$3\";\n\n为脚本设置可执行权限，并执行脚本，输出结果如下所示：\n$ chmod +x test.sh $ ./test.sh 1 2 3Shell 传递参数实例！执行的文件名：./test.sh第一个参数为：1第二个参数为：2第三个参数为：3\n\n另外，还有几个特殊字符用来处理参数：\n\n\n\n参数处理\n说明\n\n\n\n$#\n传递到脚本的参数个数\n\n\n$*\n以一个单字符串显示所有向脚本传递的参数。 如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。\n\n\n$$\n脚本运行的当前进程ID号\n\n\n$!\n后台运行的最后一个进程的ID号\n\n\n$@\n与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。\n\n\n$-\n显示Shell使用的当前选项，与set命令功能相同。\n\n\n$?\n显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n\n实例#!/bin/bash*# author:长白崎# url:www.changbaiqi.topecho \"Shell 传递参数实例！\";echo \"第一个参数为：$1\";echo \"参数个数为：$#\";echo \"传递的参数作为一个字符串显示：$*\";\n\n执行脚本，输出结果如下所示：\n$ chmod +x test.sh $ ./test.sh 1 2 3Shell 传递参数实例！第一个参数为：1参数个数为：3传递的参数作为一个字符串显示：1 2 3\n\n$* 与 $@ 区别：\n\n相同点：都是引用所有参数。\n不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。\n\n实例#!/bin/bash*# author:菜鸟教程*# url:www.runoob.com*echo \"-- \\$* 演示 ---\"for i in \"$*\"; do  echo $idoneecho \"-- \\$@ 演示 ---\"for i in \"$@\"; do  echo $idone\n\n执行脚本，输出结果如下所示：\n$ chmod +x test.sh $ ./test.sh 1 2 3-- $* 演示 ---1 2 3-- $@ 演示 ---123\n\n\n\n\n\nShell 基本运算符Shell 和其他编程语言一样，支持多种运算符，包括：\n\n算数运算符\n关系运算符\n布尔运算符\n字符串运算符\n文件测试运算符\n\n原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘ )：\n实例#!/bin/bash*val=`expr 2 + 2`echo \"两数之和为 : $val\"\n\n执行脚本，输出结果如下所示：\n两数之和为 : 4\n\n两点注意：\n\n表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。\n完整的表达式要被   包含，注意这个字符不是常用的单引号，在 Esc 键下边。\n\n\n算术运算符下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n\n\n\n运算符\n说明\n举例\n\n\n\n+\n加法\nexpr $a + $b 结果为 30。\n\n\n-\n减法\nexpr $a - $b 结果为 -10。\n\n\n*\n乘法\nexpr $a \\* $b 结果为  200。\n\n\n/\n除法\nexpr $b / $a 结果为 2。\n\n\n%\n取余\nexpr $b % $a 结果为 0。\n\n\n=\n赋值\na=$b 把变量 b 的值赋给 a。\n\n\n==\n相等。用于比较两个数字，相同则返回 true。\n[ $a == $b ] 返回 false。\n\n\n!=\n不相等。用于比较两个数字，不相同则返回 true。\n[ $a != $b ] 返回 true。\n\n\n注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。\n实例算术运算符实例如下：\n#!/bin/basha=10b=20val=`expr $a + $b`echo \"a + b : $val\"val=`expr $a - $b`echo \"a - b : $val\"val=`expr $a \\* $b`echo \"a * b : $val\"val=`expr $b / $a`echo \"b / a : $val\"val=`expr $b % $a`echo \"b % a : $val\"if [ $a == $b ]then  echo \"a 等于 b\"fiif [ $a != $b ]then  echo \"a 不等于 b\"fi\n\n\n\n执行脚本，输出结果如下所示：\na + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a 不等于 b\n\n\n注意：\n\n乘号(*)前边必须加反斜杠()才能实现乘法运算；\nif…then…fi 是条件语句，后续将会讲解。\n在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “\\“ 。\n\n\n\n关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：\n\n\n\n运算符\n说明\n举例\n\n\n\n-eq\n检测两个数是否相等，相等返回 true。\n[ $a -eq $b ] 返回 false。\n\n\n-ne\n检测两个数是否不相等，不相等返回 true。\n[ $a -ne $b ] 返回 true。\n\n\n-gt\n检测左边的数是否大于右边的，如果是，则返回 true。\n[ $a -gt $b ] 返回 false。\n\n\n-lt\n检测左边的数是否小于右边的，如果是，则返回 true。\n[ $a -lt $b ] 返回 true。\n\n\n-ge\n检测左边的数是否大于等于右边的，如果是，则返回 true。\n[ $a -ge $b ] 返回 false。\n\n\n-le\n检测左边的数是否小于等于右边的，如果是，则返回 true。\n[ $a -le $b ] 返回 true。\n\n\n实例关系运算符实例如下：\n#!/bin/basha=10b=20if [ $a -eq $b ]then  echo \"$a -eq $b : a 等于 b\"else  echo \"$a -eq $b: a 不等于 b\"fiif [ $a -ne $b ]then  echo \"$a -ne $b: a 不等于 b\"else  echo \"$a -ne $b : a 等于 b\"fiif [ $a -gt $b ]then  echo \"$a -gt $b: a 大于 b\"else  echo \"$a -gt $b: a 不大于 b\"fiif [ $a -lt $b ]then  echo \"$a -lt $b: a 小于 b\"else  echo \"$a -lt $b: a 不小于 b\"fiif [ $a -ge $b ]then  echo \"$a -ge $b: a 大于或等于 b\"else  echo \"$a -ge $b: a 小于 b\"fiif [ $a -le $b ]then  echo \"$a -le $b: a 小于或等于 b\"else  echo \"$a -le $b: a 大于 b\"fi\n\n执行脚本，输出结果如下所示：\n10 -eq 20: a 不等于 b10 -ne 20: a 不等于 b10 -gt 20: a 不大于 b10 -lt 20: a 小于 b10 -ge 20: a 小于 b10 -le 20: a 小于或等于 b\n\n\n布尔运算符下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：\n\n\n\n运算符\n说明\n举例\n\n\n\n!\n非运算，表达式为 true 则返回 false，否则返回 true。\n[ ! false ] 返回 true。\n\n\n-o\n或运算，有一个表达式为 true 则返回 true。\n[ $a -lt 20 -o $b -gt 100 ] 返回 true。\n\n\n-a\n与运算，两个表达式都为 true 才返回 true。\n[ $a -lt 20 -a $b -gt 100 ] 返回 false。\n\n\n实例布尔运算符实例如下：\n#!/bin/basha=10b=20if [ $a != $b ]then  echo \"$a != $b : a 不等于 b\"else  echo \"$a == $b: a 等于 b\"fiif [ $a -lt 100 -a $b -gt 15 ]then  echo \"$a 小于 100 且 $b 大于 15 : 返回 true\"else  echo \"$a 小于 100 且 $b 大于 15 : 返回 false\"fiif [ $a -lt 100 -o $b -gt 100 ]then  echo \"$a 小于 100 或 $b 大于 100 : 返回 true\"else  echo \"$a 小于 100 或 $b 大于 100 : 返回 false\"fiif [ $a -lt 5 -o $b -gt 100 ]then  echo \"$a 小于 5 或 $b 大于 100 : 返回 true\"else  echo \"$a 小于 5 或 $b 大于 100 : 返回 false\"fi\n\n\n\n执行脚本，输出结果如下所示：\n10 != 20 : a 不等于 b10 小于 100 且 20 大于 15 : 返回 true10 小于 100 或 20 大于 100 : 返回 true10 小于 5 或 20 大于 100 : 返回 false\n\n\n逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:\n\n\n\n运算符\n说明\n举例\n\n\n\n&amp;&amp;\n逻辑的 AND\n[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false\n\n\n||\n逻辑的 OR\n[[ $a -lt 100 || $b -gt 100 ]] 返回 true\n\n\n实例逻辑运算符实例如下：\n#!/bin/basha=10b=20if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]then  echo \"返回 true\"else  echo \"返回 false\"fiif [[ $a -lt 100 || $b -gt 100 ]]then  echo \"返回 true\"else  echo \"返回 false\"fi\n\n\n\n执行脚本，输出结果如下所示：\n返回 false返回 true\n\n\n字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：\n\n\n\n运算符\n说明\n举例\n\n\n\n=\n检测两个字符串是否相等，相等返回 true。\n[ $a = $b ] 返回 false。\n\n\n!=\n检测两个字符串是否不相等，不相等返回 true。\n[ $a != $b ] 返回 true。\n\n\n-z\n检测字符串长度是否为0，为0返回 true。\n[ -z $a ] 返回 false。\n\n\n-n\n检测字符串长度是否不为 0，不为 0 返回 true。\n[ -n “$a” ] 返回 true。\n\n\n$\n检测字符串是否不为空，不为空返回 true。\n[ $a ] 返回 true。\n\n\n实例字符串运算符实例如下：\n#!/bin/basha=\"abc\"b=\"efg\"if [ $a = $b ]then  echo \"$a = $b : a 等于 b\"else  echo \"$a = $b: a 不等于 b\"fiif [ $a != $b ]then  echo \"$a != $b : a 不等于 b\"else  echo \"$a != $b: a 等于 b\"fiif [ -z $a ]then  echo \"-z $a : 字符串长度为 0\"else  echo \"-z $a : 字符串长度不为 0\"fiif [ -n \"$a\" ]then  echo \"-n $a : 字符串长度不为 0\"else  echo \"-n $a : 字符串长度为 0\"fiif [ $a ]then  echo \"$a : 字符串不为空\"else  echo \"$a : 字符串为空\"fi\n\n\n\n\n\n执行脚本，输出结果如下所示：\nabc = efg: a 不等于 babc != efg : a 不等于 b-z abc : 字符串长度不为 0-n abc : 字符串长度不为 0abc : 字符串不为空\n\n\n文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。\n属性检测描述如下：\n\n\n\n操作符\n说明\n举例\n\n\n\n-b file\n检测文件是否是块设备文件，如果是，则返回 true。\n[ -b $file ] 返回 false。\n\n\n-c file\n检测文件是否是字符设备文件，如果是，则返回 true。\n[ -c $file ] 返回 false。\n\n\n-d file\n检测文件是否是目录，如果是，则返回 true。\n[ -d $file ] 返回 false。\n\n\n-f file\n检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。\n[ -f $file ] 返回 true。\n\n\n-g file\n检测文件是否设置了 SGID 位，如果是，则返回 true。\n[ -g $file ] 返回 false。\n\n\n-k file\n检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。\n[ -k $file ] 返回 false。\n\n\n-p file\n检测文件是否是有名管道，如果是，则返回 true。\n[ -p $file ] 返回 false。\n\n\n-u file\n检测文件是否设置了 SUID 位，如果是，则返回 true。\n[ -u $file ] 返回 false。\n\n\n-r file\n检测文件是否可读，如果是，则返回 true。\n[ -r $file ] 返回 true。\n\n\n-w file\n检测文件是否可写，如果是，则返回 true。\n[ -w $file ] 返回 true。\n\n\n-x file\n检测文件是否可执行，如果是，则返回 true。\n[ -x $file ] 返回 true。\n\n\n-s file\n检测文件是否为空（文件大小是否大于0），不为空返回 true。\n[ -s $file ] 返回 true。\n\n\n-e file\n检测文件（包括目录）是否存在，如果是，则返回 true。\n[ -e $file ] 返回 true。\n\n\n其他检查符：\n\n-S: 判断某文件是否 socket。\n-L: 检测文件是否存在并且是一个符号链接。\n\n实例变量 file 表示文件 /var/www/runoob/test.sh，它的大小为 100 字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：\n#!/bin/bashfile=\"/var/www/runoob/test.sh\"if [ -r $file ]then  echo \"文件可读\"else  echo \"文件不可读\"fiif [ -w $file ]then  echo \"文件可写\"else  echo \"文件不可写\"fiif [ -x $file ]then  echo \"文件可执行\"else  echo \"文件不可执行\"fiif [ -f $file ]then  echo \"文件为普通文件\"else  echo \"文件为特殊文件\"fiif [ -d $file ]then  echo \"文件是个目录\"else  echo \"文件不是个目录\"fiif [ -s $file ]then  echo \"文件不为空\"else  echo \"文件为空\"fiif [ -e $file ]then  echo \"文件存在\"else  echo \"文件不存在\"fi\n\n\n\n执行脚本，输出结果如下所示：\n文件可读文件可写文件可执行文件为普通文件文件不是个目录文件不为空文件存在\n\n自增和自减操作符尽管 Shell 本身没有像 C、C++ 或 Java 那样的 ++ 和 – 操作符，但可以通过其他方式实现相同的功能。以下是一些常见的方法：\n使用 let 命令let 命令允许对整数进行算术运算。\n#!/bin/bash# 初始化变量num=5# 自增let num++# 自减let num--echo $num\n\n\n\n使用 $(( )) 进行算术运算$(( )) 语法也是进行算术运算的一种方式。\n实例#!/bin/bash# 初始化变量num=5# 自增num=$((num + 1))# 自减num=$((num - 1))echo $num\n\n使用 expr 命令expr 命令可以用于算术运算，但在现代脚本中不如 let 和 $(( )) 常用。\n实例#!/bin/bash# 初始化变量num=5# 自增num=$(expr $num + 1)# 自减num=$(expr $num - 1)echo $num\n\n\n\n使用 (( )) 进行算术运算与 $(( )) 类似，(( )) 语法也可以用于算术运算。\n实例#!/bin/bash# 初始化变量num=5# 自增((num++))# 自减((num--))echo $num\n\n\n\n实例以下是一个完整的示例脚本，演示了自增和自减操作的使用：\n#!/bin/bash# 初始化变量num=5echo \"初始值: $num\"# 自增let num++echo \"自增后: $num\"# 自减let num--echo \"自减后: $num\"# 使用 $(( ))num=$((num + 1))echo \"使用 $(( )) 自增后: $num\"num=$((num - 1))echo \"使用 $(( )) 自减后: $num\"# 使用 exprnum=$(expr $num + 1)echo \"使用 expr 自增后: $num\"num=$(expr $num - 1)echo \"使用 expr 自减后: $num\"# 使用 (( ))((num++))echo \"使用 (( )) 自增后: $num\"((num--))echo \"使用 (( )) 自减后: $num\"\n\n\n\n运行这个脚本会输出以下内容：\n初始值: 5自增后: 6自减后: 5使用 $(( )) 自增后: 6使用 $(( )) 自减后: 5使用 expr 自增后: 6使用 expr 自减后: 5使用 (( )) 自增后: 6使用 (( )) 自减后: 5\n\n\n\nShell 函数\nlinux shell 可以用户定义函数，然后在shell脚本中可以随便调用。\nshell中函数的定义格式如下：\n[ function ] funname [()]{  action;  [return int;]}\n\n\n\n说明：\n\n1、可以带 function fun() 定义，也可以直接 fun() 定义,不带任何参数。\n2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return 后跟数值 n(0-255).\n\n下面的例子定义了一个函数并进行调用：\n实例#!/bin/bashdemoFun(){  echo \"这是我的第一个 shell 函数!\"}echo \"-----函数开始执行-----\"demoFunecho \"-----函数执行完毕-----\"\n\n\n\n输出结果：\n-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕-----\n\n下面定义一个带有 return 语句的函数：\n实例#!/bin/bashfunWithReturn(){  echo \"这个函数会对输入的两个数字进行相加运算...\"  echo \"输入第一个数字: \"  read aNum  echo \"输入第二个数字: \"  read anotherNum  echo \"两个数字分别为 $aNum 和 $anotherNum !\"  return $(($aNum+$anotherNum))}funWithReturnecho \"输入的两个数字之和为 $? !\"\n\n\n\n输出类似下面：\n这个函数会对输入的两个数字进行相加运算...输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 !\n\n函数返回值在调用该函数后通过 $? 来获得。\n注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。\n注意： return 语句只能返回一个介于 0 到 255 之间的整数，而两个输入数字的和可能超过这个范围。\n要解决这个问题，您可以修改 return 语句，直接使用 echo 输出和而不是使用 return：\n实例funWithReturn(){  echo \"这个函数会对输入的两个数字进行相加运算...\"  echo \"输入第一个数字: \"  read aNum  echo \"输入第二个数字: \"  read anotherNum  sum=$(($aNum + $anotherNum))  echo \"两个数字分别为 $aNum 和 $anotherNum !\"  echo $sum # 输出两个数字的和}\n\n\n\n函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…\n带参数的函数示例：\n实例#!/bin/bashfunWithParam(){  echo \"第一个参数为 $1 !\"  echo \"第二个参数为 $2 !\"  echo \"第十个参数为 $10 !\"  echo \"第十个参数为 ${10} !\"  echo \"第十一个参数为 ${11} !\"  echo \"参数总数有 $# 个!\"  echo \"作为一个字符串输出所有参数 $* !\"}funWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n\n\n输出结果：\n第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。\n另外，还有几个特殊字符用来处理参数：\n\n\n\n参数处理\n说明\n\n\n\n$#\n传递到脚本或函数的参数个数\n\n\n$*\n以一个单字符串显示所有向脚本传递的参数\n\n\n$$\n脚本运行的当前进程ID号\n\n\n$!\n后台运行的最后一个进程的ID号\n\n\n$@\n与$*相同，但是使用时加引号，并在引号中返回每个参数。\n\n\n$-\n显示Shell使用的当前选项，与set命令功能相同。\n\n\n$?\n显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n\n","categories":["Linux"],"tags":["Linux,shell"]},{"title":"archLinux i3桌面快捷方式大全","url":"/2024/06/23/learnnote/linux-xue-xi/archlinux-i3-zhuo-mian-kuai-jie-fang-shi-da-quan/","content":"\n\n\n按键绑定\n描述\n\n\n\nMod + Enter\n打开终端。\n\n\nMod + ←\n切换到左侧窗口。\n\n\nMod + →\n切换到右侧窗口。\n\n\nMod + ↑\n切换到上方窗口。\n\n\nMod + ↓\n切换到下方窗口。\n\n\nMod + Shift + ←\n将窗口移动到左侧。\n\n\nMod + Shift + →\n将窗口移动到右侧。\n\n\nMod + Shift + ↑\n将窗口移动到上方。\n\n\nMod + Shift + ↓\n将窗口移动到下方。\n\n\nMod + f\n将焦点窗口切换到全屏模式。\n\n\nMod + v\n下一个窗口将垂直放置。\n\n\nMod + h\n下一个窗口将水平放置。\n\n\nMod + s\n启用堆叠式窗口布局。\n\n\nMod + w\n启用选项卡式窗口布局。\n\n\nMod + Shift + Space\n启用浮动窗口（针对焦点窗口）。\n\n\nMod + 鼠标左键单击\n使用鼠标拖动整个窗口。\n\n\nMod + 0-9\n切换到另一个工作区。\n\n\nMod + Shift + 0-9\n将窗口移动到另一个工作区。\n\n\nMod + d\n打开应用程序启动器（D 菜单）。\n\n\nMod + Shift + q\n关闭焦点窗口。\n\n\nMod + Shift + c\n重新加载 i3 配置文件。\n\n\nMod + Shift + r\n重启 i3 窗口管理器。\n\n\nMod + Shift + e\n退出 i3 窗口管理器。\n\n\n","categories":["Linux"],"tags":["i3桌面"]},{"title":"MarkDown数学符号收集表","url":"/2023/09/18/learnnote/markdown/markdown-shu-xue-fu-hao-biao/","content":"MarkDown数学符号收集表\n希腊字母表\n\n\n符号\n代码\n符号\n代码\n\n\n\n$\\alpha$\n\\alpha\nA\n\\Alpha\n\n\nβ\n\\beta\nB\n\\Beta\n\n\n$\\gamma$\n\\gamma\nΓ\n\\Gamma\n\n\n$\\delta$\n\\delta\n$\\Delta$\n\\Delta\n\n\n$\\epsilon$\n\\epsilon\n$\\Epsilon$\n\\Epsilon\n\n\n$\\zeta$\n\\zeta\n$\\Zeta$\n\\Zeta\n\n\n$\\eta$\n\\eta\n$\\Eta$\n\\Eta\n\n\n$\\theta$\n\\theta\n$\\Theta$\n\\Theta\n\n\n$\\iota$\n\\iota\n$\\Iota$\n\\Iota\n\n\n$\\sigma$\n\\sigma\n$\\Sigma$\n\\Sigma\n\n\n$\\mu$\n\\mu\n$\\Mu$\n\\Mu\n\n\n$\\lambda$\n\\lambda\n$\\Lambda$\n\\Lambda\n\n\n$\\omega$\n\\omega\n$\\Omega$\n\\Omega\n\n\n$\\nu$\n\\nu\n$\\Nu$\n\\Nu\n\n\n$\\pi$\n\\pi\n$\\Pi$\n\\Pi\n\n\n$\\tau$\n\\tau\n\n\n\n\n$\\zeta$\n\\zeta\n\n\n\n\n$\\kappa$\n\\kappa\n\n\n\n\n$\\psi$\n$\\psi\n\n\n\n\n$\\rho$\n$\\rho\n\n\n\n\n$\\varrho$\n\\varrho\n\n\n\n\n$\\xi$\n\\xi\n\n\n\n\n$\\partial$\n\\partial\n\n\n\n\n$\\phi$\n\\phi\n$\\Phi$\n\\Phi\n\n\n数字符号表\n\n\n描述\n符号\n代码\n\n\n\n求和公式\n$\\sum$\n\\sum\n\n\n求和上下标\n$\\sum_{i=0}^n$\n\\sum_{i=0}^n\n\n\n叉乘/点乘 × \\times\n$\\times \\cdot$\n\\times \\cdot\n\n\n正负号\n$\\pm$\n\\pm\n\n\n除号\n$\\div$\n\\div\n\n\n竖线\n$\\mid$\n\\mid\n\n\n点\n$\\cdot$\n\\cdot\n\n\n圈\n$\\circ$\n\\circ\n\n\n星号\n$\\ast$\n\\ast\n\n\n克罗内克积\n$\\bigotimes$\n\\bigotimes\n\n\n异或\n$\\bigoplus$\n\\bigoplus\n\n\n同或运算\n$\\bigodot$\n\\bigodot\n\n\n向量符号\n$\\vec{字母}$\n\\vec{字母}\n\n\n小于等于\n$\\leq$\n\\leq\n\n\n大于等于\n$\\geq$\n\\geq\n\n\n不等于\n$\\neq$\n\\neq\n\n\n等价于\n$\\sim$\n\\sim\n\n\n约等于\n$\\approx$\n\\approx\n\n\nN元乘积 ∏ \\prod\n$\\prod$\n\\prod\n\n\nN元余积\n$\\coprod$\n\\coprod\n\n\n省略号\n$\\cdots$\n\\cdots\n\n\n积分\n$\\int$\n\\int\n\n\n双重积分\n$\\iint$\n\\iint\n\n\n曲线积分\n$\\oint$\n\\oint\n\n\n无穷\n$\\infty$\n\\infty\n\n\n右箭头\n$$\\rarr$$\n\\rarr\n\n\n右胖箭头\n$\\Rarr$\n\\Rarr\n\n\n左箭头\n$$\\larr$$\n\\larr\n\n\n左胖箭头\n$\\Larr$\n\\Larr\n\n\n上箭头\n$\\uarr$\n\\uarr\n\n\n上胖箭头\n$\\Uarr$\n\\Uarr\n\n\n下箭头\n$\\darr$\n\\darr\n\n\n下胖箭头\n$\\Darr$\n\\Darr\n\n\n上下双向箭头\n$\\updownarrow$\n\\updownarrow\n\n\n上下双向胖箭头\n$\\Updownarrow$\n\\Updownarrow\n\n\n左右双向箭头\n$\\lrarr$\n\\lrarr\n\n\n左右双向胖箭头\n$\\Lrarr$\n\\Lrarr\n\n\n任意一个\n$\\forall$\n\\forall\n\n\n任选一个\n$\\exists$\n\\exists\n\n\n极限lim\n$\\lim\\limits_{x\\to0}\\frac{a}{b}$\n\\lim\\limits_{x\\to0}\\frac{a}{b}$\n\n\n用于极限到某一值的箭头\n$ \\lim\\limits_{x\\to0}$\n\\to\n\n\n极限$\\lim_{x \\to 0}$\n$\\lim_{x\\to 0}$\n\\lim_{x\\to 0}\n\n\n根号$\\sqrt{2}$\n$\\sqrt{2}$\n\\sqrt{2}\n\n\n指定方根号$\\sqrt[4]{2}$\n$\\sqrt[4]{2}$\n\\sqrt[4]{2}\n\n\n属于\n$\\in$\n\\in\n\n\n不属于\n$\\notin$\n\\notin\n\n\n子集\n$\\subset$\n\\subset\n\n\n实数集\n$\\mathbb R$\n\\mathbb R\n\n\n复数集\n$\\mathbb C$\n\\mathbb C\n\n\n整数集\n$\\mathbb Z$\n\\mathbb Z\n\n\n自然数集\n$\\mathbb N$\n\\mathbb N\n\n\n空集\n$\\emptyset$\n\\emptyset\n\n\n包含于\n$\\subseteq$\n\\subseteq\n\n\n包含\n$\\supseteq$\n\\supseteq\n\n\n包含于\n$\\subset$\n\\subset\n\n\n包含\n$\\supset$\n\\supset\n\n\n真包含于\n$\\subsetneq$\n\\subsetneq\n\n\n真包含\n$\\supsetneq$\n\\supsetneq\n\n\n数学符号补充表\n\n\n$描述$\n符号\n$代码$\n\n\n\n行内公式\n$$\n$$\n\n\n独行公式\n\n\n\n\n上标\n$y=x^2$\n^\n\n\n下标\n$O_4$\n_\n\n\n上下标组合\n$\\frac{a}{b}$\n$\\frac{a}{b}\n\n\n字体控制\n$\\displaystyle \\frac{a}{b}$\n\\displaystyle\n\n\n不加此内容公式会缩至与文字同高。加此内容，公式会以原大小显示。\n\n\n\n\n占位符\n$\\quad$\n\\quad\n\n\n大空格\n\n\n\n\n中空格\n\n\n\n\n小空格\n\n\n\n\n贴紧\n$!$\n!\n\n\n括号\n$\\big(算式)$\n\\big(算式)\n\n\n中括号\n\n\n\n\n大括号\n\n\n\n\n自适应括号\n\n\n\n\n矩阵\n\n\n\n\n上箭头\n\n\n\n\n矩阵\n$\\begin{matrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{matrix}$\n\\begin{matrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{matrix}\n\n\n矩阵小括号\n$\\begin{pmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{pmatrix}$\n\\begin{pmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{pmatrix}\n\n\n矩阵中括号\n$\\begin{bmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{bmatrix}$\n\\begin{bmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{bmatrix}\n\n\n矩阵大括号\n$\\begin{Bmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{Bmatrix}$\n\\begin{Bmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{Bmatrix}\n\n\n矩阵单竖线\n$\\begin{vmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{vmatrix}$\n\\begin{vmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{vmatrix}\n\n\n矩阵双竖线\n$\\begin{Vmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{Vmatrix}$\n\\begin{Vmatrix}0&amp;1&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;1\\end{Vmatrix}\n\n\n","categories":["MarkDown"],"tags":["数学","MarkDown"]},{"title":"Nginx学习","url":"/2024/03/02/learnnote/nignx/nignx-xue-xi/","content":"Nginx学习\n常用指令：\n停止\nsystemctl stop nginx\n重启\nsystemctl restart nginx\n关于nginx总是403问题：说明：\n\n如果使用的是Centos那么并且防火墙啥的都关了可能存在SELinux的问题，只需要把SELinux关了就行\ncentos关闭SELinux指令：\nsed -i s#SELINUX=enforcing#SELINUX=disabled# /etc/selinux/config\n\n\n","categories":["Nginx"],"tags":["Nginx"]},{"title":"MySQL同时安装多个版本","url":"/2025/04/19/learnnote/sql-xue-xi/mysql-tong-shi-an-zhuang-duo-ge-ban-ben/","content":"MySQL同时安装多个版本Windows系统安装一、下载对应MySQL5版本的压缩包MySQL不同版本下载页：https://downloads.mysql.com/archives/community/，进去下载不同版本zip包即可。\n比如选择下载MySQL 5.7.40版本：\n\n下载好之后解压到自己想要的目录。\n二、安装MySQL51、定制配置文件在数据库对应根目录文件创建my.ini\n\nmy.ini文件内容\n[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3305端口,多个数据库并存的时候记得端口别TM一样的port = 3305# 设置mysql的安装目录basedir=D:\\\\mysql-5.7.37-winx64# 设置mysql数据库的数据的存放目录（自动生成，不然可能报错）datadir=D:\\\\mysql-5.7.37-winx64\\\\data# 允许最大连接数max_connections=10000# 允许最大连接人数max_user_connections=1000# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB # 连接时间一年wait_timeout=31536000interactive_timeout=31536000\n\n\n\n之后利用管理员权限的CMDcd到指定目录，注意，如果cd没有反应则需要再打一遍盘符，比如我想cd到D:\\mysql-5.7.37-winx64\\bin，如果没有反应，则再输入一次d:就行。\n2、初始化数据库mysqld --initialize\n\n3、安装MySQL服务注意这里的MYSQL5主要的作用就是给安装的服务进行自定义名称，因为不加MYSQL5的话MySQL默认安装的服务名称为MYSQL，这里自定义名称的作用就是为了防止其他MYSQL服务名称相撞。\nmysqld --install MYSQL5\n\n4、启动MySQL服务net start MYSQL5\n\n5、连接数据库输入指令之后会让你输入数据库密码，而初始数据库初次创建可能会自动生成一个数据库密码，密码可以在data中的err结尾后缀文件里面查看。\nmysql -P 3305 -u root -p\n\n\n三、下载对应MySQL8版本的压缩包MySQL不同版本下载页：https://downloads.mysql.com/archives/community/，进去下载不同版本zip包即可。\n比如选择下载MySQL 8.3.0版本：\n\n下载好之后解压到自己想要的目录。\n二、安装MySQL81、定制配置文件在数据库对应根目录文件创建my.ini\n\nmy.ini文件内容\n[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口,多个数据库并存的时候记得端口别TM一样的port = 3306# 设置mysql的安装目录basedir=D:\\\\mysql-8.3.0-winx64# 设置mysql数据库的数据的存放目录（自动生成，不然可能报错）datadir=D:\\\\mysql-8.3.0-winx64\\\\data# 允许最大连接数max_connections=10000# 允许最大连接人数max_user_connections=1000# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB # 连接时间一年wait_timeout=31536000interactive_timeout=31536000\n\n\n\n之后利用管理员权限的CMDcd到指定目录，注意，如果cd没有反应则需要再打一遍盘符，比如我想cd到D:\\mysql-8.3.0-winx64\\bin，如果没有反应，则再输入一次d:就行。\n2、初始化数据库mysqld --initialize\n\n3、安装MySQL服务注意这里的MYSQL8主要的作用就是给安装的服务进行自定义名称，因为不加MYSQL8的话MySQL默认安装的服务名称为MYSQL，这里自定义名称的作用就是为了防止其他MYSQL服务名称相撞。\nmysqld --install MYSQL8\n\n4、启动MySQL服务net start MYSQL8\n\n5、连接数据库输入指令之后会让你输入数据库密码，而初始数据库初次创建可能会自动生成一个数据库密码，密码可以在data中的err结尾后缀文件里面查看。\nmysql -P 3306 -u root -p\n\n\n","categories":["数据库","MySQL"],"tags":["MySQL"]},{"title":"Mysql中SQL的执行顺序","url":"/2025/03/02/learnnote/sql-xue-xi/mysql-zhong-sql-de-zhi-xing-shun-xu/","content":"Mysql中SQL的执行顺序\nMySQL语句的执行顺序与日常书写顺序不同，其核心逻辑是从数据源逐步过滤、聚合到最终输出，整个过程会生成多个中间虚拟表。一下是关键执行步骤及说明：\n一、SELECT语句的执行顺序1.FROM &amp; JOIN\n首先确定数据库来源，处理多表连接如（LEFT JOIN、INNER JOIN）。若涉及多个表，会按顺序生成笛卡尔积并逐步过滤。\n示例：FROM a JOIN b ON a.id=b.a_id会先连接a和b表。\n2.ON\n应用连接条件，筛选出符合逻辑的行，生成中间表（如VT2）。\n注意：ON条件用于连接操作，而WHERE用于最终过滤操。\n3.WHERE\n对于连接后的结果进行条件过滤（如WHERE age &gt;18）,生成VT4。\n关键点：WHERE过滤的是原始数据，而非分组后的数据。\n4.GROUP BY\n按指定列分组（如GROUP BY department），生成VT5。分组后每组仅保留一行。\n注意：非聚合列必须包含在GROUP BY中。\n5.HAVING\n对分组后的结果进行过滤（如HAVING avg_salary &gt; 5000），生成VT7。\n与WHERE的区别：HAVING作用于聚合后的数据。\n6.SELECT\n选择最终输出的列（如SELECT name,SUM(salary))，生成VT8。\n7.ORDER BY\n对结果排序（如ORDER BY total DESC），生成VT10。排序操作消耗资源较多，建议谨慎使用。\n8.LIMIT\n限制返回行数（如LIMIT 10），生成最终结果集并返回给客户端。\n二、更新语句的执行顺序更新（UPDATA）和删除（DELETE）语句的执行流程类似：\n1.连接器：验证用户权限。\n2.分析器：解析SQL语法和语义。\n\n优化器：生成执行计划（如选择索引）。\n执行器：调用存储引擎接口，执行具体操作并返回结果。\n\n三、关键细节与优化建议\n中间表与性能\n\n每个步骤生成虚拟表，数据量逐步减少。建议通过WHERE提前过滤数据，减少后续处理量。\n示例：WHERE age &gt; 18比HAVING age &gt; 18更高效。\n\n索引与查询优化\n\n· WHERE和JOIN条件列需建立索引。\n· 避免在SELECT中进行复杂计算，可延迟到应用层处理。\n\n别名与作用域\n\nSELECT中定义的别名（如total）仅能在ORDER BY中使用，不可在WHERE或GROUP BY中引用。\n四、总结MySQL通过分步处理+中间表实现查询，理解执行顺序有助于编写高效SQL。例如：\n· 优先使用WHERE而非HAVING过滤数据。\n· 合理设计索引，减少全表扫描。\n· 避免SELECT *，仅查询必要字段。\n通过掌握这些规则，可显著提升查询性能并规避常见错误。\n\n\n\n执行顺序\n书写顺序\n说明\n\n\n\n8\nSELECT\n\n\n\n9\nDISTINCT\n&lt;查询字段&gt;\n\n\n1\nFROM\n&lt;查询的（左）表名称&gt;\n\n\n3\n[LEFT | RIGHT | INNER] JOIN\n&lt;连接查询右边表&gt;\n\n\n2\nON\n&lt;表连接的连接条件&gt;\n\n\n4\nWHERE\n&lt;数据查询条件&gt;\n\n\n5\nGROUP BY\n&lt;字段分组信息&gt;\n\n\n6\nWITH CUBE | ROLLUP\n&lt;超组统计&gt;\n\n\n7\nHAVING\n&lt;处理后的筛选条件&gt;\n\n\n10\nORDER BY [ASC | DESC]\n&lt;排序字段&gt;\n\n\n11\nLIMIT\n&lt;查询数据长度&gt;\n\n\n说明：从这个顺序中我们不难发现，所有的查询语句都是从FROM子句开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。\n","categories":["数据库","SQL"],"tags":["SQL"]},{"title":"常用SQL大全","url":"/2023/03/22/learnnote/sql-xue-xi/sql-da-quan/","content":"常用SQL大全\n#显示查询数据库文件存储所在磁盘位置show variables like '%datadir%';\n\n#日志文件路径show variables like 'general_log_file';#错误日志文件路径show variables like 'log_error';#慢查询日志文件路径show variables like 'slow_query_log_file';\n\n\n\n修改数据库密码：\nset password for 'root'@'%' = password('123456');\n\nALTER USER 'root'@'localhost' IDENTIFIED BY '123456';\n\n\n这里指的是更新用户名称为root其访问范围为%的账号密码为123456，注意%代表的是无任何访问限制的账户也就是说可以从公网访问，如果%替换为localhost，那么意思就是只能数据库所在机子才能访问。\n\n删除数据库：\nDROP USER 'root'@'localhost';\n\n\n这里演示的是删除root账户\n\n刷新权限：\nflush privileges;\n\n","categories":["数据库","SQL"],"tags":["SQL"]},{"title":"Ajax学习","url":"/2023/02/24/learnnote/web-qian-duan/ajax-xue-xi/","content":"AJAX特点\n优点\n\n可以无需刷新页面而与服务器端进行通信。\n允许你根据用户事件来更新部分页面内容。\n\n缺点\n\n没有浏览历史，不能回退\n存在跨域问题（同源）\nSEO不友好（对搜索引擎不友好）\n\n安装nodemon插件指令：\n\nnpm install -g nodemon\n以后就可以用：nodemon *.js \n来运行Nodejs了\n\n","categories":["前端"],"tags":["JS"]},{"title":"Axios学习","url":"/2023/02/24/learnnote/web-qian-duan/axios-xue-xi/","content":"Axios学习\n什么是Axios？\nAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\nAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n特性\n\n从浏览器中创建 XMLHttpRequests\n从 node.js 创建 http 请求\n支持 Promise API\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换 JSON 数据\n客户端支持防御 XSRF\n\n浏览器支持\n\n\n\n\n\n\n\n\n\n\n\n\n\nLatest ✔\nLatest ✔\nLatest ✔\nLatest ✔\nLatest ✔\n8+ ✔\n\n\n\n\n安装\n使用 npm:\n$ npm install axios\n\n使用 bower:\n$ bower install axios\n\n使用 cdn:\n&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;\n\n案例\n执行 GET 请求\n// 为给定 ID 的 user 创建请求axios.get('/user?ID=12345')  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });// 上面的请求也可以这样做axios.get('/user', {    params: {      ID: 12345    }  })  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });\n\n执行 POST 请求\naxios.post('/user', {    firstName: 'Fred',    lastName: 'Flintstone'  })  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });\n\n执行多个并发请求\nfunction getUserAccount() {  return axios.get('/user/12345');}function getUserPermissions() {  return axios.get('/user/12345/permissions');}axios.all([getUserAccount(), getUserPermissions()])  .then(axios.spread(function (acct, perms) {    // 两个请求现在都执行完成  }));\n\naxios API\n可以通过向 axios 传递相关配置来创建请求\naxios(config)// 发送 POST 请求axios({  method: 'post',  url: '/user/12345',  data: {    firstName: 'Fred',    lastName: 'Flintstone'  }});// 获取远端图片axios({  method:'get',  url:'http://bit.ly/2mTM3nY',  responseType:'stream'})  .then(function(response) {  response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))});\n\naxios(url[, config])// 发送 GET 请求（默认的方法）axios('/user/12345');\n\n请求方法的别名为方便起见，为所有支持的请求方法提供了别名\naxios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.options(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])注意在使用别名方法时， url、method、data 这些属性都不必在配置中指定。\n并发处理并发请求的助手函数\naxios.all(iterable)axios.spread(callback)创建实例可以使用自定义配置新建一个 axios 实例\naxios.create([config])const instance = axios.create({  baseURL: 'https://some-domain.com/api/',  timeout: 1000,  headers: {'X-Custom-Header': 'foobar'}});\n\n实例方法以下是可用的实例方法。指定的配置将与实例的配置合并。\naxios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#options(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])请求配置\n这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。\n{   // `url` 是用于请求的服务器 URL  url: '/user',  // `method` 是创建请求时使用的方法  method: 'get', // default  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL  baseURL: 'https://some-domain.com/api/',  // `transformRequest` 允许在向服务器发送前，修改请求数据  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream  transformRequest: [function (data, headers) {    // 对 data 进行任意转换处理    return data;  }],  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据  transformResponse: [function (data) {    // 对 data 进行任意转换处理    return data;  }],  // `headers` 是即将被发送的自定义请求头  headers: {'X-Requested-With': 'XMLHttpRequest'},  // `params` 是即将与请求一起发送的 URL 参数  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象  params: {    ID: 12345  },   // `paramsSerializer` 是一个负责 `params` 序列化的函数  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)  paramsSerializer: function(params) {    return Qs.stringify(params, {arrayFormat: 'brackets'})  },  // `data` 是作为请求主体被发送的数据  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'  // 在没有设置 `transformRequest` 时，必须是以下类型之一：  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams  // - 浏览器专属：FormData, File, Blob  // - Node 专属： Stream  data: {    firstName: 'Fred'  },  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)  // 如果请求话费了超过 `timeout` 的时间，请求将被中断  timeout: 1000,   // `withCredentials` 表示跨域请求时是否需要使用凭证  withCredentials: false, // default  // `adapter` 允许自定义处理请求，以使测试更轻松  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).  adapter: function (config) {    /* ... */  }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头  auth: {    username: 'janedoe',    password: 's00pers3cret'  },   // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'  responseType: 'json', // default  // `responseEncoding` indicates encoding to use for decoding responses  // Note: Ignored for `responseType` of 'stream' or client-side requests  responseEncoding: 'utf8', // default   // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称  xsrfCookieName: 'XSRF-TOKEN', // default  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value  xsrfHeaderName: 'X-XSRF-TOKEN', // default   // `onUploadProgress` 允许为上传处理进度事件  onUploadProgress: function (progressEvent) {    // Do whatever you want with the native progress event  },  // `onDownloadProgress` 允许为下载处理进度事件  onDownloadProgress: function (progressEvent) {    // 对原生进度事件的处理  },   // `maxContentLength` 定义允许的响应内容的最大尺寸  maxContentLength: 2000,  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte  validateStatus: function (status) {    return status &gt;= 200 &amp;&amp; status &lt; 300; // default  },  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目  // 如果设置为0，将不会 follow 任何重定向  maxRedirects: 5, // default  // `socketPath` defines a UNIX Socket to be used in node.js.  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.  // Only either `socketPath` or `proxy` can be specified.  // If both are specified, `socketPath` is used.  socketPath: null, // default  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：  // `keepAlive` 默认没有启用  httpAgent: new http.Agent({ keepAlive: true }),  httpsAgent: new https.Agent({ keepAlive: true }),  // 'proxy' 定义代理服务器的主机名称和端口  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。  proxy: {    host: '127.0.0.1',    port: 9000,    auth: {      username: 'mikeymike',      password: 'rapunz3l'    }  },  // `cancelToken` 指定用于取消请求的 cancel token  // （查看后面的 Cancellation 这节了解更多）  cancelToken: new CancelToken(function (cancel) {  })}\n\n响应结构\n某个请求的响应包含以下信息\n{  // `data` 由服务器提供的响应  data: {},  // `status` 来自服务器响应的 HTTP 状态码  status: 200,  // `statusText` 来自服务器响应的 HTTP 状态信息  statusText: 'OK',  // `headers` 服务器响应的头  headers: {},   // `config` 是为请求提供的配置信息  config: {}, // 'request'  // `request` is the request that generated this response  // It is the last ClientRequest instance in node.js (in redirects)  // and an XMLHttpRequest instance the browser  request: {}}\n\n使用 then 时，你将接收下面这样的响应 :\naxios.get('/user/12345')  .then(function(response) {    console.log(response.data);    console.log(response.status);    console.log(response.statusText);    console.log(response.headers);    console.log(response.config);  });\n\n在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。\n配置默认值\n你可以指定将被用在各个请求的配置默认值\n全局的 axios 默认值axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\n自定义实例默认值// Set config defaults when creating the instanceconst instance = axios.create({  baseURL: 'https://api.example.com'});// Alter defaults after instance has been createdinstance.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n\n配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：\n// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', {  timeout: 5000});\n\n拦截器\n在请求或响应被 then 或 catch 处理前拦截它们。\n// 添加请求拦截器axios.interceptors.request.use(function (config) {    // 在发送请求之前做些什么    return config;  }, function (error) {    // 对请求错误做些什么    return Promise.reject(error);  });// 添加响应拦截器axios.interceptors.response.use(function (response) {    // 对响应数据做点什么    return response;  }, function (error) {    // 对响应错误做点什么    return Promise.reject(error);  });\n\n如果你想在稍后移除拦截器，可以这样：\nconst myInterceptor = axios.interceptors.request.use(function () {/*...*/});axios.interceptors.request.eject(myInterceptor);\n\n可以为自定义 axios 实例添加拦截器\nconst instance = axios.create();instance.interceptors.request.use(function () {/*...*/});\n\n错误处理\naxios.get('/user/12345')  .catch(function (error) {    if (error.response) {      // The request was made and the server responded with a status code      // that falls out of the range of 2xx      console.log(error.response.data);      console.log(error.response.status);      console.log(error.response.headers);    } else if (error.request) {      // The request was made but no response was received      // `error.request` is an instance of XMLHttpRequest in the browser and an instance of      // http.ClientRequest in node.js      console.log(error.request);    } else {      // Something happened in setting up the request that triggered an Error      console.log('Error', error.message);    }    console.log(error.config);  });\n\nY可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。\naxios.get('/user/12345', {  validateStatus: function (status) {    return status &lt; 500; // Reject only if the status code is greater than or equal to 500  }})\n\n取消\n使用 cancel token 取消请求\n\nAxios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。\n\n可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：\nconst CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get('/user/12345', {  cancelToken: source.token}).catch(function(thrown) {  if (axios.isCancel(thrown)) {    console.log('Request canceled', thrown.message);  } else {     // 处理错误  }});axios.post('/user/12345', {  name: 'new name'}, {  cancelToken: source.token})// 取消请求（message 参数是可选的）source.cancel('Operation canceled by the user.');\n\n还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：\nconst CancelToken = axios.CancelToken;let cancel;axios.get('/user/12345', {  cancelToken: new CancelToken(function executor(c) {    // executor 函数接收一个 cancel 函数作为参数    cancel = c;  })});// cancel the requestcancel();\n\n\n注意: 可以使用同一个 cancel token 取消多个请求\n\n使用 application/x-www-form-urlencoded format\n默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。\n浏览器在浏览器中，您可以使用URLSearchParams API，如下所示：\nconst params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params);\n\n\n请注意，所有浏览器都不支持URLSearchParams（请参阅caniuse.com），但可以使用polyfill（确保填充全局环境）。\n\n或者，您可以使用qs库编码数据：\nconst qs = require('qs');axios.post('/foo', qs.stringify({ 'bar': 123 }));\n\n或者以另一种方式（ES6），\nimport qs from 'qs';const data = { 'bar': 123 };const options = {  method: 'POST',  headers: { 'content-type': 'application/x-www-form-urlencoded' },  data: qs.stringify(data),  url,};axios(options);\n\nNode.js\n在node.js中，您可以使用querystring模块，如下所示：\nconst querystring = require('querystring');axios.post('http://something.com/', querystring.stringify({ foo: 'bar' }));\n\n您也可以使用qs库。\nSemver\n在axios达到1.0版本之前，破坏性更改将以新的次要版本发布。 例如0.5.1和0.5.4将具有相同的API，但0.6.0将具有重大变化。\nPromises\naxios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill.\nTypeScript\naxios包括TypeScript定义。\nimport axios from 'axios';axios.get('/user?ID=12345');\n\nvue-axios\n基于vuejs 的轻度封装\n\n安装:CommonJS:npm install --save axios vue-axios\n\n将下面代码加入入口文件:\nimport Vue from 'vue'import axios from 'axios'import VueAxios from 'vue-axios'Vue.use(VueAxios, axios)\n\n\n\nScript:按照这个顺序分别引入这三个文件： vue, axios and vue-axios\nUsage:This wrapper bind axios to Vue or this if you’re using single file component.\n你可以按照以下方式使用:\nVue.axios.get(api).then((response) =&gt; {  console.log(response.data)})this.axios.get(api).then((response) =&gt; {  console.log(response.data)})this.$http.get(api).then((response) =&gt; {  console.log(response.data)})","categories":["前端"],"tags":["JS","Axios"]},{"title":"Vue3学习","url":"/2023/12/28/learnnote/web-qian-duan/vue3-xue-xi/","content":"Vue3学习\n创建Vue3.0工程1.使用vue-cli创建## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinp m install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve\n\n\n\n2.使用vite创建## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev\n\n\n\n3.设置npm代理本地clashnpm config set proxy http://proxy.example.com:8080npm config set https-proxy http://proxy.example.com:8080\n\n\n\n\n\nsetup函数的两种返回值：\n\n1.若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。（重点关注！）\n2.若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n注意点：\n\n1、尽量不要与Vue2.x配置混用\n\nVue2.x配置（data、methos、computed…)中可以访问到setup中的属性、方法。\n但在setup中不能访问到Vue2.x配置（data、methos、computed…)。\n如果有重名，setup优先。\n\n2、setup不能是一个async函数，因为返回值不再是return的对象，而是promise，模板看不到return对象中的属性。\n\n2.ref函数\n作用：定义一个响应式的数据\n\n语法：==const xxx = ref(initValue)==\n\n创建一个包含响应式数据的引用对象（reference对象）。\n\nJS中操作数据：==xxx.value==\n\n模板中读取数据：不需要.value,直接&lt;div&gt;{{xxx}}&lt;/div&gt;\n\n备注：\n\n接受的数据可以是：基本类型、也可以是对象类型\n\n基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n\n对象类型的数据：内部“求助”了Vue3.0中的一个新函数——==reactive==函数。\n\n\n\n\n&lt;template&gt;&lt;h1&gt;一个人的信息&lt;/h1&gt;&lt;h2&gt;姓名：{{name}}&lt;/h2&gt;&lt;h2&gt;年龄：{{age}}&lt;/h2&gt;&lt;h3&gt;工作类型：{{job.type}}&lt;/h3&gt;&lt;h3&gt;工作薪水：{{job.salary}}&lt;/h3&gt;&lt;button @click=\"sayHello\"&gt;说话&lt;/button&gt;&lt;/template&gt;&lt;script&gt;    import {ref} from 'vue'    export default {        name: 'App',        //此处只是测试一个车setup，暂时不考虑响应式的问题。        setup(){            let name = ref('张三')            let age = ref(18)            let job = ref({                type: '前端',                salary: '30K'            })            function sayHello(){                name.value = '李四';                age.value= 20;                job.value.type='后端'                job.value.salary='40K'            }            //返回一个对象（常用）            return{                name,                age,                job,                sayHello            }        }    }&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n其中需要监听的数据用ref来包装一下，之后如果想要修改那么就使用xx.value去引用修改即可。注意不能直接进行xxx=这样直接修改，不然不会更新界面数据的。\n3.reactive函数\n作用：定义一个对象类型的响应式数据（基本类型别用它，用==ref==函数）\n语法：==const代理对象=reactive(被代理对象)==接收一个对象（或数组），返回一个代理对象（proxy对象）\nreactive定义的响应式数据是“深层次的”。\n内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据都是响应式的\n在使用的时候就不需要使用.value进行修改和引用了\n\n4.Vue3.0中的响应式原理\n实现原理：\n\n对象类型：通过Object.defineProperty()对属性的读取，修改进行拦截（数据劫持）。\n\n数据类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\nObject.defineProperty(data,'count',{    get(){},    set(){}})\n\n\n存在问题：\n\n新增属性、删除属性，界面不会更新。\n直接通过下标修改数组，界面不会更新。\n\n\n\nVue3.0的响应式\n\n实现原理：\n\n通过Proxy（代理）：拦截对象中任意属性的变化，包裹：属性值的读写、属性的添加、属性的删除等。\n\n通过Reflect（反射）：对被代理对象的属性进行操作。\n\nMDN文档中描述的Proxy与Reflect：\n\nProxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n\nReflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\nnew Proxy(data,{    get(target,prop){        return Reflect.get(target,prop)    },    //拦截设置属性值或添加新属性    set (target,prop.value){        return Reflect.set(target,prop,,value)    },    //拦截删除属性    deleteProperty(target,prop){        return Reflect.deleteProperty(target,prop)    }})proxy.name = 'tom'\n\n\n\n\n\n6.setup的两个注意点\nsetup执行的时机\n\n在beforeCreate之前执行一次，this是undefined。\n\n\nsetup的参数\n\nprops：值为对象，包含：组件外部传递过来，且组件内部申明接收了的属性。\ncontext：上下文对象\nattrs：值为对象，包含：组件外部传递过来，但没有在props配置中申明的属性，相当于this.$attrs。\nslots：收到的插槽内容，相当于this.$slots。\nemit：分发自定义事件的函数，相当于this.$emit。\n\n\n\n\n\n7.计算属性与监视1.computed函数\n与Vue2.x中computed配置功能一致\n\n写法\nimport {computed} from 'vue'setup(){    ...    //计算属性一简写    let fullName = computed(()=&gt;{        return person.firstName+'-'+person.lastName    })    //计算属性完整    let fullName = computed({        get(){            return person.firstName()+'-'+person.lastName        },        set(value){            const nameArr = value.split('-')            person.firstName = nameArr[0]            person.lastName = nameArr[1]        }    })    }\n\n在vue3中如果使用template插槽，尽量使用v-slot形式，比如v-slot:qwe\n2.watch函数\n与Vue2.x中watch配置功能一致\n\n两个小“坑”：\n\n监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。\n监视reactive定义响应式数据中某个属性时：deep配置有效。\n\n//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;{    console.log('sum变化了',newValue,oldValue)},{immediate: true})//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;{    console.log('sum或msg变化了',newValue,oldValue)})/* 情况三：监视reactive定义的响应式数据\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获取oldValue！！\t\t\t若watvh监视的是reactive定义的响应式数据，则强制开启了深度监视*/watch(person，(newValue,oldValue)=&gt;{    console.log('person变化了',newValue,oldValue)},{    immediate:true,deep:false})//此处的deep配置不再凑效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;{    console.log('person的job变化了',newValue,oldValue)},{immediate:true,deep:true})//情况五：监视\n\n","categories":["前端"],"tags":["Vue"]},{"title":"Vue2学习","url":"/2023/02/24/learnnote/web-qian-duan/vue-xue-xi/","content":"Vue\n创建Vue项目的命令：npm init vue@latest\n\n\n\n文件结构\nsrc:\n\n这个文件夹就是我们主要进行写代码的文件夹。\n\npage.json:\n\n这个文件包括了项目版本运行，以及依赖导入版本等，这个文件有点像maven的配置文件一样。\n\nvite.config.js:\n\n这个是Vue的配置文件，这里会进行一些额外的配置，比如跨域请求的设置，以及一些打包的配置等。\n\nVue使用一种基于HTML的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的DOM上。所有的Vue模板都是语法层面合法的HTML，可以被符合规范的浏览器和HTML解析器解析。\n文本插值：\n\n最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法（即双大括号）：\n\n\nv-text：&lt;div id=\"app\"&gt;    &lt;h2 v-text=\"message\"/&gt;    &lt;h2&gt;深圳{{message}}&lt;/h2&gt;&lt;/div&gt;&lt;script&gt;var app = new Vue({    el:\"#app\",    data:{        message:\"Test\",    }})        &lt;/script&gt;\n\n\n\nv-html：&lt;div id=\"app\"&gt;    &lt;p v-html=\"content\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;sctipt&gt;var app = new Vue({    el:\"#app\",    data:{    content:\"&lt;a href='#'&gt;Test&lt;/a&gt;\"    }    })&lt;/sctipt&gt;\n\n\n\nv-on：作用：为元素绑定事件\n&lt;div id=\"app\"&gt;    &lt;input type=\"button\" value=\"事件绑定\" v-on:事件名称=\"方法\"&gt;    点击事件：&lt;input type=\"button\" value=\"事件绑定\" v-on:click=\"方法\"&gt;    双击事件：&lt;input type=\"button\" value=\"事件绑定\" v-on:dblclick=\"方法\"&gt;    可以将v-on替换成@：&lt;input type=\"buttion\" value=\"事件绑定\" @事件名称=\"方法\"&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue({        el:\"#app\",        methods:{            方法:function(){                //逻辑            }        }    })&lt;/script&gt;\n\n传递自定义参数，事件修饰符\n&lt;div id=\"app\"&gt;    &lt;input type=\"button\" @click=\"dolt(p1,p2)\"/&gt;    &lt;input type=\"text\" @keyup.enter=\"sayHi\"&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue({        el:\"#app\",        methods:{            dolt:function(p1,p2){},            sayHi:function(){                //因为上面是@keyup.enter所以只有在回车键的时候才会触发这个逻辑                //修饰符不止这一个，更多的可以参考地址：https://cn.vuejs.org/v2/api/#v-on            }        }    })&lt;/script&gt;\n\n\n\nv-if：作用：根据表达值的真假，切换元素的显示和隐藏（操控dom元素）\n&lt;div id=\"app\"&gt;    &lt;p v-if=\"true\"&gt;我是一个p标签&lt;/p&gt;    &lt;p v-if=\"isShow\"&gt;我是一个p标签&lt;/p&gt;    &lt;p v-if=\"表达式\"&gt;我是一个p标签&lt;/p&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue({        el:\"#app\",        data:{            isShow:false        }    })&lt;/script&gt;\n\n\n\nv-bind：作用：设置元素的属性（比如：src，title，class）\n单向绑定。数据只能从data流向界面。\n&lt;div id=\"app\"&gt;    &lt;img v-bind:src=\"imgSrc\"&gt;    &lt;img v-bind:title=\"imagtitle+'!!!!'\"&gt;    &lt;img v-bind:class=\"isActive?'active':\"&gt;    &lt;img v-bind:class=\"{active:isActive}\"&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue({        el:\"#app\",        data:{            imgSrc:\"图片地址\",            imgTitle:\"黑马程序员\",            isActive:false        }    })&lt;/script&gt;\n\n\n\n\n\nv-show:作用：根据表达值的真假，切换元素的显示和隐藏\n&lt;div id=\"app\"&gt;    &lt;img src=\"地址\" v-show=\"true\"&gt;&lt;/div&gt;&lt;scritp&gt;    el:\"app\",    data:{    isShow:true    }&lt;/script&gt;\n\nv-for作用：根据数据生成列表结构\n&lt;div id=\"app\"&gt;    &lt;ul&gt;        &lt;li v-for=\"item in arr\" :title=\"item\"&gt;{{item}}{{item}}&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    var app=new Vue({        el:\"#app\",        data:{            arr:[1,2,3,4,5]        }    })&lt;/script&gt;\n\n&lt;div id=\"app\"&gt;    &lt;ul&gt;        &lt;li v-for=\"(item,index) in objArr\"&gt;        {{item.name}}        &lt;/li&gt;        &lt;li v-for=\"(item,index) in objArr\"&gt;        {{item.name}}        &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue({        el:\"#app\",        data:{            objArr:[                {name:\"jack\"},            \t{name:\"rose\"}                ]            }        }    })&lt;/script&gt;\n\n\n\nv-model：说明：获取和设置表单元素的值（双向数据绑定）\n有双向绑定效果数据同步。只能应用在表单类元素（输入类元素）上。\nmodel默认找的value属性，所以可以写成v-model=“”\nv-model指令的作用是便捷的设置和获取表单元素的值\n绑定的数据会和表单元素值相关联\n&lt;div id=\"app\"&gt;    &lt;input type=\"text\"/&gt;&lt;/div&gt;&lt;script&gt;    var app = new Vue({        el:\"#app\",        data:{            message:\"黑马程序员\"        }    })&lt;/script&gt;\n\naxios说明：功能强大的网络请求库\n\naxios必须先导入才可以使用\n使用get或者post方法即可发送对应的请求\nthen方法中的回调函数会在请求成功或失败时触发\n通过回调函数的形参可以获取响应内容，或错误信息\n\n&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;axios.get(地址?key=value&amp;key2=value2).then(function(response){},function(err){})axios.post(地址,{key:value,key2:value2}).then(function(response){},function(err){})\n\n\n\n\n随机获取笑话的接口\n\n\n\n请求地址：https://autumnfish.cn/api/joke/list\n请求方法：get\n请求参数：num\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nnum\n笑话条数\n类型为数字\n\n\n\n响应内容：随机笑话\n\n\n\n用户注册接口1\n\n请求地址：https://autumnfish.cn/api/user/reg\n请求方式：post\n请求参数：username\n\n\n\n\n参数名\n参数说明\n备注\n\n\n\nusername\n用户名\n不能为空\n\n\n\naxios+vue&lt;script&gt;    var app = new Vue({        el:\"#app\",        data:{            joke:\"搞笑的笑话\"        },        methods:{            getJokes:function(){                //this.joke?                aixos.get(\"地址\").then(function(response){                    //this.joke?                },function(err){});            }        }    })&lt;/script&gt;\n\n\n\nMVVM模型：\n\nM：模型（Model）：对应data中的数据\nV：视图（View）：模板\nVM：视图模型（ViewModel）：Vue实例对象\n\n[Vue实例].$mount(‘#id’);：获取相应组件。\nVue - 组件（Component）\n一、什么是组件（Component）？组件（Component）是Vue.js最强大的功能之一。组件可以扩展HTML元素，封装可以重用的代码。在较高层面上，组件是自定义元素，Vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用is特性进行了扩展的原生HTML元素。\n所有Vue组件同事也都是Vue实例，所以可以接受相同的选项对象（除了一些根级特有的选项）并且提供相同的生命周期钩子。\n二、使用组件1.全局组件\n我们知道，创建一个Vue实例可以：\nnew Vue({  el: '#some-element',  // 选项})\n\n全局注册组件，可以使用Vue.component(tagName, options)。 比如：\nVue.component('my-component', {  // 选项})\n\n\n请注意，对于自定义标签的命名 Vue.js 不强制遵循 W3C 规则 (小写，并且包含一个短杠)，尽管这被认为是最佳实践。\n\n组件在注册之后，便可以作为自定义元素：&lt;my-component&gt;&lt;/my-component&gt;使用了。 注意确保在初始化根实例之前注册组件：\n在初始化根实例之前注册组件这句话就是指的是：\nVue.component('my-component', {  template: '&lt;div&gt;A custom component!&lt;/div&gt;'})var vm = new Vue({  el: '#box'})\n\n这样的顺序是对的，而\nvar vm = new Vue({  el: '#box'})Vue.component('my-component', {  template: '&lt;div&gt;A custom component!&lt;/div&gt;'})\n\n这样是错的。\n&lt;div id=\"example\"&gt;  &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;\n\n\n\n// 注册Vue.component('my-component', {  template: '&lt;div&gt;A custom component!&lt;/div&gt;'})// 创建根实例new Vue({  el: '#example'})\n\n我们要注意，一般选项中需要添加template，就是HTML的构造。\n渲染为：\n&lt;div id=\"example\"&gt;  &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt;\n\n2.局部注册\n不必把每个组件都注册到全局。你可以通过某个 Vue 实例/组件的实例选项 components 注册仅在其作用域中可用的组件：\nvar Child = {  template: '&lt;div&gt;A custom component!&lt;/div&gt;'}var vm = new Vue({  el: '#box',  components: {    'my-component': Child  }})var vm = new Vue({  el: '#box2'})\n\n\n\n&lt;div id=\"box\"&gt;  &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;div id=\"box2\"&gt;  &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;\n\n\nVue组件的全局注册，可以在多个Vue实例中使用，如果是在Vue构造器中局部注册，那么只能在此Vue实例中使用。\n\n那么在&lt;div id=\"box\"&gt;下面的&lt;my-component&gt;&lt;/my-component&gt;将不会渲染出来。\n这种封装也适用于其它可注册的 Vue 功能，比如指令。\n3.DOM模板解析注意事项\n当使用 DOM 作为模板的时候（例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上），你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析，规范化之后才能获取其内容。尤其要注意，像 &lt;ul&gt; &lt;ol&gt;, &lt;table&gt;，&lt;select&gt; 这样的元素里面允许包含的元素有限制，而另外一些像 &lt;option&gt; 这样的元素只能出现在某些特定元素的内部。\n在自定义组件中使用这些受限制元素时候会导致一些问题，比如：\n&lt;table&gt;  &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt;\n\n自定义组件 &lt;my-row&gt; 会被当成无效的内容，因此会导致错误的渲染结果。变通方式是使用特殊的 is 特性：\n&lt;table&gt;  &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt;\n\n应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制：\n&lt;script type=\"text/x-template\"&gt;JavaScript 内联模板字符串.vue 组件\n\n因此，请尽可能使用字符串模板。\n\ndata必须是函数\n\n构造 Vue 实例时传入的各种选项大多数都可以在组件里使用。只有一个例外：data 必须是函数。实际上，如果你这么做：\nVue.component('my-component', {  template: '&lt;span&gt;{{ message }}&lt;/span&gt;',  data: {    message: 'hello'  }})\n\n那么 Vue 会停止运行，并在控制台发出警告，告诉你在组件实例中 data 必须是一个函数。但理解这种规则为何存在也是很有益处的，所以让我们先作个弊：\n&lt;div id=\"example-2\"&gt;  &lt;simple-counter&gt;&lt;/simple-counter&gt;  &lt;simple-counter&gt;&lt;/simple-counter&gt;  &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt;\n\ndata参数中，一般是返回的js对象。比如:\ndata: function () {    return {        text: 'text',        name: 'Hello'    }}\n\n\n\nvar data = { counter: 0 }Vue.component('simple-counter', {  template: '&lt;button v-on:click=\"counter += 1\"&gt;{{ counter }}&lt;/button&gt;',   # 注意：这里是 += 不是 +  // 技术上 data 的确是一个函数了，因此 Vue 不会警告，  // 但是我们却给每个组件实例返回了同一个对象的引用  data: function () {    return data  }})new Vue({  el: '#example-2'})\n\n由于这三个组件实例共享了同一个 data 对象，因此递增一个 counter 会影响所有组件！这就错了。我们可以通过为每个组件返回全新的数据对象来修复这个问题：\ndata: function () {  return {    counter: 0  }}\n\n现在每个 counter 都有它自己内部的状态了。\n5.组件组合\n组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件 A 在它的模板中使用了组件 B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。然而，通过一个良好定义的接口来尽可能将父子组件解耦也是很重要的。这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。\n在 Vue 中，父子组件的关系可以总结为 prop 向下传递，事件向上传递。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。\n\n图片.png\n三、Prop1.使用Prop传值 组件实例的作用域是孤立的。这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。父组件的数据需要通过 prop 才能下发到子组件中。\n子组件要显式地用 props 选项声明它预期的数据：\nVue.component('child', {  // 声明 props  props: ['message'],  // 就像 data 一样，prop 也可以在模板中使用  // 同样也可以在 vm 实例中通过 this.message 来使用  template: '&lt;span&gt;{{ message }}&lt;/span&gt;'})\n\n\n\n&lt;div id=\"box\"&gt;  &lt;child message=\"hellow\"&gt;&lt;/child&gt;  &lt;child message=\"hellow\"&gt;&lt;/child&gt;  &lt;child message=\"123\"&gt;&lt;/child&gt;&lt;/div&gt;\n\n2.驼峰法 vs 短横线分隔法\nHTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)：\nVue.js中是区分大小写的。\nVue.component('child', {  // 在 JavaScript 中使用 camelCase  props: ['myMessage'],  template: '&lt;span&gt;{{ myMessage }}&lt;/span&gt;'})\n\n\n\n&lt;!-- 在 HTML 中使用 kebab-case --&gt;&lt;child my-message=\"hello!\"&gt;&lt;/child&gt;\n\n注意是自动转换为的，我们需要在使用模板的时候&lt;child my-message=\"hello!\"&gt;&lt;/child&gt;，注意到需要使用短横线分隔符号。\n3.动态Prop\n与绑定到任何普通的 HTML 特性类似，我们可以使用 v-bind 来动态地将prop绑定到父组件的数据。 每当父组件的数据变化时，该变化也会传导给子组件：\n&lt;div&gt;  &lt;input v-model=\"parentMsg\"&gt;  &lt;br&gt;  &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt;\n\n你也可以使用 v-bind 的缩写语法：\n&lt;child :my-message=\"parentMsg\"&gt;&lt;/child&gt;\n\n如果你想把一个对象的所有属性作为 prop 进行传递，可以使用不带任何参数的 v-bind (即用 v-bind 而不是 v-bind:prop-name)。例如，已知一个 todo 对象：\nvar vm = new Vue({  el: '#box',  data: {    todo: {      text: 'Learn Vue',      isComplete: false    }  }})\n\n\n\n&lt;todo-item v-bind=\"todo\"&gt;&lt;/todo-item&gt;\n\n等价于：\n&lt;todo-item  v-bind:text=\"todo.text\"  v-bind:is-complete=\"todo.isComplete\"&gt;&lt;/todo-item&gt;\n\neg：\n&lt;div id=\"box\"&gt;  &lt;child v-bind=\"todo\"&gt;&lt;/child&gt;&lt;/div&gt;\n\n\n\nVue.component('child', {  props: ['text', 'is-complete'],  template: '&lt;span&gt;{{ text }}&lt;/span&gt;'})var vm = new Vue({  el: '#box',  data: {    todo: {      text: 'Learn Vue',      isComplete: false    }  }})\n\n或者直接传递一个对象：\n&lt;body&gt;&lt;div id=\"box\"&gt;  &lt;child v-bind:todo=\"todo\"&gt;&lt;/child&gt;&lt;/div&gt;\n\n\n\nVue.component('child', {  props: ['todo'],  template: '&lt;span&gt;{{ todo.text }} {{ todo.isComplete }} &lt;/span&gt;'})var vm = new Vue({  el: '#box',  data: {    todo: {      text: 'Learn Vue',      isComplete: false    }  }})\n\n从上面可以看出，一般我们还是这样传递最好：\n&lt;child v-bind:todo=\"todo\"&gt;&lt;/child&gt;\n\n不要v-bind=\"todo\"，这样不是很方便样。\n4.字面量语法  vs 动态语法\n字面量语法，就是直接传递字符串这样： 初学者常犯的一个错误是使用字面量语法传递数值：\n&lt;!-- 传递了一个字符串 \"1\" --&gt;&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt;\n\n因为它是一个字面量 prop，它的值是字符串 “1” 而不是一个数值。如果想传递一个真正的 JavaScript 数值，则需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算： 下面才是正确的：\n&lt;!-- 传递真正的数值 --&gt;&lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt;\n\n5.单向数据流\nProp 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。\n另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。\n在两种情况下，我们很容易忍不住想去修改 prop 中数据：\n1）Prop 作为初始值传入后，子组件想把它当作局部数据来用；2）Prop 作为原始数据传入，由子组件处理成其它数据输出。\n\n正确的应对方式是： 1）定义一个局部变量，并且使用prop的值初始化它：\nVue.component('child', {  props: ['todo'],  template: '&lt;span&gt;{{ todo }} &lt;/span&gt;',  data: function () {    return {      com_todo: this.todo + \" ok\"    }  }})\n\n\n注意：外部传入了todo进来，那么现在又返回的有一个com_todo，现在组件中可以使用的数据就有两个了：todo和com_todo。 在组件的template中， 可以这样写：\n\ntemplate: '&lt;span&gt;{{ todo }} &lt;/span&gt;'template: '&lt;span&gt;{{ this.todo }} &lt;/span&gt;',template: '&lt;span&gt;{{ com_todo }} &lt;/span&gt;',template: '&lt;span&gt;{{ this.com_todo }} &lt;/span&gt;',\n\n2）定义一个计算属性（computed），来处理prop的值并且返回：\n&lt;div id=\"box\"&gt;  &lt;child v-bind:todo=\"123\"&gt;&lt;/child&gt;&lt;/div&gt;\n\n\n\nVue.component('child', {  props: ['todo'],  template: '&lt;span&gt;{{ computed_todo }} &lt;/span&gt;',  data: function () {    return {      com_todo: this.todo + \" ok\"    }  },  computed: {    computed_todo: function () {      return this.todo + \"2\"    # 注意这里不能 return todo + \"2\"    }  }})\n\n\n注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。\n\n\nProp验证\n\n我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用。\n要指定验证规则，需要用对象的形式来定义 prop，而不能用字符串数组： （我们之前的字符串数组形式是这样的：props:['todo', 'doit'])\n对象形式是：\nVue.component('example', {  props: {    // 基础类型检测 (`null` 指允许任何类型)    propA: Number,    // 可能是多种类型    propB: [String, Number],    // 必传且是字符串    propC: {      type: String,      required: true    },    // 数值且有默认值    propD: {      type: Number,      default: 100    },    // 数组/对象的默认值应当由一个工厂函数返回    propE: {      type: Object,      default: function () {        return { message: 'hello' }      }    },    // 自定义验证函数    propF: {      validator: function (value) {        return value &gt; 10      }    }  }})\n\ntype 可以是下面原生构造器：\nStringNumberBooleanFunctionObjectArraySymbol\n\n四、 非Prop特性所谓非 prop 特性，就是指它可以直接传入组件，而不需要定义相应的 prop。\n尽管为组件定义明确的 prop 是推荐的传参方式，组件的作者却并不总能预见到组件被使用的场景。所以，组件可以接收任意传入的特性，这些特性都会被添加到组件的根元素上。\n例如，假设我们使用了第三方组件 bs-date-input，它包含一个 Bootstrap 插件，该插件需要在 input 上添加 data-3d-date-picker 这个特性。这时可以把特性直接添加到组件上 (不需要事先定义 prop)：\n&lt;bs-date-input data-3d-date-picker=\"true\"&gt;&lt;/bs-date-input&gt;\n\n添加属性 data-3d-date-picker=”true” 之后，它会被自动添加到 bs-date-input 的根元素上。\n五、自定义事件我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。\n\n使用 v-on 绑定自定义事件 每个Vue实例都实现了事件接口，即：\n\n使用 $on(eventName) 监听事件  (也叫绑定事件)使用 $emit(eventName) 触发事件\n\n\nVue 的事件系统与浏览器的 EventTarget API 有所不同。尽管它们的运行起来类似，但是 $on 和 $emit 并不是addEventListener 和 dispatchEvent 的别名。\n\n另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。\n\n不能用 $on 监听子组件释放的事件，而必须在模板里直接用 v-on 绑定，参见下面的例子。\n\n下面是一个例子： （父组件在使用子组件的地方使用v-on监听子组件触发的事件）\n&lt;div id=\"counter-event-example\"&gt;  &lt;p&gt;{{ total }}&lt;/p&gt;  &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;  &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt;\n\n\n\nVue.component('button-counter', {  template: '&lt;button v-on:click=\"incrementCounter\"&gt;{{ counter }}&lt;/button&gt;',  data: function () {    return {      counter: 0    }  },  methods: {    incrementCounter: function () {      this.counter += 1      this.$emit('increment')    }  },})new Vue({  el: '#counter-event-example',  data: {    total: 0  },  methods: {    incrementTotal: function () {      this.total += 1    }  }})\n\n我们可以看到，这里有两个v-on:click=事件绑定，注意这个increment就是自定义事件： 是使用this.$emit('increment')触发这个事件的。\n&lt;button v-on:click=\"incrementCounter\"&gt;{{ counter }}&lt;/button&gt;  # 子级（自己）&lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;  # 父级\n\n子组件已经和它外部完全解耦了。它所做的只是报告自己的内部事件，因为父组件可能会关心这些事件。请注意这一点很重要。\n2.给组件绑定原生事件\n有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native。例如：\n&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt;\n\n3..sync修饰符\n在一些情况下，我们可能会需要对一个 prop 进行“双向绑定”。事实上，这正是 Vue 1.x 中的 .sync 修饰符所提供的功能。当一个子组件改变了一个带 .sync 的 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了单向数据流。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。 上面所说的正是我们在 2.0 中移除 .sync 的理由。但是在 2.0 发布之后的实际应用中，我们发现 .sync 还是有其适用之处，比如在开发可复用的组件库时。我们需要做的只是让子组件改变父组件状态的代码更容易被区分。 从 2.3.0 起我们重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。\neg：\n&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt;\n\n会被扩展为：\n&lt;comp :foo=\"bar\" @update:foo=\"val =&gt; bar = val\"&gt;&lt;/comp&gt;\n\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\nthis.$emit('update:foo', newValue)\n\n4.使用自定义事件的表单输入组件\n自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。要牢记：\n&lt;input v-model=\"something\"&gt;\n\n这不过是以下示例的语法糖：\n&lt;input  v-bind:value=\"something\"  v-on:input=\"something = $event.target.value\"&gt;\n\n1. \ncomponents: {      'm-header':MHeader}\n\n与\ncomponents: {      MHeader}\n\n是一样的，只是省略掉了默认的那个。\n6.Vue的父组件与子组件之间的交互（数据和事件）： https://blog.csdn.net/qq_16559905/article/details/78761956\n注意：子组件和父组件 函数的传递，是不需要写在props中的。 子组件：\nthis.$emit('function', params)\n\n父组件：\n&lt;sub-component @function=\"function_in_parent\" &gt;&lt;/sub-component&gt;\n\n这里的function_in_parent是在父组件中实现。\n基于脚手架开发（Vue-Cli）创建项目指令：\nvue cteate [项目名称]\n\n利用脚手架来运行项目指令：\nnpm run serve\n\n打包指令：\nnpm run build\n\nctrl+C停止运行\nmain.js\n//导入Vueimport Vue from 'vue'//导入App.vue组件import App from './App.vue'//关闭生产提示Vue.config.productionTip = false//创建Vue实例new Vue({    render: h=&gt; h(App),}).$mount('#app')  //通过$mount方法，指定挂在的容器\n\n\n\n如果出现下载缓慢配置npm淘宝镜像：npm config set registry\nhttps://registry.npm.taobao.org\nVue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行：vue inspect &gt; output.js这里就可以把脚手架默认的配置全都整理成js文件\n关于不同版本的Vue：1.vue.sj与vue.runtime.xx.js的区别：\n(1).vue.js是完整版的Vue，包含：核心功能+模板解析器。\n(2).vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数区指定具体内容。\nVue-cli脚手架配置覆写直接在与package.json同级的目录下覆写vue.config.js文件即可\n\n脚手架文件结构\n关于不同版本的vue：\nvue.config.js配置文件\n组件自定义事件事件解绑：//解绑一个自定义事件this.$off('这里就是自定义绑定事件的标签名称');//所有的自定义事件全都解绑this.$off();\n\n销毁当前组件实例this.$destroy(); //销毁当前组件的实例（注意，只是销毁组件实例，但是真实渲染的dom还在的，但是里面所绑定的一些vue的一些属性和事件全都不生效了）\n\n&lt;School @自定义事件的标签名称=\"触发这个事件后所调用的函数\"\n\n使用ref的方式写自定义事件：&lt;template&gt;&lt;Student ref=\"student\"&gt;&lt;/Student&gt;&lt;/template&gt;&lt;script&gt;    export default{        ...,        mounted(){            //this.$refs.student.$on('自定义事件的标签名称',这里填写触发时调用的自定义函数) //绑定自定义事件            this.$refs.student.$on('自定义事件的标签名称',(name,...params)=&gt;{                console.log('App收到了学生名：'name,params)                console.log(this)            }) //绑定自定义事件        }    }&lt;/script&gt;\n\n\n\n\n\nVue生命周期图\n\n全局事件总线\n1.一种组件间通讯的方式，适用于任意组件间通讯。\n全局事件总线可以忽略其子父级组件关系所有事件的触发全由一个代理来通知：\n以下为未简化版本的写法：\nimport Vue from 'vue'import App from './App.vue'Vue.config.productionTip = falseconst Demo = Vue.extend({})const d = new Demo()Vue.prototype.$bus = dnew Vue({  render: h =&gt; h(App)}).$mount('#app')\n\n以下为简化版本：\nimport Vue from 'vue'import App from './App.vue'Vue.config.productionTip = falsenew Vue({  render: h =&gt; h(App),  beforeCreate(){    Vue.prototype.$bus = this  //安装全局事件总线，$bus就是当前应用的vm  }}).$mount('#app')\n\n这里的$bus是随便的 一个变量名，但是为了标准写$bus最好\n使用事件总线：\n1.接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。\nmethods(){\tdemo(data){\t\t...\t}......mounted(){\tthis.$bus.$on('xxxx',this.demo)}}\n\n提供数据：this.$bus.$emit(‘xxxx’,数据)\n最好在beforeDestroy钩子中，用$off去绑定 当前组件所用到的事件。\n注意：要根据实际情况来用全局事件总线，有些比如父传子那么用props就行了，没必要用事件总线。\n消息订阅与发布\n报纸订阅与发布：\n​\t1.订阅报纸：住址\n​\t2.邮递员送报纸：报纸\n注意：消息订阅与发布只是一种理念，想要落到实处要通过实际的代码来体现，这里推荐使用pubsub-js库\n在Vue中：\n​\t1.订阅信息：消息名（手机号）\n​\t2.发布消息：消息内容\n引入pubsub-js库\nnpm i pubsub-js\n\n使用：\n首先要在需要使用的vue组件先引入才行\nimport pubsub from 'pubsub-js'export default{\tmounted(){\t\tpubsub.subscribe('订阅信息名称',/*回调函数*/function(){ //订阅信息\t\t\tconsole.log('有人发布了hello消息，hello消息的回调执行了')\t\t})\t},\tmethods:{\t\tsendStudentName(){\t\t\tpubsub.publish('发布消息名称(对应订阅消息名称)',/*发布的消息*/666)\t}},}\n\n这个库的设计有点像定时器，如果要取消订阅不能通过pubsub.unsubscribe(‘订阅信息名称’)的方式去取消订阅，而pubsub.subscribe订阅函数每次生成都会有唯一的id，所以要这样进行销毁：\nmounted(){\tthis.pubId = pubsub.subscribe('hello',function(msgName,data){ console.log('有人发布了hello消息')})},beforeDestroy(){\tpubsub.unsubscribe(this.pubId)}\n\n\n\n$nextTick\n语法：this.$nextTick(回调函数)\n作用：在下一次DOM更新结束后执行其指定的回调。\n什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。\n他的意思是指下一轮，他可以去指定一个回调，他所指定的回调函数会在dom节点更新完毕之后执行。\n\nVue封装的过度与动画\n作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名。\n图示：\n\nVue还可以定义组件初始化显示入场和出场的动画。\n&lt;template&gt;\t&lt;div&gt;   \t\t&lt;transition name=\"hello\"&gt;            &lt;h1 v-show&gt;&lt;/h1&gt;    \t&lt;/transition&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped&gt;    .hello-enter-active{        animation: atguigu 0.5s linear;    }    .hello-leave-active{        animation: atguigu 0.5s reverse;    }    @keyframes atguigu{        from{                    }        to{                    }    }&lt;/style&gt;\n\n在这里，hello对应动画的.xxxx-enter-active及.xxxx-leave-active这些，动画可以自己定义。\n如果没有定义动画的name属性那么默认就是.v-enter-active及.v-leave-active\n设置默认显示：\n&lt;template&gt;\t&lt;div&gt;   \t\t&lt;transition name=\"hello\" appear&gt;            &lt;h1 v-show&gt;&lt;/h1&gt;    \t&lt;/transition&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped&gt;    .hello-enter-active{        animation: atguigu 0.5s linear;    }    .hello-leave-active{        animation: atguigu 0.5s reverse;    }    @keyframes atguigu{        from{                    }        to{                    }    }&lt;/style&gt;\n\n这里的transition里面多了个appear属性，加了这个就表示默认是显示状态，相当于初始化就是加载显示的动画。这种写法是:appear=”true”的简写方式\n另一种写法：\n\n另外一种动画执行时间的写法\n\ntransition只能包裹一个元素，如果要包裹多个元素要使用transition-group：\n\n可以集成使用第三方的动画库\n比如animate.css\n使用npm安装：\nnpm install animate.css\n\n\n\n配置代理\naxios下载：\nnpm i axios\n\n解决跨域问题：\n1.配置cors\n2.jsonp ，但是只能解决get请求\n3.代理服务器\n利用Vue-cli开启代理服务器：\n开启方式一：const { defineConfig } = require('@vue/cli-service')module.exports = defineConfig({  transpileDependencies: true,    lintOnSave: false,//关闭语法检测  publicPath: process.env.NODE_ENV === 'production'? '././':'/',    //开启代理服务器，这里的代理连接是目标API服务器    devServer:{    proxy: 'http://localhost:4000'  }})\n\n这里的代理会现在本地查询是否有自己想要访问的网址资源，如果没有才会走代理，否则会直接返回本地的资源。\n开启方式二：这种方式可以配置多个代理服务器\nconst { defineConfig } = require('@vue/cli-service')module.exports = defineConfig({  transpileDependencies: true,    lintOnSave: false,  publicPath: process.env.NODE_ENV === 'production'? '././':'/',  devServer:{    proxy:{      '/api':{        target: '&lt;url&gt;'/*填写代理访问的api服务器，比如http:22.213.53.11:8089*/,        ws: true, //用于支持WebSocket，默认为true        changeOrigin: true //用于是否让代理服务器告诉目标api服务器真相地址和端口，如果false，则表示告诉。true则表示不告诉（谎称自己和api服务器是同源请求），默认为true。      },      '/foo':{        target: '&lt;other_url&gt;'      }    }  }})\n\n注意：这里如果单纯这么配置书写，如果直接请求的话会携带对应首个请求路径字段：\n\n比如请求：http:localhost:8080/api/test，那么他最后代理服务器转发后也是http:22.213.53.11:8089/api/test\n\n如果要剔除掉对应代理字段然后转发请求的话，需要配置pathRewrite配置：const { defineConfig } = require('@vue/cli-service')module.exports = defineConfig({  transpileDependencies: true,    lintOnSave: false,  publicPath: process.env.NODE_ENV === 'production'? '././':'/',  devServer:{    proxy:{      '/api':{        target: '&lt;url&gt;',        pathRewrite:{'^/api': ''}        // ws: true,        // changeOrigin: true      },      '/foo':{        target: '&lt;other_url&gt;'      }    }  }})\n\n这里^/api使用的正则匹配/api，然后将其替换成空字符串。\n1.xhr\n2.jquery\n3.axios\n4.vue-resource\n官方更推荐axios来作为请求框架。\n插槽\nVueX是什么？概念：专门在Vue中实现几种式状态管理（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通讯的方式，且适用于任意组件间通信。\n什么时候使用VueX1.多个组件依赖于同一状态\n2.来自不同组件的行为需要变更同一状态\n\nVueX原理图：\n\nVueX的安装\n如果直接使用指令：\nnpm i vuex\n\n这样使用就会有问题，因为现在Vue默认会使用Vue3版本的VueX，所以直接下载的话会下载vueX的最新版本VueX4版本。因为我们现在是Vue2所以要下载VueX3版本。\n所以要用指令指定版本：\nnpm i vuex@3\n\n然后再main.js引入vuex：\nmport Vue from 'vue';import App from './App.vue';import Vuex from 'vuex';//使用插件Vue.use(Vuex)new Vue({  render: h =&gt; h(App),}).$mount('#app')\n\n\n\n搭建VueX环境\n1.创建文件：src/store/index.js\n//引入Vue核心库import Vue from 'vue'//引入VueXimport Vuex fom 'vuex'//应用Vuex插件Vue.use(Vuex)//准备actions对象——响应组件中用户的动作const actions={}//准备mutations对象——修改state中的数据const mutations={}//准备state对象——保存具体的数据const state={}//创建并暴露storeexport default new Vuex.Store({    actions,    mutations,    state})\n\nmain.js引入：\nimport store from './store'new Vue({    el:'#app',    render: h=&gt;(App),    store})\n\n\n\n基本使用初始化数据、配置actions、配置mutations、操作文件store.js\nimport Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const actions = {        //响应组件中加的动作        jia(context,value){            //console.log('actions中的jia被调用了',miniStore,value)            context,commit(\"JIA\",value)        },    } const mutations = {    //执行加    JIA(state,value){        //console.log('mutations中的JIA被调用了',miniStore,value)        state.sum += value    }}//初始化数据const state = {    sum: 0}//创建并暴露storeexport default new Vuex.Store(    actions,    mutations,    state,)\n\n组件中读取vuex中的数据：$store.state.sum\n组件中修改vuex中的数据：$store.dispatch(‘action中的方法名’,数据)或$srore.commit(‘mutations中的方法名’,数据)\n备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit\n路由（vue-router）\nvue-router的理解\nvue的一个插件库，专门用来实现SPA应用\n\n对SPA应用的理解\n1.单页Web应用(single page web application, SPA)。\n2.整个应用只有一个完整的页面。\n3.点击页面中的导航链接不会刷新页面，只会做页面的局部更新。\n4.数据需要通过ajax请求获取。\n\n理解：一个路由(route)就是一组映射关系（key-value），多个路由需要路由器（router）进行管理。\n前端路由：key是路径，value是组件。\n基本使用只有vue-router3才能使用 在vue2版本，所以使用安装：\nnpm i vue-router@3\n\n\n\n应用插件：Vue.use(VueRouter)\n编写router配置项：\n引入VueRouterimport VueRouter from 'vue-router'//引入Luyou 组件import About from '../components/About.vue'import Home from '../components/Home.vue'//创建router实例对象，去管理一组一组的路由规则export default new VueRouter({    routes:[        {            path:'/about',            component:About        },        {            path: '/home',            component:Home        }    ]})\n\n实现切换（active-class可配置高亮样式）\n&lt;routeer-link active-class=\"active\" to=\"/about\"&gt;About&lt;/routeer-link&gt;\n\n指定展示位置\n&lt;router-view&gt;&lt;/router-view&gt;\n\n多级路由（多级路由）1.配置路由规则，使用children配置项：\nroutes:[    {        path:'/about',        component: About,    },    {        path: '/home',        component: Home,        children:[//通过children配置子级路由            {                path: 'news', //此处一定不要写：/news            \tcomponent:News            },            {                path: 'message',//此处一定不要写，/message                component: Message            }        ]    }]\n\n2.跳转（要写完整路径）：\n&lt;router-link to=\"/home/news\"&gt;News&lt;/router-link&gt;\n\n\n\n跳转并通过query参数进行传参&lt;router-link :to=\"`/home/message/detail?id=${m.id}&amp;title=${m.title}`\"&gt;{{m.title}}&lt;/router-link&gt;\n\n另一种写法（推荐）：\n&lt;router-link :to=\"{                  \tpath: '/home/message/detail',                  \tquery:{                  \t\tid: m.id,                  \t\ttitle: m.title                  \t}                  }\"&gt;{{m.title}}&lt;/router-link&gt;\n\n接收参数：$route.query.id$route.query.title\n\n\n\n命名路由作用：可以简化路由的跳转\n在路由中加上name属性就行：\n引入VueRouterimport VueRouter from 'vue-router'//引入Luyou 组件import About from '../components/About.vue'import Home from '../components/Home.vue'//创建router实例对象，去管理一组一组的路由规则export default new VueRouter({    routes:[        {            name: 'guanyu'\t//给路由起名            path:'/about',            component:About        },        {            name: 'jia'            path: '/home',            component:Home        }    ]})\n\n使用：\n&lt;router-link :to=\"{                  \tname: 'guanyu',                  \tquery:{                  \t\tid: m.id,                  \t\ttitle: m.title                  \t}                  }\"&gt;{{m.title}}&lt;/router-link&gt;\n\n\n\n使用占位符申明接收params参数routes:[    {        path:'/about',        component: About,    },    {        path: '/home',        component: Home,        children:[//通过children配置子级路由            {                path: 'news', //此处一定不要写：/news            \tcomponent:News            },            {                path: 'message',//此处一定不要写，/message                component: Message                children:[                \t{                \t\tname: 'xiangqing',                \t\tpath: 'detail/:id/:title',\t//使用占位符申明接收params参数            \t\t}                ]            }        ]    }]\n\n传递参数：\n&lt;!-- 跳转携带params参数，to的字符串写法--&gt;&lt;router-link :to=\"/home/message/detail/666/你好\"&gt;跳转&lt;/router-link&gt;&lt;router-link :to=\"{                  \tname: 'xiangqing',                  \tparams:{                  \t\tid: 666,                  \t\ttitle: '你好'                  \t}                  }\"&gt;{{m.title}}&lt;/router-link&gt;\n\n**特别注意：**路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！\n接收参数：\n$route.params.id$route.params.title\n\n\n\n路由组件props配置routes:[    {        path:'/about',        component: About,    },    {        path: '/home',        component: Home,        children:[//通过children配置子级路由            {                path: 'news', //此处一定不要写：/news            \tcomponent:News            },            {                path: 'message',//此处一定不要写，/message                component: Message                children:[                \t{                \t\tname: 'xiangqing',                \t\tpath: 'detail/:id/:title',\t//使用占位符申明接收params参数                \t\tcomponent: Detail,                \t\t//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件                \t\t// props:{a:900}                \t\t//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件                \t\t// props:true                                \t\t//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件，这种写法是最强大的                \t\tprops(route){            \t\t\t\treturn{            \t\t\t\t\tid:route.query.id,            \t\t\t\t\ttitle:route.query.title            \t\t\t\t}            \t\t\t}            \t\t}                ]            }        ]    }]\n\n\n\n&lt;reuter-link&gt;的replace属性1.作用：控制路由跳转时操作浏览器历史记录的模式\n2.浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push。\n3.如何开启replace模式：\n&lt;router-link replace .......&gt;News&lt;router-link&gt;\n\n\n\n\n\n编程式路由导航//$router的两个APIthis.$router.push({    name: 'xiangqing',    params:{        id:xxx,        title:xxx    }})this.$router.replace({    name: 'xiangqing',    params:{        id:xxx,        title:xxx    }})this.$router.forward() //前进this.$routeer.back() //后退this.$router.go(3)\t//可前进可后退，且可以指定前进后退的次数，负数为后退，正数为前进\n\n\n\n缓存路由组件&lt;keep-alive include=\"这里写组件名称\"&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n\n如果不写include那么只要是被keep-alive包裹的组件都会被缓存下来。\n缓存多个组件：\n&lt;keep-alive :include=\"['News','Mesa']\"&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;\n\n\n\n激活和不激活状态（可以理解成组件切换状态使用吧）:\nactivated(){//路由组件被激活时触发    ......},deactivated(){//路由组件失活时触发。    ......}\n\n\n\n路由守卫全局前置路由守卫//全局前置路由守卫——初始化的时候被调用、每次路由切换之前被调用router.beforEach((to/*要去的路由信息*/,from/*从哪去的路由信息*/,next)=&gt;{        next()  //这个就是放行，路由守卫有点像拦截器，他会拦截所有的路由跳转，如果要通过的话必须要调用next函数进行放行})\n\n例如：\nrouter.beforeEach((to,from,next)=&gt;{    if(to.path==='/home/news' || to.path === '/home/message'){        if(localStorage.getItem('school') === 'atguigu'){            next()        }else{            alert('学校名称不对，无权限查看！')        }    }else{        next()    }})\n\n\n\nmeta路由信息const router = new VueRouter({    routes:{        name: 'guanyu',        path: '/about',        component: About,        meta: {title: '关于',isAuth: false}    }})\n\n\n\n\n\n全局后置路由守卫//全局后置路由守卫——初始化的时候被调用、每次路由切换之后被调用router.afterEach((to,from)=&gt;{    })\n\n\n\n\n\n独享路由守卫const router = new VueRouter({    routes:{        name: 'guanyu',        path: '/about',        component: About,        meta: {title: '关于',isAuth: false},        beforeEnter: (to,from,next)=&gt;{            //...        }    }})\n\n\n\n\n\n组件内路由守卫&lt;template&gt;&lt;/template&gt;&lt;script&gt;    export default{        name: 'About',        mounted(){                    },        //通过路由规则，进入该组件时被调用        beforeRouteEnter(to,from,next){            // ...            next() //放行        },        //通过路由规则，离开该组件时被调用        beforeRouteLeave(to,from,next){            // ...            next() //放行        }    }&lt;/script&gt;\n\n\n\nhistory模式与hash模式const router = new VueRouter({    mode: 'history' // 默认是hash模式    routes:{        name: 'guanyu',        path: '/about',        component: About,        meta: {title: '关于',isAuth: false},        beforeEnter: (to,from,next)=&gt;{            //...        }    }})\n\nhash模式兼容性好但是带有#号不美观。\nhistory模式没有#号，但是兼容性略差。\n几个注意点1.路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。\n2.通过切换，“隐藏”了的路由组件，默认是被销毁的，需要的时候再去挂载。\n3.每个组件都有自己的$route属性，里面存储着自己的路由信息。\n4.整个应用只有一个router，可以通过组件的$router属性获取到。\nVue UI组件库\n移动端常用UI组件库\nVant：https://youzan.github.io/vant\nCube UI：https://didi.github.io/cube-ui\nMint UI：http://mint-ui.github.io\n\nPC端常用UI组件库\n\nElement UI：https://element.eleme.cn\nIView UI：https://www.iviewui.com\n\n","categories":["前端"],"tags":["Vue"]},{"title":"Web前端布局学习笔记","url":"/2023/02/24/learnnote/web-qian-duan/web-bu-ju-xue-xi/","content":"Web前端布局\n标准文档流\n标准文档流为从上到下排列\n\n这样的布局显得呆板，如果想要横过来\n\n\n浮动\n\n所谓元素的浮动是指设置了浮动属性的元素会脱离标准文档流的控制，移动到其父元素中指定位置的过程。\n\n注意：使用浮动那么接下来的不用浮动的元素记得清楚浮动，清除浮动操作详见塌陷解决和清楚同级子元素浮动。\n选择器float: 属性值：\ndiv{    float: left;}\n\n说明：\n如果未有设置浮动的元素和其浮动的元素一起用，那么为设置浮动的将会占在浮动元素的本身位置上进行定位（其实是设置浮动的元素的碰撞箱没有了），也就是说会覆盖掉浮动位置的元素位置，除非两者都是浮动。\n塌陷解决如果有父元素包裹浮动元素那么就有可能造成塌陷，塌陷就是指父元素未定义长宽所以并不会被子元素撑开，想要防止塌陷那就要在父类的时候进行塌陷消除，那就要使用overflow属性设置为hidden。\ndicv{    overflow: hidden;}\n\n第二种：\n.father:after{\tcontent: \"\";\tdisplay: block;\tclear: both;}\n\n\n\n清除同级子元素浮动div{    clear: both;}\n\nclear只能清除元素左右两侧浮动影响；\n\n脱离文档流之后，块元素的宽度和高度默认被内容撑开，除非事先定义好高宽；\n\n元素浮动后，block块级元素的显示模式就变成了inline-block，宽度本身是100%的元素，因为显示模式的改变，宽度变为自身内容宽度。\n\nblock块级元素的宽是独占一行，如果不通过盒模型设置，宽度继承100%占满文档。\n\n行内元素浮动后变为行内 块元素（inline-block），不需要转成块元素，就能够设置宽度、高度了。\n\n\n定位布局\nposition属性用于定义元素的定位模式，其基本语法格式如下：\ndiv{\tposition: relative;}\n\nrelative为相对定位\nabsolute为绝对定位\nrelative相对定位：\n\n保留了同级元素的碰撞箱，默认不覆盖到其他同级盒子，并且相对！！其进行定位\n\nabsolute绝对定位：绝对定位，如果没有在其父元素知道相对定义(也就是父级元素定义position为relative)，则就是依据body来定位。\n\n默认忽略掉同级元素盒子以父盒子或者body来进行定位。\n\n固定位置\n是以浏览器窗口为基准进行元素进行定位，脱离基本文档流。\noverflow可以解决文档溢出问题flex配合justify-content实现控件水平平均分布。","categories":["前端"],"tags":["HTML","CSS"]},{"title":"GithubActions使用教程","url":"/2024/11/27/learnnote/github/githubactions/","content":"GitHubActions使用教程关于GitHubActionsGitHubActions Yaml模板name: Actions Name # 这个表示的是你当前Actions执行工程的别名，根据你自己需求随便写就行on:  push:  \ttags:  \t  - 'v*' # Trigger on version tags 触发的版本标签，就是说如果有以推送v....开头的tag标签push那么就会触发这个actionspermissions:  contents: write # 这个意思是同意GitHubrelease写入权限，你如果要同时进行release发布则必须要写这个env:  PROJECT_NAME: ${{github.event.repository.name}} #使用仓库名作为项目名称  BUILD_DATE: ${{github.ref_name}}-${{github.run_id}} #获取当前日期jobs:  build:    name: Build and Release    runs-on: ubuntu-latest #表示以Ubuntu系统环境构建    steps:    - name: Checkout code #这个是构建步骤名称，根据自己需求随便写就行      uses: actions/checkout@v4 # 这啥玩意      with:        fetch-depth: 0 #获取完整的Git历史    - name: Set up Go #步骤名称，按照实际情况取名就行，在这里是作为go环境安装的步骤进行      uses: actions/setup-go@v5      with:        go-version-file: 'go.mod' #使用go.mod文件指定Go版本，其实也可以直接手动指定版本        cache: true # 启用依赖缓存    - name: Get dependencies #步骤名称，按照自己需要随便取名      run: go mod download #run是执行指令的意思，这里的话代表下载对应项目的依赖项，熟悉go语言的应该懂得          - name: Prepare Release Directory      run: mkdir -p release #创建一个名为release的文件夹        - name: Build Linux AMD64      run: &gt; #这里是执行指令      \tGOOS=linux GOARCH=amd64 go build -o release/${{env.PROJECT_NAME}}_${{env.BUILD_DATE}}_linux_amd64    - name: Build linux ARM64      run: &gt;\n\n","categories":["GithubActions"],"tags":["Github"]},{"title":"玩转Github","url":"/2024/06/08/learnnote/github/github/","content":"玩转Github\nREADME的Banner 生成网址GitHub Socialify\n比如：\n\n相关图标推荐📛 Awesome Badges - DEV Community\n","categories":["Github"],"tags":["Github"]},{"title":"Gin学习","url":"/2025/04/03/learnnote/go-xue-xi-bi-ji/gin-xue-xi/","content":"Gin学习\n一、Gin导入与基础使用预览1、安装Gin框架go get -u github.com/gin-gonic/gin\n\nGin 使用 encoding/json 作为默认的 json 包，但是你可以在编译中使用标签将其修改为 jsoniter。\n$ go build -tags=jsoniter .\n\n\n\n2、创建第一个Gin应用package mainimport \"github.com/gin-gonic/gin\"func main() {    // 新建一个没有任何默认中间件的路由\tr := gin.New()    r.GET(\"/\", func(c *gin.Context) {        c.String(200, \"Hello, Gin!\")    })    r.Run(\":8080\")}\n\n在上面的代码中，我们首先导入了Gin框架的包，然后创建了一个默认的Gin引擎，并定义了一个路由，最后启动了Gin应用程序。\n3、常用功能除了基本的路由功能外，Gin框架还提供了许多常用的功能，如中间件、参数解析、日志记录等。下面是一个使用中间件和参数解析的示例：\npackage mainimport (    \"github.com/gin-gonic/gin\"    \"net/http\")func main() {    // 新建一个没有任何默认中间件的路由\tr := gin.New()        \t// 全局中间件\t// Logger 中间件将日志写入 gin.DefaultWriter，即使你将 GIN_MODE 设置为 release。\t// By default gin.DefaultWriter = os.Stdout    r.Use(gin.Logger())    // Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500。    r.Use(gin.Recovery())    r.GET(\"/hello\", func(c *gin.Context) {        name := c.Query(\"name\")        c.JSON(http.StatusOK, gin.H{\"message\": \"Hello, \" + name})    })    r.Run(\":8080\")}\n\n在上面的示例中，我们首先使用了Logger和Recovery中间件，然后定义了一个带有参数解析的路由，最后启动了Gin应用程序。\n4、路由定义和处理：package mainimport (\t\"github.com/gin-gonic/gin\")func main() {\trouter := gin.Default()\t// GET 请求处理\trouter.GET(\"/hello\", func(c *gin.Context) {\t\tc.JSON(200, gin.H{\t\t\t\"message\": \"Hello, World!\",\t\t})\t})\t// POST 请求处理\trouter.POST(\"/users\", func(c *gin.Context) {\t\tvar user User\t\tif err := c.ShouldBindJSON(&amp;user); err != nil {\t\t\tc.JSON(400, gin.H{\t\t\t\t\"error\": err.Error(),\t\t\t})\t\t\treturn\t\t}\t\t// 处理接收到的用户数据\t\t// ...\t\tc.JSON(200, gin.H{\t\t\t\"message\": \"User created successfully\",\t\t})\t})\trouter.Run(\":8080\")}\n\n\n\n5、参数化路由和路由组：package mainimport (\t\"github.com/gin-gonic/gin\")func main() {\trouter := gin.Default()\t// 参数化路由\trouter.GET(\"/users/:id\", func(c *gin.Context) {\t\tid := c.Param(\"id\")\t\tc.String(200, \"User ID: %s\", id)\t})\t// 路由组\tv1 := router.Group(\"/api/v1\")\t{\t\tv1.GET(\"/users\", func(c *gin.Context) {\t\t\tc.String(200, \"List of users\")\t\t})\t\tv1.POST(\"/users\", func(c *gin.Context) {\t\t\tc.String(200, \"Create a user\")\t\t})\t\tv1.PUT(\"/users/:id\", func(c *gin.Context) {\t\t\tid := c.Param(\"id\")\t\t\tc.String(200, \"Update user with ID: %s\", id)\t\t})\t\tv1.DELETE(\"/users/:id\", func(c *gin.Context) {\t\t\tid := c.Param(\"id\")\t\t\tc.String(200, \"Delete user with ID: %s\", id)\t\t})\t}\trouter.Run(\":8080\")}\n\n这些代码示例展示了如何使用 Gin 框架定义路由和处理请求，包括 GET 和 POST 请求的处理、参数化路由以及路由组的使用。\n6、模板渲染和静态文件1. 模板渲染：Gin 框架内置了对多种模板引擎的支持，包括 HTML 模板引擎、Ace 模板引擎等。你可以通过 gin.Default() 方法创建一个默认的路由组，并使用 LoadHTMLGlob 或者 LoadHTMLFiles()方法来加载模板文件。以下是一个简单的示例：\npackage mainimport (\t\"github.com/gin-gonic/gin\"\t\"net/http\")func main() {\trouter := gin.Default()\t// 加载模板文件\trouter.LoadHTMLGlob(\"templates/*\")\t// 定义路由处理函数，渲染模板\trouter.GET(\"/hello\", func(c *gin.Context) {\t\tc.HTML(http.StatusOK, \"hello.tmpl\", gin.H{\t\t\t\"title\": \"Hello, Gin!\",\t\t})\t})\trouter.Run(\":8080\")}\n\ntemplates/index.tmpl：\n&lt;html&gt;\t&lt;h1&gt;\t\t{{ .title }}\t&lt;/h1&gt;&lt;/html&gt;\n\n在这个示例中，我们首先使用 LoadHTMLGlob 方法加载了位于 “templates” 目录下的所有模板文件。然后，在 “/hello” 路由处理函数中，我们使用 c.HTML 方法渲染了名为 “hello.tmpl” 的模板，并传递了一个包含标题信息的数据。\n使用不同目录下名称相同的模板:\nfunc main() {\trouter := gin.Default()\trouter.LoadHTMLGlob(\"templates/**/*\")\trouter.GET(\"/posts/index\", func(c *gin.Context) {\t\tc.HTML(http.StatusOK, \"posts/index.tmpl\", gin.H{\t\t\t\"title\": \"Posts\",\t\t})\t})\trouter.GET(\"/users/index\", func(c *gin.Context) {\t\tc.HTML(http.StatusOK, \"users/index.tmpl\", gin.H{\t\t\t\"title\": \"Users\",\t\t})\t})\trouter.Run(\":8080\")}\n\ntemplates/posts/index.tmpl\n{{ define \"posts/index.tmpl\" }}&lt;html&gt;&lt;h1&gt;\t{{ .title }}&lt;/h1&gt;&lt;p&gt;Using posts/index.tmpl&lt;/p&gt;&lt;/html&gt;{{ end }}\n\ntemplates/users/index.tmpl\n{{ define \"users/index.tmpl\" }}&lt;html&gt;&lt;h1&gt;\t{{ .title }}&lt;/h1&gt;&lt;p&gt;Using users/index.tmpl&lt;/p&gt;&lt;/html&gt;{{ end }}\n\n2. 自定义模板渲染器可以使用自定义的 html 模板渲染\nimport \"html/template\"func main() {\trouter := gin.Default()\thtml := template.Must(template.ParseFiles(\"file1\", \"file2\"))\trouter.SetHTMLTemplate(html)\trouter.Run(\":8080\")}\n\n3. 自定义分隔符你可以使用自定义分隔\nrouter := gin.Default()router.Delims(\"{[{\", \"}]}\")router.LoadHTMLGlob(\"/path/to/templates\")\n\n4. 自定义模板功能查看详细示例代码。\nmain.go\nimport (    \"fmt\"    \"html/template\"    \"net/http\"    \"time\"    \"github.com/gin-gonic/gin\")func formatAsDate(t time.Time) string {    year, month, day := t.Date()    return fmt.Sprintf(\"%d/%02d/%02d\", year, month, day)}func main() {    router := gin.Default()    router.Delims(\"{[{\", \"}]}\")    router.SetFuncMap(template.FuncMap{        \"formatAsDate\": formatAsDate,    })    router.LoadHTMLFiles(\"./testdata/template/raw.tmpl\")    router.GET(\"/raw\", func(c *gin.Context) {        c.HTML(http.StatusOK, \"raw.tmpl\", map[string]interface{}{            \"now\": time.Date(2017, 07, 01, 0, 0, 0, 0, time.UTC),        })    })    router.Run(\":8080\")}\n\nraw.tmpl\nDate: {[{.now | formatAsDate}]}\n\n结果：\nDate: 2017/07/01\n\n\n\n5. 静态文件服务：package mainimport \"github.com/gin-gonic/gin\"func main() {\trouter := gin.Default()\t// 从相对路径 \"assets\" 提供静态文件\trouter.Static(\"/static\", \"./assets\")\t// 从绝对路径 \"/tmp\" 提供静态文件\trouter.StaticFS(\"/static2\", http.Dir(\"/tmp\"))\t// 提供单个静态文件\trouter.StaticFile(\"/favicon.ico\", \"./resources/favicon.ico\")\trouter.Run(\":8080\")}\n\n这个示例展示了如何在 Gin 框架中提供静态文件服务，可以方便地将静态资源文件（如图片、样式表、脚本等）提供给客户端。\n7、 JSON 解析与绑定：package mainimport (\t\"github.com/gin-gonic/gin\")type User struct {\tUsername string `json:\"username\"`\tPassword string `json:\"password\"`}func main() {\trouter := gin.Default()\trouter.POST(\"/login\", func(c *gin.Context) {\t\tvar user User\t\tif err := c.ShouldBindJSON(&amp;user); err != nil {\t\t\tc.JSON(400, gin.H{\"error\": err.Error()})\t\t\treturn\t\t}\t\t// 根据用户输入的用户名和密码进行验证\t\t// ...\t\tc.JSON(200, gin.H{\"message\": \"Login successful\"})\t})\trouter.Run(\":8080\")}\n\n这个示例演示了如何接收 JSON 格式的请求体，并将其绑定到结构体中进行处理。\n这些代码示例展示了 Gin 框架中各种功能的具体使用方法，包括中间件、JSON 解析与绑定等。\n8、错误处理和日志记录1. 自定义错误处理函数Gin 框架允许你注册全局的中间件来处理错误。你可以创建一个中间件函数来捕获处理程序中的错误，并返回自定义的错误响应。以下是一个简单的示例：\npackage mainimport (\t\"github.com/gin-gonic/gin\"\t\"net/http\")func main() {\trouter := gin.Default()\t// 自定义全局中间件处理错误\trouter.Use(func(c *gin.Context) {\t\tc.Next()\t\t// 检查是否有发生错误\t\tif len(c.Errors) &gt; 0 {\t\t\t// 自定义错误处理\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"服务器内部错误\"})\t\t}\t})\trouter.GET(\"/ping\", func(c *gin.Context) {\t\t// 模拟处理过程中发生错误\t\tc.Error(gin.Error{Err: errors.New(\"处理过程中发生错误\")})\t})\trouter.Run(\":8080\")}\n\n在这个示例中，我们创建了一个全局中间件函数来检查处理过程中是否有错误发生，如果有错误则返回自定义的错误响应。在路由处理函数中，我们通过 c.Error 方法模拟了一个处理过程中发生的错误。\n2. 使用 Gin 框架的日志功能Gin 框架默认集成了日志功能，你可以直接使用 gin.Default() 方法创建的默认路由组来记录日志。以下是一个示例：\npackage mainimport (\t\"github.com/gin-gonic/gin\"\t\"os\")func main() {\t// 将日志输出到文件\tf, _ := os.Create(\"gin.log\")\tgin.DefaultWriter = io.MultiWriter(f, os.Stdout)\trouter := gin.Default()\trouter.GET(\"/ping\", func(c *gin.Context) {\t\tc.String(http.StatusOK, \"pong\")\t})\trouter.Run(\":8080\")}\n\n在这个示例中，我们将日志输出到文件 “gin.log” 中，并使用 io.MultiWriter 来同时输出到文件和标准输出。Gin 框架会自动记录请求的详细信息以及处理时间等日志内容。\n9、设置当前环境Gin 项目的部署可以通过环境变量或直接在代码中进行配置。\n以下环境变量可用于配置 Gin：\n\n\n\n环境变量\n说明\n\n\n\nPORT\n使用 router.Run() 启动 Gin 服务器时（即不带任何参数）监听的 TCP 端口。\n\n\nGIN_MODE\n可设置为 debug、release 或 test。用于管理 Gin 的运行模式，如是否输出调试信息。也可以在代码中使用 gin.SetMode(gin.ReleaseMode) 或 gin.SetMode(gin.TestMode) 来设置。\n\n\n以下代码可用于配置 Gin：\n// 不指定 Gin 的绑定地址和端口。默认绑定所有接口，端口为 8080。// 使用不带参数的 `Run()` 时，可通过 `PORT` 环境变量更改监听端口。router := gin.Default()router.Run()// 指定 Gin 的绑定地址和端口。router := gin.Default()router.Run(\"192.168.1.100:8080\")// 仅指定监听端口。将绑定所有接口。router := gin.Default()router.Run(\":8080\")// 设置哪些 IP 地址或 CIDR 被视为可信任的代理，用于设置记录真实客户端 IP 的请求头。// 更多详情请参阅文档。router := gin.Default()router.SetTrustedProxies([]string{\"192.168.1.2\"})\n\n\n\n10、不要信任所有代理Gin 允许你指定哪些请求头可以保存真实的客户端 IP（如果有的话），以及你信任哪些代理（或直接客户端）可以设置这些请求头。\n在你的 gin.Engine 上使用 SetTrustedProxies() 函数来指定可信任的网络地址或网络 CIDR，这些地址的请求头中与客户端 IP 相关的信息将被信任。它们可以是 IPv4 地址、IPv4 CIDR、IPv6 地址或 IPv6 CIDR。\n注意： 如果你没有使用上述函数指定可信代理，Gin 默认会信任所有代理，这并不安全。同时，如果你不使用任何代理，可以通过 Engine.SetTrustedProxies(nil) 来禁用此功能，这样 Context.ClientIP() 将直接返回远程地址，避免不必要的计算。\nimport (  \"fmt\"  \"github.com/gin-gonic/gin\")func main() {  router := gin.Default()  router.SetTrustedProxies([]string{\"192.168.1.2\"})  router.GET(\"/\", func(c *gin.Context) {    // 如果客户端是 192.168.1.2，则使用 X-Forwarded-For    // 请求头中可信部分推断出原始客户端 IP。    // 否则，直接返回客户端 IP    fmt.Printf(\"ClientIP: %s\\n\", c.ClientIP())  })  router.Run()}\n\n提示： 如果你使用 CDN 服务，可以设置 Engine.TrustedPlatform 来跳过 TrustedProxies 检查，它的优先级高于 TrustedProxies。 请看下面的示例：\nimport (  \"fmt\"  \"github.com/gin-gonic/gin\")func main() {  router := gin.Default()  // 使用预定义的 gin.PlatformXXX 头  // Google App Engine  router.TrustedPlatform = gin.PlatformGoogleAppEngine  // Cloudflare  router.TrustedPlatform = gin.PlatformCloudflare  // Fly.io  router.TrustedPlatform = gin.PlatformFlyIO  // 或者，你可以设置自己的可信请求头。但要确保你的 CDN  // 能防止用户传递此请求头！例如，如果你的 CDN 将客户端  // IP 放在 X-CDN-Client-IP 中：  router.TrustedPlatform = \"X-CDN-Client-IP\"  router.GET(\"/\", func(c *gin.Context) {    // 如果设置了 TrustedPlatform，ClientIP() 将解析    // 对应的请求头并直接返回 IP    fmt.Printf(\"ClientIP: %s\\n\", c.ClientIP())  })  router.Run()}","categories":["GO"],"tags":["GO","Gin"]},{"title":"go语言基础","url":"/2024/06/23/learnnote/go-xue-xi-bi-ji/go-yu-yan-ji-chu/","content":"go语言基础Go 语言数据类型在 Go 编程语言中，数据类型用于声明函数和变量。\n数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。\nGo 语言按类别有以下几种数据类型：\n\n\n\n序号\n类型和描述\n\n\n\n1\n布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。\n\n\n2\n数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。\n\n\n3\n字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。\n\n\n4\n派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型\n\n\n\n数字类型Go 也有基于架构的类型，例如：int、uint 和 uintptr。\n\n\n\n序号\n类型和描述\n\n\n\n1\nuint8 无符号 8 位整型 (0 到 255)\n\n\n2\nuint16 无符号 16 位整型 (0 到 65535)\n\n\n3\nuint32 无符号 32 位整型 (0 到 4294967295)\n\n\n4\nuint64 无符号 64 位整型 (0 到 18446744073709551615)\n\n\n5\nint8 有符号 8 位整型 (-128 到 127)\n\n\n6\nint16 有符号 16 位整型 (-32768 到 32767)\n\n\n7\nint32 有符号 32 位整型 (-2147483648 到 2147483647)\n\n\n8\nint64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)\n\n\n浮点型\n\n\n序号\n类型和描述\n\n\n\n1\nfloat32 IEEE-754 32位浮点型数\n\n\n2\nfloat64 IEEE-754 64位浮点型数\n\n\n3\ncomplex64 32 位实数和虚数\n\n\n4\ncomplex128 64 位实数和虚数\n\n\n\n其他数字类型以下列出了其他更多的数字类型：\n\n\n\n序号\n类型和描述\n\n\n\n1\nbyte 类似 uint8\n\n\n2\nrune 类似 int32\n\n\n3\nuint 32 或 64 位\n\n\n4\nint 与 uint 一样大小\n\n\n5\nuintptr 无符号整型，用于存放一个指针\n\n\n声明变量的一般形式是使用 var 关键字：\nvar identifier type\n\n可以一次声明多个变量：\nvar identifier1, identifier2 type\n\n其中var是代表变量的意思，const是不可变的变量，type则是对应的变量类型\n","categories":["go"],"tags":["语言基础"]},{"title":"go语言踩坑","url":"/2024/01/24/learnnote/go-xue-xi-bi-ji/go-yu-yan-cai-keng/","content":"go语言踩坑// 若出现hash校验错误请使用以下指令// set GONOSUMDB=*// set GOPROXY=direct","categories":["GO"],"tags":["GO","踩坑"]},{"title":"机场收藏列表","url":"/2025/01/18/learnnote/v2ray-shi-yong-jiao-cheng/ji-chang-ping-tai/","content":"\nSSONE导航站 (hello36d.com)\n\n最强机场 (zqjc.org)\n\n百变小樱-官方地址发布页 (bbxy88.com)\n\n24年实惠好用的翻墙机场推荐/VPN推荐 - 性价比机场测速 (duangks.com)\n\n独角兽\n\n\n","categories":["机场"],"tags":["机场","clash","VPN","V2R"]},{"title":"FCNN神经网络算法","url":"/2023/02/24/learnnote/ren-gong-zhi-neng/bp-shen-jing-wang-luo-suan-fa/","content":"FCNN神经网络算法\n1 BP神经网络概念\n首先从名称中可以看出，Bp神经网络可以分为两个部分，bp和神经网络。bp是 Back Propagation 的简写 ，意思是反向传播。\nBP网络能学习和存贮大量的输入-输出模式映射关系，而无需事前揭示描述这种映射关系的数学方程。它的学习规则是使用最速下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。\n其主要的特点是：信号是正向传播的，而误差是反向传播的。\n举一个例子，某厂商生产一种产品，投放到市场之后得到了消费者的反馈，根据消费者的反馈，厂商对产品进一步升级，优化，一直循环往复，直到实现最终目的——生产出让消费者更满意的产品。产品投放就是“信号前向传播”，消费者的反馈就是“误差反向传播”。这就是BP神经网络的核心。\n2 算法流程图\n\n3 神经元模型\n\n每个神经元都接受来自其它神经元的输入信号，每个信号都通过一个带有权重的连接传递，神经元把这些信号加起来得到一个总输入值，然后将总输入值与神经元的阈值进行对比（模拟阈值电位），然后通过一个“激活函数”处理得到最终的输出（模拟细胞的激活），这个输出又会作为之后神经元的输入一层一层传递下去。\n4 激活函数\n引入激活函数的目的是在模型中引入非线性。如果没有激活函数（其实相当于激励函数是f(x) = x），那么无论你的神经网络有多少层，最终都是一个线性映射，那么网络的逼近能力就相当有限，单纯的线性映射无法解决线性不可分问题。正因为上面的原因，我们决定引入非线性函数作为激励函数，这样深层神经网络表达能力就更加强大。\nBP神经网络算法常用的激活函数：\n1）Sigmoid（logistic），也称为S型生长曲线，函数在用于分类器时，效果更好。\n\n\n2）Tanh函数（双曲正切函数），解决了logistic中心不为0的缺点，但依旧有梯度易消失的缺点。\n\n\n3）relu函数是一个通用的激活函数，针对Sigmoid函数和tanh的缺点进行改进的，目前在大多数情况下使用。\n\n\n5 神经网络基础架构\nBP网络由输入层、隐藏层、输出层组成。\n\n输入层：信息的输入端，是读入你输入的数据的\n隐藏层：信息的处理端，可以设置这个隐藏层的层数（在这里一层隐藏层，q个神经元）\n输出层：信息的输出端，也就是我们要的结果\nv，w分别的输入层到隐藏层，隐藏层到输出层的是权重\n对于上图的只含一个隐层的神经网络模型：BP神经网络的过程主要分为两个阶段，第一阶段是信号的正向传播，从输入层经过隐含层，最后到达输出层；第二阶段是误差的反向传播，从输出层到隐含层，最后到输入层，依次调节隐含层到输出层的权重和偏置，输入层到隐含层的权重和偏置。\n6 如何确定隐含层中的神经元个数\n因为对于隐层的神经元个数的确定目前还没有什么比较完美的解决方案，所以对此经过自己查阅书籍和上网查阅资料，有以下的几种经验方式来确定隐层的神经元的个数，方式分别如下所示：\n\n一般取(输入+输出)/2\n隐层一般小于输入层\n（输入层+1）/2\nlog(输入层)\nlog(输入层)+10\n\n实验得到以第五种的方式得到的测试结果相对较高。\n","categories":["AI","NN"],"tags":["BPNN"]},{"title":"CNN(卷积神经网络算法)","url":"/2024/06/29/learnnote/ren-gong-zhi-neng/cnn-juan-ji-shen-jing-wang-luo-suan-fa/","content":"CNN（卷积神经网络算法）\n\n重难点：CNN的BPy演算\n\n","categories":["AI","CNN"],"tags":["NN"]},{"title":"ReLU函数","url":"/2023/12/11/learnnote/ren-gong-zhi-neng/relu-han-shu/","content":"ReLU函数\n介绍：\n\nReLU函数是一种非线性激活函数，其函数形式为f(x) = max(0, x)。**当输入值小于0时，ReLU函数输出0；当输入值大于0时，ReLU函数输出输入值本身。ReLU函数具有以下特点：\n\n简单性：ReLU函数的定义简单，仅需比较输入值和0的大小即可确定输出值，因此计算效率高。\n\n非线性：虽然称为线性整流函数，但ReLU函数实际上是非线性的，能够引入非线性因素，增强模型的表达能力。\n\n激活稀疏性：当输入值小于0时，ReLU函数的输出为0，这意味着ReLU函数可以激活稀疏性，即只激活输入中的一部分神经元，增强模型的泛化能力和鲁棒性。\n\n凸性：ReLU函数在其定义域上是凸函数，具有较好的优化性质。\n\n\n  ReLU函数在深度学习中具有以下优势：\n\n梯度稳定性：在正区间上梯度为常数1，在负区间上梯度为0，没有出现梯度消失问题。\n\n计算效率：ReLU函数的计算非常简单，只需要进行一次比较操作和一次乘法操作，相比于其他激活函数更加高效。\n\n生物合理性：ReLU函数的形式与生物神经元的激活方式较为接近，能够更好地建模生物神经系统的特性2。\n\n\n  ReLU函数广泛应用于深度学习和神经网络中的各个任务，如图像处理、自然语言处理、强化学习等\n\n","categories":["AI","NN","算法"],"tags":["ReLU函数"]},{"url":"/2025/04/25/learnnote/ren-gong-zhi-neng/sumo-yu-python-jiao-ben/","content":"\n\nSUMO与Python脚本\n一、利用Python启动SUMOdef train():    # 启动SUMO    sumo_cmd = [\"sumo-gui\", \"-c\", \"E:/SUMOProject/study1.sumocfg\", \"--start\"] #这里注意替换为对应你的SUMO项目sumocfg文件路径    traci.start(sumo_cmd)        traci.close() #关闭仿真，这里close内部可以选填参数，如果为false则是强制关闭，不然会等系统响应完毕后才会关闭\n\n\n\n二、仿真交互控制红绿灯相位 \ntraci.trafficlight.setPhase(\"0\",2) #选择相位，也就是选择红绿灯策略，注意是从0开始的\n\n\n\n\n\n获取仿真是否有车辆traci.simulation.getMinExpectedNumber()\n\n比如：\ndef run():    \ttraci.trafficlight.setPhase(\"0\",2)        # while循环，如果没有车辆才结束        while traci.simulation.getMinExpectedNumber() &gt; 0:            traci.simulationStep();        traci.close()        sys.stdout.flush()\n\n"},{"title":"YOLO学习","url":"/2025/01/18/learnnote/ren-gong-zhi-neng/yolo/","content":"YOLO学习\n指标分析：\n$$Precision={TP \\over TP+FP}$$\n\n\n\n","categories":["YOLO"],"tags":["YOLO"]},{"title":"YOLOv8网络结构图","url":"/2025/01/18/learnnote/ren-gong-zhi-neng/yolov8/","content":"YOLOv8网络结构图\n","categories":["YOLO"],"tags":["YOLO"]},{"title":"卷积神经网络算法","url":"/2023/12/10/learnnote/ren-gong-zhi-neng/juan-ji-shen-jing-wang-luo-suan-fa/","content":"卷积神经网络算法\n1、卷积神经网络-CNN 的基本原理\n 卷积神经网络(Convolutional Neural Networks, CNNs)是一种深度学习算法，特别适用于图像处理和分析。其设计灵感来源于生物学中视觉皮层的机制，是一种强大的特征提取和分类工具。\n\n1.1、Layers\n整个CNN是由若干层不同类型的网络连接构成的的。例如下图，首先经过一次卷积滤波处理，得到了C1（卷积层 Feature map），然后又经过了一次下采样（池化）处理得到了S2（下采样层），之后又是一次卷积滤波得到C3卷积层，依次处理至途中的C5位全连接层，至此卷积的过程结束，被抽象的特征输入至传统的全连接神经网络。\n\n\n1.1.1 输入层（Input Layer）\n 这是网络的最初层，负责接收原始像素数据。每个像素的值都被视为原始特征。\n\n1.1.2 卷积层（Convolutional Layer）\n在卷积层中，一组可学习的滤波器（卷积核）在输入数据上进行滑动操作以生成特征图（Feature Maps，也就是下图的Convolved Feature）。卷积操作允许网络学习到输入数据的局部特征。此外，由于滤波器（卷积核）的权重在图像的不同部分是共享的，卷积层可以显著减少模型的参数数量，从而减轻过拟合的风险。\n怎么理解权重共享呢？我们可以这100个参数（也就是卷积操作）看成是提取特征的方式，该方式与位置无关。这其中隐含的原理则是：图像的一部分的统计特性与其他部分是一样的。这也意味着我们在这一部分学习的特征也能用在另一部分上，所以对于这个图像上的所有位置，我们都能使用同样的学习特征。\n\n\n 卷积层的运算过程如下图，用一个卷积核扫完整张图片：\n\n\n\n==注：==黄色部分框选部分的下标红色数字代表的是卷积核内的值。\n\n\n这个过程我们可以理解为我们使用一个过滤器（卷积核）来过滤图像的各个小区域，从而得到这些小区域的特征值。\n在具体应用中，往往有多个卷积核，可以认为，每个卷积核代表了一种图像模式，如果某个图像块与此卷积核卷积出的值大，则认为此图像块十分接近于此卷积核。如果我们设计了6个卷积核，可以理解：我们认为这个图像上有6种底层纹理模式，也就是我们用6种基础模式就能描绘出一副图像。\n\n\n\n以下就是25种不同的卷积核的示例：\n\n\n1.1.3 ReLU层（Rectified Linear Unit Layer）\n这是非线性操作层，通常紧跟在卷积层之后。其目的是通过应用非线性函数如ReLU（max(0, x)）来增加网络的非线性特性。\n\n1.1.4 池化层（Pooling Layer）\n也称作下采样层，其主要功能是降低特征图的空间尺寸，从而降低模型的计算复杂性，并在一定程度上提供模型的平移不变性。常见的池化操作有最大池化(Max Pooling)和平均池化(Average Pooling)。\n当图像太大时，池化层部分将减少参数的数量。空间池化也称为子采样或下采样，可在保留重要信息的同时降低数据维度，可以具有不同的类型，如最大值池化(Max Pooling)，平均池化(Average Pooling)，加和池化(Sum Pooling)。\n最常见的是最大值池化，其将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，能够在一定程度上控制过拟合。通常来说，CNN的卷积层之间都会周期性地插入池化层。\n\n\n1.1.5 全连接层（Fully Connected Layer）\n在一系列的卷积层和池化层之后，全连接层被用于对之前提取的特征进行高级别的推理。在这一层中，所有的输入都被连接到每个神经元，这与传统的神经网络类似。这个部分就是最后一步了，经过卷积层和池化层处理过的数据输入到全连接层，得到最终想要的结果。经过卷积层和池化层降维过的数据，全连接层才能”跑得动”，不然数据量太大，计算成本高，效率低下。\n\n1.1.6 输出层（Output Layer）\n最后，输出层通常使用softmax激活函数进行多类分类，或使用sigmoid激活函数进行二分类。\n\n1.2 反向传播算法推导（Backpropagation）1.2.1 回顾DNN的反向传播算法\n我们首先回顾DNN的反向传播算法。在DNN中，我们是首先计算出输出层的$\\delta^L$:$$\\delta^L = \\frac{\\partial J(W,b)}{\\partial z^L} = \\frac{\\partial J(W,b)}{\\partial a^L}\\odot \\sigma{‘}(zL)$$\n　　利用数学归纳法，用$\\delta^l+1$的值一步步的向前求出第l层的$\\delta^l$，表达式为：$$\\delta^{l} = (\\frac{\\partial z^{l+1}}{\\partial z{l}})T\\delta^{l+1} = (W{l+1})T\\delta^{l+1}\\odot \\sigma{‘}(zl)$$\n　　有了$\\delta ^l$的表达式，从而求出$W,b$的梯度表达式：$$\\frac{\\partial J(W,b)}{\\partial W^l} = \\delta{l}(a)^T\\frac{\\partial J(W,b,x,y)}{\\partial b^l} = = \\delta^{l}$$\n　　有了$W,b$梯度表达式，就可以用梯度下降法来优化$W,b$,求出最终的所有$W,b$的值。\n　　现在我们想把同样的思想用到CNN中，很明显，CNN有些不同的地方，不能直接去套用DNN的反向传播算法的公式。\n\n1.2.2 CNN的反向传播算法思想\n要套用DNN的反向传播算法到CNN，有几个问题需要解决：\n　　1）池化层没有激活函数，这个问题倒比较好解决，我们可以令池化层的激活函数为$\\sigma(z)=z$，即激活后就是自己本身。这样池化层激活函数的导数为1.\n　　2）池化层在前向传播的时候，对输入进行了压缩，那么我们现在需要向前反向推导$\\delta ^{l−1}$，这个推导方法和DNN完全不同。\n  3）卷积层是通过张量卷积，或者说若干个矩阵卷积求和而得的当前层的输出，这和DNN很不相同，DNN的全连接层是直接进行矩阵乘法得到当前层的输出。这样在卷积层反向传播的时候，上一层的$\\delta  ^{l−1}$递推计算方法肯定有所不同。\n\n　　4）对于卷积层，由于$W$使用的运算是卷积，那么从$\\delta ^l$推导出该层的所有卷积核的$W,b$的方式也不同。\n　　从上面可以看出，问题1比较好解决，但是问题2,3,4就需要好好的动一番脑筋了，而问题2,3,4也是解决CNN反向传播算法的关键所在。另外大家要注意到的是，DNN中的$a_l,c_l$都只是一个向量，而我们CNN中的$a_l,z_l$都是一个张量，这个张量是三维的，即由若干个输入的子矩阵组成。\n　　下面我们就针对问题2,3,4来一步步研究CNN的反向传播算法。\n　　在研究过程中，需要注意的是，由于卷积层可以有多个卷积核，各个卷积核的处理方法是完全相同且独立的，为了简化算法公式的复杂度，我们下面提到卷积核都是卷积层中若干卷积核中的一个。\n\n1.2.3 已知池化层的$\\delta ^l$，推导上一隐藏层的$\\delta ^{l-1}$\n我们首先解决上面的问题2，如果已知池化层的$\\delta ^l$，推导出上一隐藏层的$\\delta ^{l−1}$。\n　　在前向传播算法时，池化层一般我们会用MAX或者Average对输入进行池化，池化的区域大小已知。现在我们反过来，要从缩小后的误差$\\delta ^l$，还原前一次较大区域对应的误差。\n　　在反向传播时，我们首先会把$\\delta ^l$的所有子矩阵矩阵大小还原成池化之前的大小，然后如果是MAX，则把$\\delta ^l$的所有子矩阵的各个池化局域的值放在之前做前向传播算法得到最大值的位置。如果是Average，则把$\\delta ^l$的所有子矩阵的各个池化局域的值取平均后放在还原后的子矩阵位置。这个过程一般叫做upsample。\n　　用一个例子可以很方便的表示：假设我们的池化区域大小是2x2。$\\delta ^l$的第k个子矩阵为:\n$\\delta ^l _k = \\begin{pmatrix} 2&amp;8 \\ 4&amp;6\\end{pmatrix}$\n由于池化区域为2x2，我们先讲$\\delta ^l _k$做还原，即变成：\n$\\begin{pmatrix} 0&amp;0&amp;0&amp;0 \\ 0&amp;2&amp;8&amp;0 \\ 0&amp;4&amp;6&amp;0 \\ 0&amp;0&amp;0&amp;0 \\end{pmatrix}$\n如果是MAX，假设我们之前在前向传播时记录的最大值位置分别是左上，右下，右上，左下，则转换后的矩阵为：\n$\\begin{pmatrix} 2&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;8 \\ 0 &amp;4&amp;0&amp;0 \\ 0&amp;0&amp;6&amp;0 \\end{pmatrix}$\n如果是Average，则进行平均：转换后的矩阵为：\n$\\begin{pmatrix} 0.5&amp;0.5&amp;2&amp;2 \\ 0.5&amp;0.5&amp;2&amp;2 \\ 1&amp;1&amp;1.5&amp;1.5 \\ 1&amp;1&amp;1.5&amp;1.5 \\end{pmatrix}$\n这样我们就得到了上一层 $\\frac{\\partial J(W,b)}{\\partial a_k^{l-1}} 的值，要得到\\delta_k^{l-1}：\\delta_k^{l-1}=({\\partial a^{l-1} _k \\over \\partial z ^{l-1} _k})^T{\\partial J(W,b) \\over \\partial a^{l-1} _k} = upsample(\\delta^l _k) \\bigodot \\sigma^{‘} (z^{l-1} _k)$\n其中，upsample函数完成了池化误差矩阵放大与误差重新分配的逻辑。\n我们概括下，对于张量$\\delta ^{l−1}$，我们有：$\\delta^{l-1} = upsample(\\delta^l) \\odot \\sigma{‘}(z)$\n\n1.2.4 已知卷积层的$\\delta ^l$，推导上一隐藏层的$\\delta ^{l-1}$\n对于卷积层的反向传播，我们首先回忆下卷积层的前向传播公式：$ a^l= \\sigma(z^l) = \\sigma(a^{l-1}*W^l +b^l) $\n　　其中$n_in$为上一隐藏层的输入子矩阵个数。\n　　在DNN中，我们知道$\\delta ^{l-1}$和$\\delta ^l$的递推关系为：$\\delta^{l} = \\frac{\\partial J(W,b)}{\\partial z^l} =(\\frac{\\partial z^{l+1}}{\\partial z{l}})T \\frac{\\partial J(W,b)}{\\partial z^{l+1}} =(\\frac{\\partial z^{l+1}}{\\partial z{l}})T\\delta^{l+1}$\n　　因此要推导出$\\delta ^{l-1}$和$\\delta ^l$的递推关系，必须计算${\\partial z^l \\over \\partial z^{l-1}}$的梯度表达式。\n　　注意到$z^l$和$z^{l-1}$的关系为：$z^l = a{l-1}*Wl +b^l =\\sigma(z^{l-1})*W^l +b^l $\n　　因此我们有：$\\delta^{l-1} = (\\frac{\\partial z^{l}}{\\partial z{l-1}})T\\delta^{l} = \\delta^{l}*rot180(W) \\odot \\sigma{‘}(z) $\n　　这里的式子其实和DNN的类似，区别在于对于含有卷积的式子求导时，卷积核被旋转了180度。即式子中的$rot180()$，翻转180度的意思是上下翻转一次，接着左右翻转一次。在DNN中这里只是矩阵的转置。那么为什么呢？由于这里都是张量，直接推演参数太多了。我们以一个简单的例子说明为啥这里求导后卷积核要翻转。\n　　假设我们$l−1$层的输出$a^{l−1}$是一个3x3矩阵，第$l$层的卷积核$W^l$是一个2x2矩阵，采用1像素的步幅，则输出$z^l$是一个2x2的矩阵。我们简化$b^l$都是0,则有$a^{l-1}*W^l = z^{l}$\n　　我们列出$a,W,z$的矩阵表达式如下：\n$\\begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\ a_{21} &amp; a_{22} &amp; a_{23} \\ a_{31}&amp;a_{32}&amp;a_{33} \\end{pmatrix} * \\begin{pmatrix} w_{11}&amp;w_{12} \\ w_{21}&amp;w_{22}\\end{pmatrix}= \\begin{pmatrix}  z_{11}&amp;z_{12} \\ z_{21}&amp;z_{22}\\end{pmatrix}$\n　利用卷积的定义，很容易得出：\n$z_{11}=a_{11}w_{11}+a_{12}w_{12}+a_{21}w_{21}+a_{22}w_{22} \\  z_{12}=a_{12}w_{11}+a_{13}w_{12}+a_{22}w_{21}+a_{23}w_{22} \\ z_{22}=a_{22}w_{11}+a_{23}w_{12}+a_{32}w_{21}+a_{33}w_{22}$\n接着我们模拟反向求导：$\\nabla a^{l-1} = \\frac{\\partial J(W,b)}{\\partial a^{l-1}} = ( \\frac{\\partial z^{l}}{\\partial a^{l-1}})T\\frac{\\partial J(W,b)}{\\partial z^{l}} =(\\frac{\\partial z^{l}}{\\partial a^{l-1}})T \\delta^{l} $\n　　从上式可以看出，对于$a^{l−1}$的梯度误差$∇a^{l−1}$，等于第$l$层的梯度误差乘以${\\partial z^l \\over \\partial a^{l-1}}$,而${\\partial z^l \\over \\partial  a^{l−1}}$对应上面的例子中相关联的$w$的值。假设我们的$z$矩阵对应的反向传播误差是$\\delta _{11},\\delta _{12},\\delta _{21},\\delta _{22}$组成的2x2矩阵，则利用上面梯度的式子和4个等式，我们可以分别写出$∇a^{l−1}$的9个标量的梯度。\n　　比如对于$a_{11}$的梯度，由于在4个等式中$a_{12}$只和$z_{11}$有乘积关系，从而我们有：\n​\t\t$\\nabla a_{12} = \\delta_{11}w_{12} + \\delta_{12}w_{11}$\n   同样的道理我们得到：\n$\\nabla a_{13} = \\delta_{12}w_{12} \\ \\nabla a_{21} = \\delta_{11}w_{21} + \\delta_{21}w_{11} \\ \\nabla a_{22} = \\delta_{11}w_{22} + \\delta_{12}w_{21} + \\delta_{21}w_{12} + \\delta_{22}w_{11} \\ \\nabla a_{23} = \\delta_{12}w_{22} + \\delta_{22}w_{12} \\ \\nabla a_{31} = \\delta_{21}w_{21} \\ \\nabla a_{32} = \\delta_{21}w_{22} + \\delta_{22}w_{21} \\ \\nabla a_{33} = \\delta_{22}w_{22}$\n   这上面9个式子其实可以用一个矩阵卷积的形式表示，即：\n$\\left( \\begin{array}{ccc} 0&amp;0&amp;0&amp;0 \\ 0&amp;\\delta_{11}&amp; \\delta_{12}&amp;0 \\ 0&amp;\\delta_{21}&amp;\\delta_{22}&amp;0 \\ 0&amp;0&amp;0&amp;0 \\end{array} \\right) * \\left( \\begin{array}{ccc} w_{22}&amp;w_{21}\\ w_{12}&amp;w_{11}\\end{array}\\right)  = \\left( \\begin{array}{ccc}\\nabla a_{11}&amp;\\nabla a_{12}&amp;\\nabla a_{13} \\ \\nabla a_{21}&amp; \\nabla a_{22}&amp;\\nabla a_{23} \\ \\nabla a_{31}&amp;\\nabla a_{32}&amp;\\nabla a_{33} \\end{array} \\right)$\n 为了符合梯度计算，我们在误差矩阵周围填充了一圈0，此时我们将卷积核翻转后和反向传播的梯度误差进行卷积，就得到了前一次的梯度误差。这个例子直观的介绍了为什么对含有卷积的式子反向传播时，卷积核要翻转180度的原因。\n\n1.2.5. 已知卷积层的$\\delta ^l$，推导该层的$W,b$的梯度\n　好了，我们现在已经可以递推出每一层的梯度误差$\\delta ^l$了，对于全连接层，可以按DNN的反向传播算法求该层$W,b$的梯度，而池化层并没有$W,b$,也不用求$W,b$的梯度。只有卷积层的$W,b$需要求出。\n　　注意到卷积层$z$和$W,b$的关系为：$z^l = a^{l-1}*W^l +b$\n　　因此我们有：$\\frac{\\partial J(W,b)}{\\partial W^{l}}=a *\\delta^l$\n　　注意到此时卷积核并没有反转，主要是此时是层内的求导，而不是反向传播到上一层的求导。具体过程我们可以分析一下。\n　　和第4节一样的一个简化的例子，这里输入是矩阵，不是张量，那么对于第l层，某个个卷积核矩阵W的导数可以表示如下：$\\frac{\\partial J(W,b)}{\\partial W_{pq}^{l}} = \\sum\\limits_i\\sum\\limits_j(\\delta_{ij} ^la_{i+p-1,j+q-1})$\n　　假设我们输入$a$是4x4的矩阵，卷积核$W$是3x3的矩阵，输出$z$是2x2的矩阵,那么反向传播的$z$的梯度误差$\\delta$也是2x2的矩阵。\n　　那么根据上面的式子，我们有：\n$\\frac{\\partial J(W,b)}{\\partial W_{11}^{l}} = a_{11}\\delta_{11} + a_{12}\\delta_{12} + a_{21}\\delta_{21} + a_{22}\\delta_{22}$\n$\\frac{\\partial J(W,b)}{\\partial W_{12}^{l}} = a_{12}\\delta_{11} + a_{13}\\delta_{12} + a_{22}\\delta_{21} + a_{23}\\delta_{22}$\n$\\frac{\\partial J(W,b)}{\\partial W_{13}^{l}} = a_{13}\\delta_{11} + a_{14}\\delta_{12} + a_{23}\\delta_{21} + a_{24}\\delta_{22}$\n$\\frac{\\partial J(W,b)}{\\partial W_{21}^{l}} = a_{21}\\delta_{11} + a_{22}\\delta_{12} + a_{31}\\delta_{21} + a_{32}\\delta_{22}$\n最终我们可以一共得到9个式子。整理成矩阵形式后可得：\n$\\frac{\\partial J(W,b)}{\\partial W^{l}} =\\left( \\begin{array}{ccc} a_{11}&amp;a_{12}&amp;a_{13}&amp;a_{14} \\ a_{21}&amp;a_{22}&amp;a_{23}&amp;a_{24} \\ a_{31}&amp;a_{32}&amp;a_{33}&amp;a_{34} \\a_{41}&amp;a_{42}&amp;a_{43}&amp;a_{44} \\end{array} \\right) * \\left( \\begin{array}{ccc}\\delta_{11}&amp; \\delta_{12} \\ \\delta_{21}&amp;\\delta_{22} \\end{array} \\right)$\n从而可以清楚的看到这次我们为什么没有反转的原因。\n　　而对于b,则稍微有些特殊，因为$\\delta ^l$是高维张量，而$b$只是一个向量，不能像DNN那样直接和$\\delta ^l$相等。通常的做法是将$\\delta ^l$的各个子矩阵的项分别求和，得到一个误差向量，即为$b$的梯度：\n$\\frac{\\partial J(W,b)}{\\partial b^{l}} = \\sum\\limits_{u,v}(\\delta^l)_{u,v}$\n\n\n参考文档： C++ 手搓 CNN 卷积神经网络 - 缙云山车神 - 博客园 (cnblogs.com)\n\n","categories":["AI","NN"],"tags":["CNN"]},{"title":"常见激活函数","url":"/2023/12/11/learnnote/ren-gong-zhi-neng/chang-jian-ji-huo-han-shu/","content":"常见激活函数\n\n\n&gt; sigmoid: $$\\sigma (x) =  {1 \\over 1+ e^{-x}}$$\n\n\n\n\n\n&gt; $$Softmax(z_i) = {e^{z_j} \\over {\\sum_{j}e^{z_j}} }$$\n\n\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; ba9a30f9b6bc72c7c9ab853dfe8d7a734c1dc853\n&gt; tanh: $$tanh(x)={sinh x \\over cosh x} = {{e^x-e^{-x}} \\over {e^x + e^{-x}}}$$\n&gt;\n&gt; ![image-20250312185116260](./常见激活函数/images/image-20250312185116260.png)\n\n\n\n\n\n&gt; ReLu: $$max(0,x)$$\n&gt;\n&gt; ![image-20250312183640674](./常见激活函数/images/image-20250312183640674.png)\n\n\n\n\n\n&gt; Leaky ReLu: $$max(0.1x,x)$$\n\n\n\n\n\n&gt; Maxout: $$max(w^T_1 x + b1, w^T _2 x + b2)$$\n\n\n\n\nELU: \n说明：ELU不会有梯度消失的困扰\n与 Leaky-ReLU 和 PReLU 类似，与 ReLU 不同的是，ELU 没有神经元死亡的问题(ReLU Dying 问题是指当出现异常输入时，在反向传播中会产生大的梯度，这种大的梯度会导致神经元死亡和梯度消失)。 它已被证明优于 ReLU 及其变体，如 Leaky-ReLU(LReLU) 和 Parameterized-ReLU(PReLU)。 与 ReLU 及其变体相比，使用 ELU 可在神经网络中缩短训练时间并提高准确度。\n\n\n","categories":["AI"],"tags":["AI","激活函数"]},{"title":"强化学习-马尔科夫决策过程（MDP）","url":"/2023/12/10/learnnote/ren-gong-zhi-neng/qiang-hua-xue-xi-ma-er-ke-fu-jue-ce-mdp/","content":"强化学习-马尔科夫决策过程（MDP）\n1、强化学习介绍\n\n强化学习任务通常使用马尔科夫决策过程（Markov Decision Process，简称MDP）来描述，具体而言：机器处在一个环境中，每个状态为机器对当前环境的感知；机器只能通过动作来影响环境，当机器执行一个动作后，会使得环境按某种概率转移到另一个状态；同时，环境会根据潜在的奖励函数反馈给机器一个奖赏。综合而言，强化学习主要包含四个要素：状态、动作、转移概率以及奖赏函数。\n\n\n根据上图，agent（智能体）在进行某个任务时，首先与environment进行交互，产生新的状态state，同时环境给出奖励reward，如此循环下去，agent和environment不断交互产生更多新的数据。强化学习算法就是通过一系列动作策略与环境交互，产生新的数据，再利用新的数据去修改自身的动作策略，经过数次迭代后，agent就会学习到完成任务所需要的动作策略。\n2、马尔科夫决策过程（Markov Process）\n 马尔可夫性当前状态包含了对未来预测所需要的有用信息，过去信息对未来预测不重要，该就满足了马尔科夫性，严格来说，就是某一状态信息包含了所有相关的历史，只要当前状态可知，所有的历史信息都不再需要，当前状态就可以决定未来，则认为该状态具有马尔科夫性。用公式描述为：\n$$P(S_{t+1}|S_t)=p(S_{t+1}|S_1,S_2,···,S_t)$$\n马尔科夫过程又叫做马尔科夫链（Markov Chain）,它是一个无记忆的随机过程，可以用一个元组&lt;S, P&gt;表示，其中\n\nS 是有限数量的状态集$S={s_1,s_2,s_3,\\cdots,s_t}$\nP 是状态转移概率矩阵$p(S_{t+1}=s’|s_t=s)$其中$s’$表示下一时刻的状态，s表示当前状态如下所示：对于状态$s_1$来说，有0.1的概率保持不变，有0.2的概率转移到$s_2$状态，有0.7的概率转移到$s_4$状态。\n\n\n可以使用矩阵来表示：\n\n3、马尔科夫奖励过程（Markov Reward Process）\n3.1、概念介绍\n马尔科夫奖励过程是在马尔科夫过程基础上增加了奖励函数R和衰减系数$\\gamma$，用$&lt; S,R,P,\\gamma &gt;$表示\n\nR：表示S状态下某一时刻的状态$S_t$在下一个时刻(t+1)能获得的奖励的期望\n\n$R_s = E[R_{t+1}|S_t =s]$\n\n$G_t$： 收获$G_t$为在一个马尔科夫奖励链上从t时刻开始往后所有的奖励的衰减收益总和\n\n$G_t = R_{t+1}+\\gamma R_{t+2}+ \\gamma ^2 R_{t+3} + ···+\\gamma ^{T-t-1}R_T$\n\n$\\gamma$：折扣因子$（Discount factory \\gamma \\in [0,1]）$\n1、为了避免出现状态循环的情况\n2、系统对于将来的预测并不一定都是准确的，所以要打折扣\n很显然$\\gamma$越靠近1，考虑的利益越长远。\n$V(s)$:状态价值函数（state value function表示从改状态开始的马尔科夫链收获$G_t$的期望\n\n$v(s)=E[G_t|S_t =s]$\n例子：对于如下状态，设定进入$S_1$状态奖励为5，进入$S_7$状态奖励为10，其余状态奖励为0。则R可以如下表示：$R=[5,0,0,0,0,0,10]$,折扣引子$\\gamma$为0.5。则对于下面两个马尔科夫过程获得的奖励为：\n\n$S_4,S_5,S_6,S_7: 0+0.50+0.50+0.125*10=1.25$\n$S_4,S_3,S_2,S_1: 0+0.50+0.250+0.125*5=0.625$\n\n\n3.2、Bellman Equation 贝尔曼方程\n$v(s) = E[G_t|S_t=s]$\n$= E[R_{t+1}+ \\gamma R_{t+2}+\\gamma ^2 R_{t+3}+···|S_t=s]$\n$= E[R_{t+1}+ \\gamma (R_{t+2} + \\gamma R_{t+3}+···)|S_t=s]$\n$= E[R_{t+1}+ \\gamma v(S_{t+1})|S_t=s]$\n$=E[R_{t+1}|S_t=s]+ \\gamma E[v(S_{t+1})|S_t=s]$\n其中$E[R_{t+1}|S_t=s]]$代表的当前奖励函数，$\\gamma E[v(S_{t+1})|S_t=s$为下一时刻状态的价值期望\n使用贝尔曼方程状态价值V可以表示为：\n$V(s)= R(s) + \\gamma \\sum _{s’ \\in S}P(s’|s)V(s’)$\n其中$R(s)为Immediate reward，\\gamma \\sum _{s’ \\in S}P(s’|s)V(s’)为Discounted sum of future reward$\n\nS 表示下一时刻的所有状态， $s’$表示下一时刻可能的状态\n\n通过贝尔曼方程，可以看到价值函数$v(s)$\n","categories":["AI","强化学习"],"tags":["马尔科夫决策"]},{"title":"计算机语言分类","url":"/2024/06/22/learnnote/qi-ta/ji-suan-ji-yu-yan-fen-lei/","content":"计算机语言分类\n1. 机器语言\n机器语言是计算机最原始的语言，是由0和1的代码构成，cpu在工作的时候只认识机器语言，即0和1的代码。\n2. 汇编语言\n汇编语言，即为一种低级语言，它用人类容易记忆的语言和符号来表示一组0和1的代码，例如AND代表加法。\n3. 标记语言\n标记语言：是一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的电脑文字编码。\n与文本相关的其他信息（包括文本的结构和表示信息等）与原来的文本结合在一起，但是使用标记进行标识。标记语言不仅仅是一种语言，就像许多语言一样，它需要一个运行时环境，使其有用。\n4. 脚本语言（解释型语言）\n脚本语言：是为了缩短编程语言的“编写、编译、链接、运行”等过程而创建的计算机编程语言。\n是一种用来解释某些东西的语言，又被称为扩建的语言，或者动态语言，用来控制软件应用程序，脚本通常以文本保存，只在被调用时进行解释或编译。\n脚本语言是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。它的命名起源于一个脚本“screenplay”，每次运行都会使对话框逐字重复。\n早期的脚本语言经常被称为批量处理语言或工作控制语言。 一个脚本通常是解释运行而非编译。\n脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。\n各种动态语言，如ASP、PHP、CGI、JSP、JavaScript、VBScript等，都是脚本语言。\n1、脚本语法比较简单，比较容易掌握； \n2、脚本与应用程序密切相关，所以包括相对应用程序自身的功能； \n3、脚本一般不具备通用性，所能处理的问题范围有限。\n5. 编程语言（高级语言、编译型语言）\n高级语言，它是在低级语言的基础上，采用接近于人类自然语言的单词和符号来表示一组低级语言程序，使编程变得更加简单，易学，且写出的程序可读性强。\n编程语言（programming language）：是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。\n编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成 为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些\n如 C、C++。\n","categories":["其他"],"tags":["计算机语言"]},{"title":"Hadoop使用","url":"/2024/07/01/learnnote/da-shu-ju/hadoop-shi-yong/","content":"Hadoop使用\nHadoop介绍\n狭义上Hadoop指的是Apache软件基金会的一款开源软件。\n用Java语言实现，开源\n允许用户使用简单的编程模型实现跨机器集群对海量数据进行分布式计算处理\n\nHadoop核心组件\nHadoop HDFS（分布式文件存储系统）：解决海量数据存储\nHadoop YARN（集群资源管理和人物调度框架）：解决资源任务调度\nHadoop MapReduce（分布式计算框架）：解决海量数据计算\n\n广义上Hadoop指的是围绕Hadoop打造的大数据生态圈。\n\n\n\nHadoop发展史\nHadoop之父：Doug Cutting\n\nHadoop起源于Apache Lucene子项目：Nutch\nNutch的设计目标是构建一个大型的全网搜索引擎。\n遇到瓶颈：如何解决数十亿网页的存储和索引问题\n\nGoogle三篇论文\n《The Google file system》：谷歌分布式文件系统GFS\n《MAPReduce：Simplified Data Processing on Large Clusters》：谷歌分布式计算框架MapReduce\n《Bigtable：A Distributed Storage System for Structured Data》：谷歌结构化数据存储系统\n\n\nHadoop现状\nHDFS作为分布式文件存储系统，处在生态圈的底层与核心地位；\n\nYARN作为分布式通用的集群资源管理系统和任务调度平台，支撑各种计算引擎计算引擎运行，保证了Hadoop地位；\n\nMapReduce作为大数据生态圈第一代分布式计算引擎，由于自身设计的模型所产生的弊端，导致企业一线几乎不再直接使用MapReduce进行编程处理，但是很多软件的底层依然在使用MapReduce引擎来处理数据。\n\n狭义上Hadoop指软件，广义上Hadoop指生态圈\n\n\nHadoop特性优点\n扩容能力：Hadoop实在可用的计算机集群间分配数据并完成计算任务的，这些集群可方便灵活的方式扩展到数以千计的节点。\n低成本：Hadoop集群允许通过部署普通廉价的机器组成集群来处理大数据，以至于成本很低。看重的是集群整体能力。\n高效率：通过高并发数据，hadoop可以在节点间动态并行的移动数据，使得速度非常快。\n可靠性：能自动维护数据的多份复制，并且在任务失败后能自动地重新部署（redeploy）计算任务。所以Hadoop的按位存储和处理数据的能力值得人们信赖。\n\nHadoop国内应用\n百度\n用户搜索表征的需求数据、阿拉丁爬虫数据存储数据分析和挖掘 竞价排名\n\n阿里巴巴\n为啥电子商务网络平台提供底层的基础计算和存储服务交易数据、信用数据\n\n腾讯\n用户关系数据\n基于Hadoop、Hive构建TDW（腾讯分布式数据仓库）\n\n华为\n对Hadoop的HA方案，以及HBase领域有深入研究\n\n\nHadoop发行版本\n开源社区版：Apache开源社区发行也是官方发行版本\n优点：更新迭代快\n缺点：兼容稳定性不周\n\n商业发行版：\n商业公司发行基于Apache开源协议，某些服务需要收费\n优点：稳定兼容好\n缺点：收费 版本更新慢\n\nApache开源社区版本\nhttp://hadoop.apache.org/\n\n商业发行版本\nCloudera：https://www.cloudera.com/products/open-source/apache-hadoop.html\nHortonworks：https://www.cloudera.com/products/hdp.html\n\n\n\nHadoop架构变迁（1.0-2.0变迁）\nHadoop 1.0\nHDFS（分布式文件存储）\nMapReduce（资源管理和分布式数据处理）\n\nHadoop 2.0\nHDFS（分布式文件存储）\nMapReduce（分布式数据处理）\nYARN（集群资源管理、任务调度）\n\n\n\nHadoop架构变迁（3.0新版本）Hadoop3.0架构组件和Hadoop 2.0类似，3.0着重于性能优化。\n\n通用方面\n精简内核、类路径隔离、shell脚本重构\n\nHadoop HDFS\nEC纠删码、多NameNode支持\n\nHadoop MapReduce\n任务本地化优化、内存参数自动推断\n\nHadoop YARN\nTimeline Service V2、队列配置\n\n\n\nHadoop集群整体概述\nHadoop集群包括两个集群：HDFS集群、YARN集群\n\n两个集群逻辑上分离、通常物理上在一起\n\n两个集群都是标准的主从架构集群\n\nHDFS集群（分布式存储）：\n主角色：NameNode\n从角色：DataNode\n主角色辅助角色：SecondaryNameNode\n\nYARN集群（资源管理、调度）：\n主角色：ResourceManager\n从角色：NodeManager\n\n逻辑上分离\n两个集群互相之间没有依赖、互不影响\n\n物理上在一起\n某些角色进程往往部署在同一台物理服务器上\n\nMapReduce集群呢？\nMapReduce是计算框架、代码层面的组件 没有集群之说\n\n\n\nHadoop安装包目录结构\nbin：Hadoop最基本的管理脚本和使用脚本的目录，这些脚本是sbin目录下管理脚本的基础实现，用户可以直接使用这些脚本管理和使用Hadoop\netc：Hadoop配置文件所在的目录\ninclude：对外提供的编程库头文件（具体动态库和静态库在lib目录中），这些头文件均是用C++定义的，通常用于C++程序访问HDFS或者编写MapReduce程序。\nlib：改目录包含了Hadoop对外提供的编程动态库和静态库，与include目录中的头文件结合使用。\nlibexec：各个服务对用的shell配置文件所在的目录，可用于配置日志输出、启动参数（比如JVM参数）等基本信息。\nsbin：Hadoop管理脚本所在的目录，主要包含HDFS和YARN中各类服务的启动/关闭脚本。\nshare：Hadoop各个模块编译后的jar包所在的目录，官方自带示例。\n\n配置文件概述\n官方文档：https://hadoop.apache.org/docs/r3.3.0/\n\n第一类1个：hadoop-env.sh\n\n第二类4个：\nxxxx-site.xml，site表示的是用户自定义的配置，会覆盖default中的默认配置。\ncore-site.xml，核心模块配置\nhdfs-site.xml，hdfs文件系统模块配置\nmapred-site.xml，MapReduce模块配置\nyarn-site.xml，yarn模块配置\n\n第三类1个：workers\n\n所有的配置文件目录：/export/server/hadoop-3.3.0/etc/hadoop\n\n修改配置文件（配置文件路径hadoop-3.3.0/etc/hadoop）\n\nhadoop-env.sh\nexport JAVA_HOME=/export/server/jdk1.8.0.241 #配置Java环境在哪export HDFS_NAMENODE_USER=root #NAMENODE使用的用户，以下配置意思以此类推export HDFS_DATANODE_USER=root export HDFS_SECONDARYNAMENODE_USER=rootexport YARN_RESOURCEMANAGER_USER=rootexport YARN_NODEMANAGER_USER=root\n\ncore-site.xml\n&lt;!--设置默认使用的文件系统Hadoop支撑file、HDFS、GFS、ali|Amazon云等文件系统--&gt;&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://node1:8020&lt;/value&gt;&lt;/property&gt;&lt;!--设置Hadoop本地保存数据路径--&gt;&lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/export/data/hadoop-3.3.0&lt;/value&gt;&lt;/property&gt;&lt;!--设置HDFS web UI用户身份--&gt;&lt;property&gt;    &lt;name&gt;hadoop.http.staticuser.user&lt;/name&gt;    &lt;value&gt;root&lt;/value&gt;&lt;/property&gt;&lt;!--整合hive用户代理设置--&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;    &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;!--文件系统垃圾桶保存时间--&gt;&lt;property&gt;    &lt;name&gt;fs.trash.interval&lt;/name&gt;    &lt;value&gt;1440&lt;/value&gt;&lt;/property&gt;\n\nhdfs-site.xml\n&lt;!-- 设置SNN进程运行机器位置信息 --&gt;&lt;property&gt;    &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;    &lt;value&gt;node2:9868&lt;/value&gt;&lt;/property&gt;\n\nmapred-site.xml\n&lt;!-- 设置MR程序默认运行模式：yarn集群模式 local本地模式--&gt;&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;&lt;/property&gt;&lt;!-- MR程序历史服务地址 --&gt;&lt;property&gt;    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;    &lt;value&gt;node1.10020&lt;/value&gt;&lt;/property&gt;&lt;!-- MR程序历史服务器web端地址 --&gt;&lt;property&gt;    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;    &lt;value&gt;node1:19888&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt;    &lt;value&gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;mapreduce.reduce.env&lt;/name&gt;    &lt;value&gt;HADOOP_MAPRED_HOME=${HADOOP_HOME}&lt;/value&gt;&lt;/property&gt;\n\nyarn-site.xml\n&lt;!-- 设置YARN集群主角色运行机器位置 --&gt;&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;node1&lt;/value&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;!-- 是否将对容器实施物理内存限制--&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.pmem-check-enabled&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;!-- 是否将对容器实施虚拟内存限制 --&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;!--开启日志聚集--&gt;&lt;property&gt;    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- 设置yarn历史服务器地址 --&gt;&lt;property&gt;    &lt;name&gt;yarn.log.server.url&lt;/name&gt;    &lt;value&gt;http://node1:19888/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;!-- 历史日志保存的时间 7天 --&gt;&lt;property&gt;    &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;    &lt;value&gt;604800&lt;/value&gt;&lt;/property&gt;\n\nworkers\nnode1.itcast.cnnode2.itcast.cnnode3.itcast.cn\n\n\n分发同步hadoop安装包\ncd /export/serverscp -r hadoop-3.3.0 root@node2:$PWDscp -r hadoop-3.3.0 root@node3:$PWD\n\n将hadoop添加到环境变量（3台机器）\nvim /etc/profileexport HADOOP_HOME=/export/server/hadoop-3.3.0export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\n\n集群启动准备工作step1：集群规划：\n\n角色规划的准则\n根据软件工作特征和服务器硬件资源情况合理分配\n比如依赖内存工作的NameNode是不是部署在大内存机器上？\n\n角色规划注意事项\n资源上有抢夺冲突的，尽量不要部署在一起\n工作上个需要互相配合。尽量部署在一起\n\n\n\n服务器\n运行角色\n\n\n\nnode1.itcast.cn\nnamenode datanode resourcemanager nodemanager\n\n\nnode2.itcast.cn\nsecondarynamenode datanode nodemanager\n\n\nnode3.itcast.cn\nnode3.itcast.cn nodemanager\n\n\n\n\nstep2：服务器基础环境准备\n\n集群时间同步（3台机器）\nyum -y install ntpdate\nntpdate ntp4.aliyun.com\n\n\n创建统一工作目录（3台机器）\nmkdir -p /export/server/ #软件安装路径\nmkdir -p /export/data #数据存储路径\nmkdir -p /export/software/ #安装包存放路径\n\n\n\nstep3：上传安装包、解压安装包\n\nJDK1.8安装（3台机器）\n\n\n上传、解压Hadoop安装包（node1）\n\n\n\nstep5：编辑Hadoop配置文件（1）\n\nhadoop-env.sh\n\n\n\nstep8：NameNode format（格式化操作）(注意！！！！！千万不要执行多次，只需要搭建好初始化的时候执行一次就行，以后都不用执行)\n\n首次启动HDFS时，必须对其进行格式化操作。\n\nformat本质上是初始化工作，进行HDFS清理和准备工作\n\n命令：\nhdfs namenode -format\n\n\n\n\n手动逐个进程启停\n\n每台机器上每次手动启动关闭一个角色进程，可以进准控制每个进程启停，避免群起群停。\n\nHDFS集群\n#hadoop2.x版本命令hadoop-daemon.sh start|stop namenode|datanode|secondarynamenode#hadoop3.x版本命令hdfs --daemon start|stop namenoddatanodsecondarynamenode\n\nYARN集群\n#hadoop2.x版本命令yarn-daemon.sh starstop resourcemanager|nodemanager#hadoop3.x版本命令yarn --daemon start|stop resourcemanager|nodemanager\n\nshell脚本一键启停\n\n在node1上，使用软件自带的shell脚本一键启动。前提：配置好机器之间的ssh免密登录和workers文件。\n\nHDFS集群\nstart-dfs.sh\nstop-dfs.sh\n\nYARN集群\nstart-yarn.sh\nstop-yarn.sh\n\nHadoop集群\nstart-all.sh\nstop-all.sh\n\n\n\n进程状态、日志查看\n\n启动完毕之后可以使用jps命令查看进程是否启动成功\njps #j代表Java，ps代表进程\n\n\n\nHadoop启动日志路径：/export/server/hadoop-3.3.0/logs/\n\n\n\nHDFS集群\n\n地址：http://namenode_host:9870\n其中namenode_host是namenode运行所在机器的主机名或者ip\n如果使用主机名访问，别忘了在Windows配置hosts\n\n\n\n","categories":["大数据"],"tags":["Hadoop"]},{"title":"宝塔常用指令","url":"/2024/03/02/learnnote/bao-ta/bao-ta-chang-yong-zhi-ling/","content":"\n查看面板入口（也可以通过该命令判断服务器是否安装了宝塔面板）\n/etc/init.d/bt default\n\n\n\n使用 bt 命令 重置用户密码\n\n\n重启面板\nbt restart\n\n","categories":["宝塔"],"tags":["宝塔"]},{"title":"实验室培训指南","url":"/2023/10/22/learnnote/shi-yan-shi-pei-xun-zhi-nan/shi-yan-shi-pei-xun-zhi-nan/","content":"培训指南\n一、常用便捷软件培训\n\n这个根据情况进行\n截图软件使用\nMarkdown笔记使用\n\n二、问答艺术及Git培训\n\nGit项目管理\n\n三、基础算法培训指南\n1、C语言基础语法\n1）变量的使用（局部变量、全局变量）\n2）++i和i++的区别\n3）局部变量和全局变量\n4）函数的使用\n5）数组的使用 \n6）指针的使用\n7）结构体的使用\n\n2、迭代算法的使用\n1）累加\n2）斐波拉契数列\n\n3、递归算法的使用\n1）递归实现累加\n2）递归实现一维数组的查找\n3）递归实现二维数组的查找\n\n4、基础数据结构\n1）链表的实现\n2）栈的实现\n3）队列的实现\n4）树的实现\n\n5、基础算法\n1）贪心算法实现\n2）前缀和算法实现（一维前缀和、二维前缀和）\n3）差分算法实现（一维差分、二维差分）\n4）全排列算法\n5）DFS算法实现\n6）BFS算法实现（这里教学两种实现方式即可，一个基于栈，一个基于队列，这里学完之后可以看情况布置任务，比如AI贪吃蛇）\n7）优先队列实现\n8）二分查找算法（整形二分，高精度二分）\n9）求最大公约数\n10）最小公倍数算法\n11）分解质因数\n12）求阶乘约数\n13）排列组合数学\n14）Dijkstra算法\n15）Kruskal算法\n16）基础DP算法\n\n6、数论\n1）判断质数\n2）最大公因数\n3）最小公倍数\n4）互质\n逆元\n容斥原理\n\n刷题计划\n\n比赛前1个月每日一题计划（难度逐渐提高）\n\n\n每一到两周进行算法双周赛（根据情况来定）\n\n","categories":["实验室"],"tags":["计算机培训"]},{"title":"STM32学习","url":"/2023/03/22/learnnote/qian-ru-shi/stm32/","content":"STM32 学习\n\n工程架构：\nST建议是如果是想自己写中断的话，是写在这个位置；\n直接操作寄存器可以查看stm32f10x.h：\nstm32f10x.adc.c封装了寄存器的操作，提供了更加人性化的操作。\n\nGPIO介绍\nGPIO(General Purpose Input Output)通用输入输出口\n可配置为8种输入输出模式\n引脚电平：0V~3.3V，部分引脚可容忍5V\n输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通讯协议输出时序等\n输入模式下课读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通讯协议接收数据等\n\nGPIO的基本结构\nGPIO位结构\n通过配置GPIO的端口配置寄存器，端口可以配置成以下8种模式\n浮空/上拉/下拉输入\nLED和蜂鸣器介绍\nLED：发光二极管，正向通电点亮，反向通电不亮\n有源蜂鸣器：内部自带震荡源，将正负极接上直流电压即可持续发声，频率固定\n无源蜂鸣器：内部不带震荡源，需要控制器提供震荡脉冲才可发声，调整提供震荡脉冲的频率，可发出不同频率的声音\n\n\n对应硬件电路\n电灯代码：#include \"stm32f10x.h\"int main(void){\t//RCC-&gt;APB2ENR = 0x00000010;\t//GPIOC-&gt;CRH = 0x00300000;\t//GPIOC-&gt;ODR = 0x00002000;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);\tGPIO_InitTypeDef GPIO_InitStructure;\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStructure);\tGPIO_ResetBits(GPIOA,GPIO_Pin_0);\t\t\twhile(1){\t}\t//return 0;}\n\n\n\n按键介绍：\n按键：常见的输入设备，按下导通，松手断开\n按键抖动：由于按键内部使用的是机械式弹簧片来进行通断的，所以在按下和松手的瞬间会伴随有一连串的抖动\n\n\n按钮控制代码：#include \"stm32f10x.h\"#include \"Delay.h\"void Key_Init(void){\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t\tGPIO_InitTypeDef GPIO_InitStructure;\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //上拉输入\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_12;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOB,&amp;GPIO_InitStructure);}int Key_GetNum(uint16_t btnID){\t\tint KeyNum = 0;\tif(GPIO_ReadInputDataBit(GPIOB,btnID) ==0){\t\tDelay_ms(20);\t\twhile(GPIO_ReadInputDataBit(GPIOB,btnID)==0);\t\tDelay_ms(20);\t\tKeyNum = 1;\t}\treturn KeyNum;}\n\n\n\n\n\n按键与传感器的接法\n上面两种解法是按下为高电平，松开是低电平。下面两种解法反之。（一般常用上面两种接法）\n\n\n传感器模块介绍：\n传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等)的电阻会随外接模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出\n\n\n\nC语言数据类型：\n\n在51单片机中int是占16位的，而在STM32中int是占32位的，如果要用16位的数据，要用short来表示\n\nOLED驱动函数\n\nI2C通讯\nI2C总线（Inter IC BUS）是由Philips公司开发的一种通用数据总线\n两根通讯线：SCL（Serial Clock）、SDA（Serial Data）\n同步，半双工\n带数据应答\n支持总线挂载多设备（一主多从、多主多从）\n\n\n硬件电路：\n简单双向串口通信由两根通信线（发送端TX和接收端RX）\nTX与RX要交叉连接\n当只需单向的数据传输时，可以只接一根通信线\n当电平标准不一致时，需要加电平转换芯片\n\n\n\nMPU6050：\nMPU6050是一个六轴姿态传感器，可以测量芯片自身X、Y，Z轴的加速度、角速度参数，通过数据融合，可以进一步得到姿态角，常应用于平衡车、飞行器等需要检测自身姿态的场景\n3轴加速度计（Accelerometer）：测量X、Y，Z轴的加速度\n3轴陀螺仪传感器（Gyroscope）：测量X，Y，Z轴的角速度\n\n\n\nEXTI介绍\nEXTI(Extern Interrupt)外部中断\nEXTI可以检测指定GPIO口的电平信号，当其指定的GPIO产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序\n支撑的触发方式：上升沿/下降沿/双边沿/软件触发\n支撑的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断\n通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒\n触发响应方式：中断响应/事件响应\n\n中断系统\n中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行\n中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源\n中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前的中断程序，转而去处理新的中断程序，处理完成后一次进行返回\n\n中断执行流程；\nSTM32中断\nNVIC基本结构\nNVIC优先级分组\nAFIO复用IO口\nAFIO主要用于引脚复用功能的学则和重定义\n在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择\n\n\nEXTI框图\n旋转编码器介绍\n旋转编码器：用来测量位置、速度或者旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向\n\n类型：机械触点式/霍尔传感器式/光柵式\n\n\n\n旋转编码器硬件电路\n注意：\n\n中断函数里，最好不要执行耗时过长的代码，中断函数要简短快速，别刚进中断就执行一个Delay多少毫秒这样的代码，因为中断是处理突发的事情，如果你为了一个突发的事情待着中断不出来了，那么主程序就会受到堵塞，另外就是，最好不要在中断函数和主函数调用相同的函数或者操作同一个硬件，尤其是硬件相关的函数，比如OLED显示函数，如果你既在主程序里调用OLED，又在中断里调用OLED，OLED就会显示错误。\n\n","categories":["嵌入式","STM32"],"tags":["STM32"]},{"title":"好用工具收集表","url":"/2024/06/08/learnnote/gong-ju/hao-yong-gong-ju-shou-ji-biao/","content":"好用工具收集表\n圆形图片裁剪器：\n在线圆形图片生成器-照片制作圆形图工具-江下科技在线应用 (onlinedo.cn)\n正则匹配工具：\n正则表达式在线测试 | 菜鸟工具 (jyshare.com)\nRegex正则表达式在线测试 - 正则表达式在线生成工具 - MKLab在线工具\n图片压缩工具：\n压缩图片：在线缩小图片大小（免费） (freecompress.com)\n","categories":["工具"],"tags":["工具"]},{"title":"英语四级分值评估标准","url":"/2023/09/17/learnnote/ying-yu/ying-yu-si-ji-fen-zhi-ping-gu/","content":"\n英语四级总分是710分。\n一、英语四级作文\n说明：写作部分占整套试卷的15% =106.5分\n这部分要达到63.9分为及格。\n时间：30分钟\n二、英语四级听力部分 =248.5分\n听力部分占整套试题的35%，除听力篇章外每个题都是7.1分。\n1、短篇新闻 7% 共7小题，每小题7.1分。\n2 、长对话 8% 8个题目 每小题7.1分。\n3、听力篇章 20% 共10个小题，每小题14.2分。\n时间：25分钟。这部分要达到149分为及格，做对14个左右即可。\n三、英语四级阅读理解 35% =248.5分\n阅读部分占整套试题的35%，选词填空每题3.55分，其余每题都是7.1分。\n1、选词填空 5% 10个题，每小题3.55分\n2、长篇阅读 10% 10个题，每小题7.1分。\n3、仔细阅读 20% 10个题 共2篇，一篇5个题，每小题14.2分。\n时间：40分钟 这部分要达到149分为及格，做对18个左右即可。\n四、英语四级翻译部分 汉译英 15% 30分钟 =106.5分\n","categories":["English"],"tags":["English","英语四级"]},{"title":"操作系统复习","url":"/2023/12/28/learnnote/ji-suan-ji-cao-zuo-xi-tong-yuan-li/ji-suan-ji-cao-zuo-xi-tong-fu-xi/","content":"操作系统复习\n操作系统概念、层次\n 操作系统是一种庞大的系统软件，由大量复杂的程序和众多的数据组合而成，他具有层次和模块结构的特点，其内部分为三个层次：操作系统对象、控制和管理的软件集合、用户接口。\n\n操作系统的特征1、并发性\n\n并发性是指两个或两个以上的事件在同一时间间隔内发生。多道程序环境下，计算机系统中同时存在多个进程，宏观上，这些进程同时执行，同时向前推进；微观上，单处理机中任何时刻只能由一个进程在执行，多个进程之间是交替执行的，多处理机中这些进程被分配到多处理机上并行执行。并发的目的是提高系统资源的利用率和系统的吞吐量。\n并发和并行是两个既相似又有区别的概念。并行是从某一时刻去观察，两个或多个事件都在运行。\n\n2、共享性\n\n共享性是指计算机系统中的资源可被多个并发执行的进程使用，而不是被其中某个进程独占使用。根据资源的属性，共享可分为互斥共享和同时共享。\n（1）互斥共享。系统中的资源，如打印机、扫描仪等，在一段时间内只允许一个进程使用。当某个进程使用该资源时，其他进程必须等待，只有当该进程使用完并释放后，其他进程才可以使用该资源，即进程之间排他、互斥地使用共享的资源。\n（2）同时共享。系统中有些资源在同一段时间内允许多个进程同时访问。这里的同时访问是宏观意义上的。\n并发性和共享性是操作系统的两个最基本特征，它们互为存在的条件。一方面，资源共享是以进程的并发执行为存在条件，若系统不允许并发，就不存在资源共享问题。另一方面，若系统不能有效管理共享资源，则将影响进程的并发执行。\n\n3、虚拟性\n\n虚拟性是指通过某种技术，将一个物理实体变成若干个逻辑对应物。物理实体是实际存在的，而逻辑对应物是虚构的，用户使用时感觉有多个实体可供使用。操作系统重采用了多种虚拟技术，如利用多道程序设计技术实现虚拟CPU，通过请求调入调出技术实现虚拟存储器，通过SPOOLing技术实现虚拟设备。\n\n4、异步性\n\n\n产生死锁的原因是什么？如何解除死锁？\n\n产生死锁的原因是因为竞争不可剥夺资源或临时资源时，进程的推进顺序非法。\n处理死锁的基本办法：\n1.预防死锁：破坏产生死锁的四个必要条件的其中一个或多个。\n2.避免死锁：利用算法来避免，比如银行家算法。\n3.检测和解除死锁：回收相应的资源，进行资源的再次分配。\n\n","categories":["期末复习"],"tags":["操作系统"]},{"title":"GFW原理和封锁技术","url":"/2024/02/27/learnnote/ji-suan-ji-wang-luo/gfw-yuan-li-he-feng-suo-ji-zhu/","content":"GFW原理和封锁技术\n一、简介\n计算机的防火墙，和物理意义上的墙并不一样，物理上的墙建立以后，那就既进不来，也出不去了。而计算机的墙，则是可以对两个方向进行控制。\n其实我们今天所说的计算机防火墙，大致有两种，一种是对内的，一种是对外的。\n传统意义上的防火墙，一般是用来防止外部访问的，当然，你也可以设置禁止访问某些IP或者网站，禁止内部访问。\n简而言之，GFW对网络内容的过滤和分析是双向的，GFW不仅针对国内读者访问中国境外的网站进行干扰，也干扰国外读者访问主机在中国大陆的网站。\n我们使用计算机的时候，会开放很多端口，比如22，139，3389等等，而作为非开发者的用户，往往用不到这些端口。 再考虑到使用这些端口的程序有的时候是有漏洞的，开放了容易被攻击，所以干脆打开防火墙封闭了就好。 这就好比你日常宅在家，并不需要出门，就把锁孔都堵死来保证安全一样。\n而我们今天讨论的主角，主要的功能不是阻止别人进来（入侵），而是阻止你出去的。 你访问不了Google/Youtube/Facebook/LINE/Twitter/。。。的根本原因： 防火长城，GreatFireWall，简称GFW。\n每当谈起互联网的历史，都会有一种恍如隔世的感觉，当年上网大部分的网站并不需要注册，博客随便看，甚至可以匿名评论。就算要注册，有个邮箱就够了，不需要实名制（实名制在今天的体现是大部分网站注册都要手机号）。大家在网上大体友善的讨论，无私的分享，自由的交谈。几乎所有的网站不需要VPN即可访问。搜索引擎就管搜索，聊天软件也只聊天，没有那么多弹窗和流氓软件。那是互联网的田园时代。\n和之前的互不联网公司是如何恶心用户的(持续更新)一样，老网虫应该都对这些事情有一些印象，而00后乃至10后可能并不知道这些黑历史。 不论是寿司之神，还是其他顶级的厨师都说过，要想成为好的厨师，首先要吃得出什么是美食。最近辗转反侧，我觉得有必要把这些内容写出来，让人看见，哪怕只是一两个人，告诉大家互联网原来应该是什么样子的，今天为什么是这个样子。\n\n二、墙的历史\n1987年，中国发出了第一封电子邮件：“Across the Great Wall, we can reach every corner in the world”（越过长城，走向世界每个角落）。从那一年开始，我们用互联网和这个世界联系在一起了，但是就在12年后，那个越不过去长城，回来了。\n1998年，为了防止大家访问部分网站，针对IP和DNS的污染，开始了。伴随着污染，墙和梯的较量正式开始。 早期的GFW不能称之为墙，更像是一个补丁，只是单纯的污染DNS，那么我们修改DNS服务器就可以绕过去。 加上国内的DNS也流氓，所以大家大多会把DNS改成Google提供的 8.8.8.8/8.8.4.4。\n这样幼稚的屏蔽方式，政府也知道是不行的，于是，真正的GFW正式登上历史舞台。\n除了屏蔽特定的IP或者域名之类，GFW还会审查流量内容，因为当时大部分的网站都没有用HTTPS进行加密，所以流量是非常透明的，审查起来很容易。 当然，也会对URL进行审查，有一段时间Google无法访问，就是因为URL里面又一个叫gs_rfai的参数，其中“rfa”字样，与在大陆被封锁的自由亚洲电台的网址和英文缩写巧合而被GFW屏蔽。 近几年HTTPS普及了，针对内容审查手段也就慢慢失效了。\n墙的其它升级就简单的多了，主要就是两个任务：\n\n针对IP、域名列表的扩充，扩大黑名单范围；\n对新增的翻墙工具的封堵。\n\n这些是功能上的升级，性能上也在升级，据传说16年，GFW就拥有100多台小型机做的集群了（而且，各地的GFW似乎也没能完美的同步（也可能是故意的），大致是以省为单位，有的时候会出现某个网站只能被某些省访问的情况出现）。\n举些升级的例子：\n\n比如你用HTTP/SOCKS代理翻墙，那我就检测代理的流量特征（于是HTTP/SOCKS代理，卒……）。\n你用SSH翻墙，我就检测你的流量特征，分析你到底是在执行命令，传输文件还是在打隧道翻墙\n但是SSH隧道目前仍然可用，技术角度说，完全区分SSH/SFTP和翻墙流量还是有难度的\n\n\n你用GoAgent翻墙，那我就屏蔽Google的所有IP。\n你用PPTP翻墙，那我就检测PPTP的协议，直接杀。\nOpenVPN也遭遇了PPTP同样的待遇。\n但是AnyConnect没有，因为很多外企在使用它连接公司内网。\nShadowsocks也差点遭受和各大VPN一样的待遇，但是因为SS的流量实在难以识别，所以当时（大约2015年）解决的方式更加粗暴：请Shadowsocks的作者喝茶。详细看下图：\n\n\n\n后来（大约2020年前）Shadowsocks还是被识别了，参见这个报告。\n目前最强大的工具应该是V2Ray，除了支持的协议多，其中的VMess协议对计算机时钟的要求让这个系统可以抵御一定的流量重放攻击。\n最近大家开始用Vultr/Linode搭建服务器……这个的确不好管，但是重要节假日（每年0110月/0100日前后，国庆，两会）就批量屏蔽这些IP。\nGFW不仅防止国内用户访问国外主机，有的时候还会禁止一些境外IP访问国内的主机，这样可以屏蔽部分使用内网穿透技术的人。\n\n\n三、今天我们怎么翻墙\n\nHTTPS代理，TLS给HTTP代理穿上了铠甲，使之又能再战500年。但是考虑到GFW会主动刺探，所以最好将代理的endpoint隐藏在正常网站的某个子路径下。\nSSH隧道，SSH采用非对称加密，再加上有广泛的正常用途（管理服务器）所以目前SSH隧道还是可用的。\nShadowsocks/V2Ray/GoProxy 其实可以理解为对你的代理流量进行加密和混淆的工具，但是GFW在慢慢尝试识别这些流量。\n需要特别说明一下的是，GoProxy比较特殊，支持内网穿透。\n\n\nAnyConnect等商用方案。\n\n除此之外，还有内网穿透等一系列骚操作 当然，这一系列教程不能说翻墙，也不能说科学上网，要说连接公司内网，本质上，在公司外部管理公司内网和翻墙的技术基本一致，但是会多一些诸如混淆之类的不必要操作。然后本文章不会传播翻墙具体教学等，只作为技术分析，私自搭建梯子在国内是违法的，我也不想被请喝茶。\n\n四、我对墙的记忆事实上，我个人没有经历过只有DNS污染这个阶段，我第一次感受到墙的威力，是谷歌退出中国。\n山雨欲来风满楼，事实上，早在2007～2009年，就开始出现一些Google搜索的负面新闻：\n\n据了解，今年１月和４月，“谷歌中国”网站因存在大量淫秽色情和低俗链接，曾两次被互联网违法和不良信息举报中心公开曝光。近期，举报中心又接到公众举报，经核查发现，“谷歌中国”网站仍然存在大量淫秽色情和低俗信息，包括大量极其低级、丑陋的色情图片、视频和文字。 举报中心有关负责人表示，“谷歌中国”网站未按照我国法律法规的要求做好淫秽色情内容的过滤工作，大量境外互联网上的淫秽色情信息通过该网站传播到我境内，严重违反了《全国人大常委会关于维护互联网安全的决定》和国务院《互联网信息服务管理办法》等法律法规，以及有关行业自律规范，严重侵害青少年身心健康，损害公众利益。 举报中心在强烈谴责“谷歌中国”网站的同时，还建议相关执法部门依法处罚，并希望广大网民继续予以监督。\n\n那么这些色情联想是什么呢：\n\n但是后来有人发现，这些词以前都没人搜索，是在新闻播出的前些天才有人搜索，搜索量还全部来自于北京。\n\n我只能说，你们北京人好BT……当时的说法是，这个事情是百度策划的，的确，深入理解搜索引擎，并且能做出有效的内容攻击，怎么看都不像电视台那帮子文科生能做出来的事情。 只可惜Google的日志留的太全了，被发现了。\n很多人说Google退出中国是因为不接受审查，这个是错误的，事实上，Google不是没有配合中国审查，也不只有中国要求Google进行审查。\n10年就有人提问，为啥温度计和胡萝卜都不能搜索了(参见这里)。\n但是按照规则配合审查是不够的，因为根本就没有什么规则，政府对谷歌（当然对其它所有互联网公司都一样）的要求是自我审查。一般来说，还需要配合网信办等神秘机构做一些舆论引导：\n\n这些舆论引导并不合符合政府一般的办事流程，比如发红头文件，通知，办法之类的。 往往就是个微信消息或者邮件，乃至一个电话，但是不设立专门的部门应对这种不规范的办事方式，公司可能就开不下去。\n大致流程就是，你的网站的内容，你自己看着办，我这里只给出精神和模糊的指导意见，但是如果我（政府部门）觉得你内容有问题，那就先约谈，让你再自己琢磨琢磨哪里做错了，要是还是不满意， 我就封鲨你：\n\n简而言之就是：\n\n2010年，Google与政府彻底谈崩了，但是还没等Google关闭服务，首先就遭到了DNS污染，这个时候大家通过修改hosts文件还是可以上Google的，那个时候往上大多流传着好多hosts文件的版本。 后来Google就把google.cn做成了静态页面，指向Google香港，但是随着事态恶化，先是用香港Google搜索国家领导人的时候会自动断开，后来香港的Google也很快不能用了。\n就是从这里开始，我感受到了墙，也就是从这里开始，百度的搜索质量开始下跌，广告越来越多，越来越隐蔽，广告质量也下降，出现很多虚假广告，比如莆田系的医院。这些都是后话了。\n详情可以参考这篇文章，写的相对翔实。\n以及这一篇：深度调查 | 为什么我们不能访问谷歌？(长文慎入) 写的有理有力，调查清晰，证据翔实，部分稍微有些小错误，但是长文难免有纰漏，瑕不掩瑜，我认为值得一读。\n五、墙的设计者说到墙，不得不讨论一下墙的设计者：方滨兴教授，这个人在中文互联网可谓是臭名昭著。 2011年，方滨兴出现在武汉大学，被学生用鞋子和鸡蛋砸。 同年，方滨兴接受采访的时候说，自己电脑上装了6个VPN。 2013年，方滨兴在微博上发了一条拜年微博，转发评论万余次，大多都是“滚”，评论后被和谐，并被水军洗地。 同年，方滨兴说因为身体原因不再担任北邮校长职务，大家在网络上表示：“祝病魔早日战胜校长”。 搜索引擎上搜索方滨兴，有的时候会联想出来“方滨兴死了吗”。 2016年，方滨兴以杰出校友身份，回到其母校哈尔滨工业大学做题为《定义网络空间安全》的报告。报告中，他试图以韩国政府也架设网络防火墙来论证中国架设网络防火墙的必要性。但由于论证其观点的韩国网页被防火墙阻挡，无法登录，方滨兴只能在众目睽睽之下连接VPN绕过大陆的网络防火墙继续演讲。但连接VPN后，1分钟之内便断线2次，只得用Google搜索网页截屏。由于场面尴尬，报告结束后没有安排任何提问环节。\n详细内容可参见Wiki\n对于这个人，我只认可他的一句话：中国防火墙与虚拟专用网VPN之间是场“永恒的战争”。\n六、GFW是怎么拦住我们的？1 关键字过滤阻断\n关键字过滤系统。此系统能够从出口网关收集分析信息，过滤、嗅探指定的关键字。主要针对HTTP的默认端口：80端口，因为HTTP传播的内容是明文的内容，没有经过加密，而GFW是一个IDS(Intrusion detection system)。普通的关键词如果出现在HTTP请求报文的头部(如“Host: www.youtube.com”\\)时，则会马上伪装成对方向连接两端的计算机发送RST包干扰两者正常的TCP连接，进而使请求的内容无法继续查看。如果GFW在数据流中发现了特殊的内文关键词(如轮子，达赖等)时，其也会试图打断当前的连接，从而有时会出现网页开启一部分后突然停止的情况。在任何阻断发生后，一般在随后的90秒内同一IP地址均无法浏览对应IP地址相同端口上的内容。\n\n2 IP地址封锁\nIP地址封锁是GFW通过路由器来控制的，在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往某些被屏蔽的网站的所有IP数据包无法到达。路由器的正常工作方式是学习别的路由器广播的路由规则，遇到符合已知的IP转发规则的数据包，则按已经规则发送，遇到未知规则IP的数据，则转发到上一级网关。\n而GFW对于境外(中国大陆以外)的XX网站会采取独立IP封锁技术。然而部分XX网站使用的是由虚拟主机服务提供商提供的多域名、单(同)IP的主机托管服务，这就会造成了封禁某个IP地址，就会造成所有使用该服务提供商服务的其它使用相同IP地址服务器的网站用户一同遭殃，就算是正常的网站，也不能幸免。其中的内容可能并无不当之处，但也不能在中国大陆正常访问。现在GFW通常会将包含XX信息的网站或网页的URL加入关键字过滤系统，并可以防止民众透过普通海外HTTP代理服务器进行访问。\n\n3 特定端口封锁\nGFW会丢弃特定IP地址上特定端口的所有数据包，使该IP地址上服务器的部分功能(如SSH的22、VPN的1723或SSL的443端口等)无法在中国大陆境内正常使用。\n在中国移动、中国联通等部分ISP(手机IP段)，所有的PPTP类型的VPN都被封锁。\n2011年3月起，GFW开始对Google部分服务器的IP地址实施自动封锁(按时间段)某些端口，按时段对www.google.com(用户登录所有Google服务时需此域名加密验证)和mail.google.com的几十个IP地址的443端口实施自动封锁，具体是每10或15分钟可以连通，接着断开，10或15分钟后再连通，再断开，如此循环，令中国大陆用户和Google主机之间的连接出现间歇性中断，使其各项服务出现问题。GFW这样的封锁手法很高明，因为Gmail并非被完全阻断，这令问题看上去好像出自Google本身。这就是你们认为Google抽风的原因。\n\n4 SSL连接阻断\nGFW会阻断特定网站的SSL加密连接，方法是通过伪装成对方向连接两端的计算机发送RST包(RESET)干扰两者间正常的TCP连接，进而打断与特定IP地址之间的SSL(HTTPS，443端口)握手(如Gmail、Google文件、Google网上论坛等的SSL加密连接)，从而导致SSL连接失败。\n当然由于SSL本身的特点，这并不意味着与网站传输的内容可被破译。\n\n5 DNS劫持和污染\nGFW主要采用DNS劫持和污染技术，使用Cisco提供的IDS系统来进行域名劫持，防止访问被过滤的网站，2002年Google被封锁期间其域名就被劫持到百度。中国部分ISP也会通过此技术插入广告。\n对于含有多个IP地址或经常变更IP地址逃避封锁的域名，GFW通常会使用此方法进行封锁。具体方法是当用户向DNS服务器提交域名请求时，DNS返回虚假(或不解析)的IP地址。\n全球一共有13组根域名服务器(Root Server)，目前中国大陆有F、I这2个根域DNS镜像，但现在均已因为多次DNS污染外国网络，而被断开与国际互联网的连接。\nDNS劫持和污染是针对某些网站的最严重的干扰。\n干扰的方式有两种：\n一种是通过网络服务提供商(Internet Service Provider)提供的DNS服务器进行DNS欺骗，当人们访问某个网站时，需要要把域名转换为一个IP地址，DNS服务器负责将域名转换为IP地址，中国大陆的ISP接受通信管理局的屏蔽网站的指令后在DNS服务器里加入某些特定域名的虚假记录，当使用此DNS服务器的网络用户访问此特定网站时，DNS服务便给出虚假的IP地址，导致访问网站失败，甚至返回ISP运营商提供的出错页面和广告页面。\n另一种是GFW在DNS查询使用的UDP的53端口上根据blacklist进行过滤，遇到通往国外的使用UDP53端口进行查询的DNS请求，就返回一个虚假的IP地址。\n\n6 加密连接的干扰\n加密连接不总是加密的，公钥还是明文的，所以 GFW 就能识别出特定服务的证书。然后在遇到 “黑名单” 加密连接时，它会发送RST数据包，干扰双方正常的 TCP 连接，进而切断加密连接的握手。即使 GWF 有这么多阴招，我们还是有办法的，本文主要也是说这个的。\n\n文章引用：about-firewall/中国网络防火长城简史.md at main · yzxsblog/about-firewall (github.com)\nfq-book/docs/abc/gfw.md at master · hoochanlon/fq-book (github.com)\n","categories":["计算机网络"],"tags":["GFW"]},{"title":"TCP/IP知识","url":"/2024/06/10/learnnote/ji-suan-ji-wang-luo/tcpip-zhi-shi/","content":"TCP/IP知识\n关于TCP/IP\nTCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。 比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。注意：TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族 (也就是整个框架协议)。\n\n\nIP：\nIP所提供的服务通常被认为是无连接的和不可靠的，它将差错控制和流量控制之类的服务授权给了其他的各层协议，这正是TCP/IP 能够高效率工作的一个重要保证。网络层的功能主要由IP来提供，除了提供端到端的分组分发功能外，IP还提供很多扩充功能。例如，为了克服数据链路层对帧大小的限制，网络层提供了数据分块和重组功能，这使得很大的IP数据包能以较小的分组在网络上传输。\nARP：\nARP(Address Resolution Protocol，地址解析协议)用于动态地完成IP地址向物理地址的转换。物理地址通常是指计算机的网卡地址，也称为MAC(Medai Access Control，媒体访问控制)地址，每块网卡都有唯一的地址。\nRARP：\nRARP(Reverse Address Resolution Protocol，反向地址解析协议)用于动态完成物理地址向IP地址的转换。\nICMP：\nICMP(Internet Control Message Protocol，网际控制报文协议)是一个专门用于发送差错报文的协议，由于IP协议是一种尽力传送的通信协议，即传送的数据可能丢失、重复、延迟或乱序传递，所以需要一种尽量避免差错并能在发生差错时报告的机制，这就是ICMP的功能。\nIGMP：\nIGMP(Internet Group Management Protocol，网际组管理协议)允许Internet中的计算机参加多播，是计算机用做向相邻多目路由器报告多组成员的协议。多目路由器是支持组播的路由器，它向本地网络发送IGMP查询，计算机通过发送IGMP报告来应答查询。多目路由器负责将组播包转发到网络中所有组播成员。\n\n1、物理层\n   物理层是OSI模型的第一层，主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。它负责管理电脑通信设备和网络媒体之间的互通。该层传递是比特流，主要的设备有包括了针脚、集线器、中继器、网卡、主机接口卡等。\n2、数据链路层\n  数据链路层主要功能：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame)在信道上无差错的传输。\n在计算机网络中由于各种干扰的存在，物理链路是不可靠的，因此，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。\n数据链路层将比特组合成字节进而组合成帧(frame),通过MAC地址进行寻址，访问介质。\n我们常用的接入交换机(二层交换机)就是工作在这层，交互机连接的设备在同一个广播域，如果想抓某个设备的网络包，就可以使用交换机将电脑和设备互联。\n3、网络层\n​    网络层是七层模型中复杂的，茫茫机海中，两台计算机顺利的牵手就靠网络层，比如我们访问百度，将数据链路层提供的帧转化成数据包(packets)，该数据包包含IP头。通过路径选择、分段组合、顺序、进/出路由等控制，将我们机器的访问信息从我们的机器传送到百度的服务器，这中间经过很多通信子网，也有N个路径可以选择，如何选择一条最优路径，是该层重要的功能。\n在数据链路层，在一个广播域的内部采用的是MAC寻址；在网络层，实现不同的子网平面间采用的IP寻址。所以和IP相关的都是三层，比如我们ping 一个ip地址看通不通，就是看网络层是否连通。\n这层的主要设备就是路由器，熟知的是家庭路由器(现在都被称为wifi)。\n4、传输层\n  传输层起到承上启下的作用，一方面向高层屏蔽下层数据通信的细节，即向用户透明地传送报文，另一方面将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层提供建立、维护和拆除传输连接的功能，跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险，保证报文的正确传输。\n我们通常说的检查下443,80端口通不通，就是指的是传输层端口，今天要讲的TCP/UDP协议就是该层的协议，另外大名鼎鼎的负载LVS也是工作在四层上。\n5、会话层\n  会话层是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。会话控制和远程过程调用均属于这一层的功能。\n6、表示层\n   表示层对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。\n数据的压缩和解压缩， 加密和解密等工作都由表示层负责。\n7、应用层\n应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。应用层为用户提供的服务和协议，比如http，ftp，telnet等。\n在日常工作中，将传输层以上统称为应用层，划分TCP/IP五层模型。\n\n关与路由转发分组\nTCP/IP的体系结构比较简单，它只有四层。路由器在转发分组时最高只用到网络层而没有用到运输层和应用层。如下图所示（==注：==网络接口层就是数据链路层和物理层一起。网际层就是网络层。运输层就是传输层。TCP/IP四层模型中可能会将运输层划分到应用层当中）：\n\n还有一种方法，就是分层次画出具体的协议来表示TCP/IP协议族，应用层和网络接口层都有多种协议，上层的各种协议都向下汇聚到一个IP协议中。这表明，TCP/IP协议可以为各式各样的应用提供服务（everything over IP），同时TCP/IP协议也允许IP协议在各式各样的网络构成的互联网上运行（IP over everything），如下图所示，不难看出IP协议在因特网中的核心作用： \n​    通过下图，利用协议栈的概念来说明在因特网中客户服务器（B/S）的工作方式。\n​    主机A和B都有各自的协议栈。主机A中的应用进程（即客户进程）向主机B应用层的服务进程发出请求，请求建立连接。然后，****主机*B的服务器进程接收A的客户进程发来的请求，然后建立连接。所有的这些通信，都必须使用下面各层所提供的服务*，若仅仅考虑客户进程和服务进程的交互，则如图顶部虚线所示。\n \nICMP协议\nICMP：Internet控制报文协议，通常被认为是IP层的一个组成部分。传递差错报文以及其他需要注意的信息。ICMP报文通常被IP层或更高协议（TCP/UDP）使用。ICMP报文是在IP数据报内被传输的。这里注意ICMP的功能是检错而不是纠错.\n\n\nICMP报文类型\n图中为各种类型的ICMP报文对应类型，不同类型由报文中的类型字段和代码字段共同决定。最后两列则显示此ICMP报文为查询报文还是差错报文，因为ICMP差错报文有时需要做特殊处理，因此我们需要对它们进行区分。当发送一份ICMP差错报文时，报文始终包含IP的首部和产生ICMP差错报文的IP数据报的前8个字节。这样，接收ICMP差错报文的模块就会把它与某个特定的协议和用户进行联系起来。\nICMP地址掩码请求与应答ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码。系统广播它的ICMP请求报文。无盘系统获取子网掩码的另一个方法时BOOTP协议。ICMP地址掩码请求和应答报文的格式如下：\n\nICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。\nICMP时间戳请求与应答\nICMP时间戳请求允许向另一个系统查询当前时间。返回的建议值时自午夜开始计算的毫秒数，协调的统一时间，由于返回的时间是从午夜开始算的，因此调用者必须通过其他方法获取当时的日期，这是它的缺陷。\n\n\n请求端填写发起时间戳，发送报文，应答系统收到请求报文时填写接收时间戳，在发送时填写发送时间戳，但是，实际上，大多数的实现把后面两个字段都设置成相同的值。\nICMP不可达差错ICMP差错报文，即端口不可达报文，它是ICMP目的不可到达报文中的一种。\n\nICMP的一个规则是，ICMP差错报文必须包括生成该差错报文的数据报IP首部，还必须至少包括跟在该IP首部后面的前8个字节\n\nTCP协议\nTCP介绍：TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为：TCP）是一种面向连接的、可靠的、基于字节流的通信协议\nTCP把连接作为最基本的抽象单元，每条TCP连接有两个端点，TCP连接的端点即套接字。套接字socket = （IP地址+端口号）TCP连接={socket1，socket2}={（IP1:port1），（IP2,port2）}TCP提供全双工通信。\n\n\n\n源端口号：本次TCP连接中，发起连接的主机使用的端口号；\n目的端口号：本次TCP连接主，接受连接的主机使用的端口号；\n序号：通过TCP传输的每一个数据段，都有一个序号，作用是为了确认此数据段的顺序。网络中允许传输的数据长度是有限制的，所以当我们要通过TCP传输一个较大的数据时，TCP会将数据切割成很多小的数据段进行传输。而将这些小的数据段发送到目的主机时（发送方会同时发送多个数据），并不能保证它们是按顺序到达目的地，所以对于每一个数据段，都要有一个序号，来标识它们是属于总数据的哪一部分，以保证在目的主机中能将他们重新拼接。\n确认序号：接收方若接收到一个数据段，会发送一个确认报文给发送方，告诉发送方已经接收到这个数据段，而确认序号的作用就是告诉发送方接收到了哪条数据段。若接收方接收到了序号为n的报文段，则确认序号将是n+1，表示它已经接收了n，下一条想要接收n+1；\n首部长度：TCP报文的首部+选项的字节数；\nACK：只有1 bit的标志位，若为1，表示这个数据段中的确认序号是有效的，即这个数据报是对之前接收到的某个报文的确认（一个TCP报文可以同时作为确认报文和传递数据报文）。\nRST：只有1 bit的标志位，若客户端向服务器的一个端口请求建立TCP连接，但是服务器的那个端口并不允许建立连接（比如没开启此端口），则服务器会回送一个TCP报文，将RST位置为1，告诉客户端不要再向这个端口发起连接；\nSYN：只有1 bit的标志位，若为1，表示这是一条建立连接的TCP报文段；\nFIN：只有1 bit的标志位，若为1，表示这是一条断开连接的TCP报文段；\n\n对于TCP报文格式，就先介绍这么多，其余的部分虽然也很重要，但是并没有作用于TCP连接的建立与断开，所以就不在这里叙述了。\n不要将确认序号Ack与标志位中的ACK搞混\n窗口：表示发送/接收缓存窗口大小。如下图：\n\nTCP连接建立与断开为了保证客户端和服务器端的可靠连接，TCP建立连接时必须要进行三次会话，也叫TCP三次握手，进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常。\n举个栗子公安局长王哥 和 陈某打电话\n公安局：你好！陈某，听得到吗？（一次会话）陈某：听到了，王哥，你能听到吗 （二次会话）公安局：听到了，你过来自首吧 （开始会话）（三次会话）\n通过这个例子我们可以知道三次会话的目的就是为了确保双方的连接正常，同理，TCP三次握手也是这个过程。\nTCP建立连接的过程中需要发送三次报文，所以TCP建立连接也被称为三次握手，接下来我就来讲讲这三次握手的过程，假设客户端向服务器发起TCP连接：\n\n第一步：客户端的TCP程序首先向服务器的TCP程序发送一个TCP报文。这个报文不包含数据，且它的SYN标志位被置为1，表示这是一条建立连接的TCP报文段，因此这个报文段也被称为SYN报文段。客户端的TCP程序随机选择一个序号作为客户端报文的初始序号（假设序号为client_isn），放入这个报文段的序号部分。这个报文段由运输层传递到网络层后，被封装在一个IP数据报中发往服务器；\n第二步：包含SYN报文段的IP数据报被服务器接收，服务器的网络层将SYN数据报抽取出来，交给运输层，同时服务器为该TCP连接分配资源（包括发送缓存、接收缓存和变量等），并向客户发送允许连接的TCP报文段。这条允许连接的报文段不包含数据，SYN标志位也被置为1，同时它的ACK标志位也被置为1，表示它是SYN报文段的确认报文，所以这条允许连接的报文段也被称为SYNACK报文段。服务器随机选择一个序号，作为服务器报文段的初始序号（假设称为server_isn），并将其放入SYNACK报文段的序号部分，同时确认号字段被设置为client_isn + 1（SYN报文段的序号+1）。这个报文段可以解释为服务器向客户端说：“我收到了你的连接请求，我允许你连接，我的初始序号是server_isn”。\n第三步：当客户端接收到SYNACK报文段后，它也将为TCP连接分配资源（缓存和变量），同时生成一条SYNACK报文段的确认报文，并发送给服务器。由于经过上面两个步骤，已经算是建立了连接，所以这次的SYN标志位将被置为0，而不是1（ACK标志位是1）。同时，这条报文段的序号被设置为client_isn + 1（第一条客户报文的序号是client_isn，而这是它的下一条，所以+1），而确认序号被设置为server_isn + 1（第一条服务器报文的序号是server_isn，客户端成功接收，所以期望服务器下一次发送server_isn + 1）。和上面两条报文不同，第三条报文可以携带数据，比如HTTP的请求就是在TCP的第三次握手报文中发送到服务器的。\n\n  经过上面这三个步骤，TCP连接就算正式建立完毕，客户端和服务器可以相互发送数据了。下面是这个过程的图片形式：\n\n为什么是三次握手而不是两次  首先我们要明确，两次握手是必要的。第一次握手，客户端将SYN报文发送到服务器，服务器接收到报文后，即可确认客户端到服务器是可达的；而服务器向客户端发送响应的SYNACK报文，客户端接收到后，即可确认服务器到客户端也是可达的。至此，连接已经算是建立，那为什么还要有第三次握手呢？\n  客户端和服务器的握手过程，不仅仅是确认互相可达的过程，更重要的是一个同步的过程，SYN就是同步（Synchronize）的缩写。对于TCP报文段来说，序号是一个至关重要的部分，它保证了TCP传输数据的完整性。而我们上面也说过，TCP报文的初始序号不是从0开始的，而是一个随机的序号，而所谓的同步，就是TCP客户端和服务器互相同步初始序号的过程。第一次握手，客户端发送SYN报文，将自己的初始序号发送到了服务器，服务器接收到后，向客户端发送SYNACK报文段，告诉客户端已经收到了它的初始序号，同时在这个报文段中带上了自己的初始序号。这个时候，第三次握手的作用就出来了：第三次握手实际上就是客户端在告诉服务器，自己已经收到了它的初始序号，完成了同步，可以开始相互传输数据了。若没有第三次握手，服务器将无法保证客户端接收到了自己的SYNACK报文段，若此时SYNACK报文段丢失，客户端不知道服务器的初始序号，将无法处理之后到达客户端的数据。\n  在很多书籍和网上的博客中还流传另外一种说法。若仅仅是两次握手，将产生以下问题：客户端向服务器发送SYN报文段请求建立连接，但是没有在指定时间内收到SYNACK报文段，所以客户端认为SYN报文段在网络中丢失，则再次发送SYN报文段，并成功接收到了SYNACK报文段，但是客户端在很短的时间内就断开了TCP连接。然而，最初的SYN报文并没有丢失，只是传输时延太长，过了许久才到达。等它到达服务器时，其实客户端已经与服务器建立过TCP连接，并且已经断开了。此时服务器接收到这条SYN报文段，以为客户端又想建立一条新的连接，于是向客户端回送ACK报文，并为连接分配了资源。由于没有第三次握手，服务器将不知道这其实是上一次连接的报文，于是将它创建一个新的TCP连接并维持，直至因为太久没有接收到数据而释放。这种情况非常浪费资源，所以为了防止这种情况的发生，才需要客户端的再一次确认。\n  实际上，上面所述的第一点才是TCP三次握手的原因，第二个只能算是顺带的好处吧，从建立连接的报文被称为SYN（同步）就可以看出这点。\nTCP四次挥手的过程  说完了三次握手，下面来说说四次挥手的过程。TCP在断开连接时，客户端与服务器之间要交换四次报文，所以，TCP的断开连接也叫四次挥手。\n\n第一步：客户端进程发出断开连接指令，这将导致客户端的TCP程序创建一个特殊的TCP报文段，发送到服务器。这个报文段的FIN字段被置为1，表示这是一条断开连接的报文；\n第二步：服务器接收到客户端发来的断开连接报文，向客户端回送这个报文的确认报文（ACK字段为1），告诉服务器已经接收到FIN报文，并允许断开连接；\n第三步：服务器发送完确认报文后，服务器的TCP程序创建一条自己的断开连接报文，此报文的FIN字段被置为1，然后发往客户端；\n第四步：客户端接收到服务器发来的FIN报文段，则产生一条确认报文（ACK为1），发送给服务器，告知服务器已经接收到了它的断开报文。服务器接收到这条ACK报文段后，释放TCP连接相关的资源（缓存和变量），而客户端等待一段时间后（半分钟、一分钟或两分钟），也释放处于客户端的缓存和变量；\n\n  以上就是四次挥手的过程，相对建立连接来说要简单一些。以上是以客户端请求断开连接来举例，但其实也可以由服务器断开连接。\n\n客户端为什么要等待一段时间再释放资源看完上面四次挥手的过程，可能有的人会有疑问，四次挥手之后，连接不是已经断开了吗，为什么客户端还要等待一段时间再释放资源呢？原因有两个：\n\n原因一：客户端接收到服务器发送的FIN报文后（第三次挥手），会回送一条确认报文（第四次挥手），但是，客户端并不知道这条确认报文是否可以顺利到达服务器。若这条确认报文在传送到服务器的过程中损坏、丢失或超时，将引起服务器重新发送FIN报文，客户端接收到后，将需要再次发送一条确认报文，直到服务器正确接收。但是，客户端发送确认报文后，立刻释放资源，将导致无法处理重传的FIN报文，所以客户端需要等待一段时间，直到确认没有出现上述情况出现再释放资源。\n原因二：TCP四次挥手完成后，理论上已经断开了连接，但是这不代表之前通过这条连接发送的所有数据都处理完毕了，有些可能还在网络中传输。若在四次挥手后，立即释放客户端的资源，然后客户端立即以同一个源端口，向服务器的同一个目的端口再次建立一个TCP连接，这个连接和上一个的 源端口+源IP+目的端口+目的IP 都一模一样，此时将会产生问题。若上一次连接遗留在网络中的报文此时到达，将会被当做新连接传输的数据处理，于是可能会产生一些不可预估的错误。所以，客户端在断开连接后，需要等待一段时间，直到网络中遗留的数据都死掉，才释放资源，而在资源没有被释放前，是不允许建立一个 源端口+源IP+目的端口+目的IP 都一模一样的TCP连接的（因为TCP套接字由这四部分标识）。\n\n断开连接为什么需要四次挥手  有的人可能也会想，断开连接为什么是四次挥手，不能是两次呢？其中一方请求断开连接，另一方确认即可，为什么这个过程需要两边各发起一次？原因就是：TCP连接是全双工的。什么是全双工，即A与B建立连接，则A可以向B发送数据，而B也可以向A发送数据。\n  我们知道断开连接的请求什么时候发起？当然就是在不再有数据需要发送时。我们依旧以客户端向服务器断开连接为例。假设客户端和服务器建立了一个TCP连接，在客户端需要向服务器发送的数据都发送完后，客户端就可以向服务器发送一个FIN报文段，请求断开连接；服务器接收到后，将会回送一个ACK报文，告诉客户端，自己已经收到了它断开连接的请求。若只有两次挥手，这个时候连接就算是断开了。但是这样真的合理吗？答案当然是否定的。\n  客户端发送完数据后，告诉服务器，我没有数据了，可以和你断开，但是不代表服务器没有数据需要发送到客户端了呀。TCP是一个全双工的连接，代表服务器也有可能有数据需要发送到客户端。所以，只有当两端的数据都发送完毕，连接才能安全的断开。因此，服务器接收到了客户端的FIN报文段，他会等到自己所有的数据发送完，然后也向客户端发送一个FIN报文，告诉客户端我也没数据了，这时候连接才能真正断开，两端各自释放资源。\n关与Wireshark抓包显示的“三次握手问题”\n为什么抓到的 TCP 挥手是三次，而不是书上说的四次？\n\n因为服务器端收到客户端的 FIN 后，服务器端同时也要关闭连接，这样就可以把 ACK 和 FIN 合并到一起发送，节省了一个包，变成了“三次挥手”。\n而通常情况下，服务器端收到客户端的 FIN 后，很可能还没发送完数据，所以就会先回复客户端一个 ACK 包，稍等一会儿，完成所有数据包的发送后，才会发送 FIN 包，这也就是四次挥手了。\n如下图，就是四次挥手的过程：\n\nUDP协议\nUDP协议工作原理UDP（User Datagram Protocol，用户数据报协议）是一种无连接的传输层协议，具有简单、高效的特点，适用于一些对数据可靠性要求不高的应用场景。UDP协议通过将数据分割成小的数据包进行传输，每个数据包都包含源端口号和目标端口号信息，以便接收方能够正确地将数据包交给相应的应用程序。\nUDP协议的工作原理如下：\n发送端：当UDP想要传送数据时，它会抓取来自应用程序的数据，并尽可能快地将其发送到网络上。在这个过程中，UDP不会建立连接，因此无需等待接收方的响应，其传输速度仅受应用程序生成数据的速度、计算机能力和传输带宽的限制。数据包：UDP协议将数据分割成小的数据包，每个数据包都包含源端口号和目标端口号，以及长度和校验和等字段。其中，校验和用于检测数据的完整性，以确保数据在传输过程中没有被损坏。接收端：在接收端，UDP将每个消息段放在队列中，应用程序每次从队列中读取一个消息段进行处理。由于UDP不保证数据的可靠传输，因此接收方需要自行处理可能的数据丢失或乱序问题。\n\n\n16位UDP长度, 表示整个数据报(UDP首部+UDP数据)的最大长度;\n如果校验和出错, 就会直接丢弃;\n\nTCP和UDP的区别\n\n\n\n区别\nudp\ntcp\n\n\n\n面向连接\n面向非连接\n面向连接\n\n\n传输速度\n快\n慢\n\n\n可靠性\n不可靠\n可靠\n\n\n应用场景\n数据量小，对可靠性要求不很高的场景。比如：qq发送消息\n数据量相对较大，对可靠性要求高的场景\n\n\nHttp协议\n（1）首先，http、tcp、udp并不是在一个层（osi七层模型）中，http在应用层，tcp和udp在传输层。\n（2）http是基于tcp的，因为发送http请求时，会先进行tcp三次握手的连接。\n（3）http的长连接与短连接，其实就是tcp的长连接与短连接。http1.1开始默认使用长连接，也就是 connection 默认使用 keep-alive关键字。长连接就是只需要在第一次连接时进行tcp三次握手，接下来就不需要了，可以一直使用这个连接，不会立即关闭，与短连接不同。短连接是，每次client和server进行http操作就建立一个连接，请求结束就中断连接。虽然http1.0支持长连接，但是默认的还是短连接。\nHTTP/1.0是无状态、无连接的应用层协议。\n\n无连接：每次请求都要建立连接，需要使用 keep-alive 参数建立长连接、HTTP1.1默认长连接keep-alive\n无法复用连接，每次发送请求都要进行TCP连接，TCP的连接释放都比较费事，会导致网络利用率低\n\nHTTP/1.1\n\n\n特点\n简单HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解\n灵活、易扩展各类请求方法、URL、状态码，等每个组成都没有固定死，开发者可以自定义与扩充HTTP在应用层其下层可以灵活变化（https就是HTTP与TCP之间增加SSL/TSL安全传输协议）\n应用广泛、支持跨平台\n\n优缺点\n无状态好处：服务器不用额外资源记录，减轻服务器负担，提高CPU内存利用效率坏处：每次都要确认验证信息；一般通过Cookie解决（Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。）\n明文传输： 传输过程中信息可以抓包直接获取，信息暴露、安全性差\n不安全：通信使用明文传输、信息泄露不验证通信双方身份、有可能进入伪装网站无法证明报文完整性都导致不安全的问题\n\n解决方式：可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得更安全。\nHTTP协议层次结构图现在主流浏览器大部分使用的都是HTTP/1.1协议，也有部分支持HTTP/2.0；绝大部分网站都升级为HTTPS更保证安全性\n参考：\n\n《计算机网络——自顶向下方法（原书第七版）》\n多篇博客\n\n","categories":["计算机网络"],"tags":["TCP/IP"]},{"title":"eNSP使用","url":"/2023/12/04/learnnote/ji-suan-ji-wang-luo/ensp-shi-yong/","content":"eNSP使用\n1. 基本概念\n1.VRP概念：通用路由平台，华为公司数据通信产品的通用网络操作系统平台，拥有一致的网络界面、用户界面和管理界面。\n2.VRP作用：通过命令行对设备下发各种命令实现对设备的配置和日常维护操作。\n3.命令行接口（CLI）：用户登录到路由器后出现命令行提示符，是用户与路由器进行交互的常用工具。\n\n什么是WAN口：\n\n广域网接口，连接猫或光猫、入户光纤宽带等外部网络；\n\n什么事LAN口：\n\n本地网接口，连接台式电脑、笔记本，电视机、交换机等内部网络，将一根网线一端连接任意一个LAN口，一端连接自己家里需要联网的设备；\n\n为什么需要VLAN早期以太网是一种基于CSMA/CD（Carrier Sense Multiple Access/Collision Detection）的共享通讯介质的数据网络通讯技术。当主机数目较多时会导致冲突严重、广播泛滥、性能显著下降甚至造成网络不可用等问题。通过二层设备实现LAN互连虽然可以解决冲突严重的问题，但仍然不能隔离广播报文和提升网络质量。\n在这种情况下出现了VLAN技术。这种技术可以把一个LAN划分成多个逻辑的VLAN，每个VLAN是一个广播域，VLAN内的主机间通信就和在一个LAN内一样，而VLAN间则不能直接互通，广播报文就被限制在一个VLAN内。如下图所示。\n\n因此，VLAN具备以下优点：\n\n限制广播域：广播域被限制在一个VLAN内，节省了带宽，提高了网络处理能力。\n增强局域网的安全性：不同VLAN内的报文在传输时相互隔离，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。\n提高了网络的健壮性：故障被限制在一个VLAN内，本VLAN内的故障不会影响其他VLAN的正常工作。\n灵活构建虚拟工作组：用VLAN可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。\n\n常用指令进入用户视图\nsystem-view\n\n\n\n命令视图[Hwawei]下——sysname命令——修改路由器名称。\nsysname R1\n\n命令视图 [ Huawei ]——interface——进入接口视图——配置——return——直接回到用户视图\n接口视图功能：使用ip address 命令配置接口IP地址、子网掩码\n\n1.clock datetime命令：设置当前时间和日期（用户视图）2.clock timezone命令：设置所在时区（命令视图）【注意：一般先配置时区，再配置时间和日期】\n\n关闭烦人的提示信息：\nun in en //关闭烦人的提示信息\n\n\n\n路由配置IP地址：\nint g 0/0/0ip add 192.168.1.1 24\n\n配置PC的春地址与网关：\nip add 192.168.1.2 24gateway 192.168.1.254\n\n\n\n创建VLAN\nvlan 10 //这个意思是创建一个vlan 10组别\n\nvlan batch 10 20 30 //\n\n\n\n进入对应接口并进行管理\nint g 0/0/1 //意思是进入001号接口\n\n配置接口类型为access类型\nport link-type access //配置端口类型\n\n配置当前端口为指定vlan放行\nport default vlan 10 //这里就是指定放行或者说接入vlan10\n\n\n\n配置接口类型为trunk类型\nport link-type trunk //配置端口类型\n\nport trunk allow-pass vlan all  //这个意思就是设置trunk为放行所有的vlan\n\n\n\n关于accss和truck端口的区别：\n\n1、端口用途不同：truck端口为与其它交换机端口相连的VLAN汇聚口，access端口为交换机与VLAN域中主机相连的端口；\n2、trunk一般是打tag标记的，一般只允许打了该tag标记的vlan通过，所以该端口可以允许多个打tag标记的vlan通过，而accss端口一般是untag不大标记的端口，而且一个access vlan端口只允许一个access vlan 通过。\nAccess类型端口：只能属于1个VLAN，一般用于连接计算机端口；\nTrunk类型端口：可以允许多个VLAN通过,可以接收和发送多个VLAN 报文,\n一般用于交换机与交换机相关的接口。\nHybrid类型端口：可以允许多个VLAN通过，可以接收和发送多个VLAN 报文，\n可以用于交换机的间连接也可以用于连接用户计算机。\n\n配置当前接口所属VLAN\nport default vlan 10  //配置接口的所属vlan\n\ndis vlan   //查看vlan配置\n\n\n\n\n\n开启DHCP功能\ndhcp enable\n\n创建IP地址池\nip pool aa\n\n给IP地址池添加IP地址网段\nnetwork 10.1.1.0 mask 24\n\n给ip地址配置网关\ngateway-list 10.1.1.1\n\n配置DNS\ndns-list 1.1.1.1\n\n选择DHCP配置方式\ndhcp select global\n\n查看所有对应端口配置\ndis port vlan //\n\n查看跳表\ntracert xxx.xxx.xxx.xxx \n\n创建链路聚合\nin eth 1 //创建链路聚合，标签为1\n\n进入链路聚合标签\nin eth1 //进入链路聚合标签1\n\n将当前接口添加到指定标签的链路聚合里面\neth 1 //把当前接口加入到标签名称为1的链路聚合里面，记住此指令必须要先进入需要加入的接口才能使用\n\n设定acl\nacl 2000 //这里2000-2999指的是基本aclacl 3000-3999  //这里是高级acl，功能指定更多\n\n详细参考：\n华为-ACL-访问控制列表（基础理论与配置实验详解）_ensp设置acl自动排序-CSDN博客\n设定rule\nrule 1 premit source 172.16.1.0 0.0.0.255//这里意思是允许所有172.16.1.x网段的ip给过\n\n这里一定要注意，默认情况下，是所有流量都给直接通过，所以要拦截的时候一定要注意设定好deny any\n如何配置虚拟用户终端？\n1、进入虚拟用户终点接口\nuer-interface vty 0 4 //进入虚拟用户终端接口,这里0 4代表可以同时有5个用户登录authentication-mode password  //设置认证模式为密码认证set authentication password cipher huawei //设置密码为密文格式的“huawei”user privilege level 3 //设置用户权限等级为3，登录权限范围为0-15，其中0-2只具备用户视图权限，3-15具备系统视图权限（相当于最高权限）\n\n\n\n\n\n\n\naaa模式认证\n\nAAA提供的安全服务具体是指：\n\n认证（Authentication）：是对用户的身份进行验证，判断其是否为合法用户。\n授权（Authorization）：是对通过认证的用户，授权其可以使用哪些服务。\n计费（Accounting）：是记录用户使用网络服务的资源情况，这些信息将作为计费的依据。\n\n\n\n 配置aaa模式，设置账户为 admin 密码为123456（只是为了认证，才是简单密码），并设置用户等级为3\naaauserlocal-user admin password cipher 123456 privilege level 3local-user admin service-type telnet //配置该用户的接类型为telnet\n\n 进入VTY界面，将认证模式修改为aaa\n\n如何设置直接进入控制台就需要密码？\n设置密码：\nuser-interface console 0 //进入控制台set authentication password cipher nihao mimaauthenticcation-mode password 开启mimaidle-timeout 1 //设置时间\n\n取消密码：\nuser-interface console 0 //进入控制台undo authenticcation-mode //取消掉密码\n\n路由如何和交换机通讯（ping通）\n注意！！！ 交换机对应路由相连接的接口一定要配置access，并且一定要绑定一个vlan，这个vlan也必须要有地址。不能使用trunk，不然无效！！！！！！！！！！！！！\n\n三步设置NAT：第一步：建立nat地址访问表（就是从这里出去访问外网的时候，用什么地址）\nnat address-group 1 64.1.1.4 64.1.1.4       //这个意思使用64.1.1.4到64.1.1.4这个区间的地址去访问\n不同Vlan之间通讯\n//交换机可以子接口划分，直接进入子接口0.10，建议与vlan一致[R1]int g0/0/0.10//配置vlan封装结构，（dot1q为IEEE802.1q协议，该子接口属于vlan10）[R1-GigabitEthernet0/0/0.10]dot1q termination vid 10//为该子接口添加ip地址（即vlan10下面所属主机的网关地址）[R1-GigabitEthernet0/0/0.10]ip address 192.168.10.1 24//开启向下arp广播请求功能[R1-GigabitEthernet0/0/0.10]arp broadcast enable //进入子接口0.10，建议与对应的vlan一致[R1-GigabitEthernet0/0/0.10]int g0/0/0.20//配置vlan封装结构，同上[R1-GigabitEthernet0/0/0.20]dot1q termination vid 20//为该子接口添加ip地址，同上[R1-GigabitEthernet0/0/0.20]ip address 192.168.20.1 24//开启广播请求功能，同上[R1-GigabitEthernet0/0/0.20]arp broadcast enable \n\n\n\n终结vlan\ndot1q termination vid 10                    //配置子接口的终结VLAN ID\n\n开启子接口的ARP广播功能\narp broadcast enable\n\n","categories":["计网","组网实习","eNSP"],"tags":["计网","组网实习"]},{"title":"正向代理和反向代理","url":"/2024/03/16/learnnote/ji-suan-ji-wang-luo/zheng-xiang-dai-li-he-fan-xiang-dai-li/","content":"正向代理和反向代理一、代理\n代理就相当于中间商,本来A和B是可以直接连接的,但是此时添加了一个C在中间,A跟B不直接连接,而是通过C作为中介进行连接。最常见的例子就是二手东,其实很多我们租房子时签约的人不是房子的真正房东,而是房东委托的中介,房东不想管事或者房子太多,只靠自己无法进行管理,所以才会通过中介(代理)进行处理,像蛋壳、自如这样的租房软件其实也是中介的一种,真正的房东是直接将房子委托给这样的第三方中介进行出租。\n一个完整的请求是由: client(客户端) -&gt; proxy(代理) -&gt; server(服务端) 组成。\n二、正向代理\n正向代理: 顺着请求的方向进行的代理，即代理服务器它是由你配置为你服务，去请求目标服务器地址。\n举例一: 如我们现在想要访问谷歌,但是由于某些原因,无法直接访问到谷歌,我们可以通过连接一台代理服务器,代理服务将我们的请求提交到谷歌,然后再将谷歌的响应反馈给我们,对于谷歌而言,它只知道有一个请求过来,但是它并不会知道我们是无法直接访问它的。\n\n正向代理的作用:\n\n访问原来无法访问的资源，如google\n可以做缓存，加速访问资源\n对客户端访问授权，上网进行认证\n代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息\n\n三、反向代理\n反向代理: 跟正向代理相反,它是为目标服务器进行服务的,但是请求的流程还是: clieng -&gt; proxy -&gt; server。\n举例: 比如我们访问百度网站，百度的代理服务器对外的域名为 https://www.baidu.com 。具体内部的服务器节点我们不知道。现实中我们通过访问百度的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回,此时,代理服务器对我们客户端来说就充当了提供响应的服务器,但是对于目标服务器来说,它只是进行了一个请求和转发的功能。\n\n反向代理的作用:\n\n保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。\n负载均衡，通过反向代理服务器来优化网站的负载。\n\n四、两者的区别与联系\n正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.\n反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端.\n\n联系:\n1、正向代理中，proxy和client同属一个LAN，对server透明；\n2、反向代理中，proxy和server同属一个LAN，对client透明。\n五、总结\n事实上,正向代理和反向代理的作用都是进行请求和转发,但是为了区别正向代理,所以后出现的就成为反向代理。\n生活中最常见的例子:\n1、正向代理: 卖票的黄牛\n2、反向代理: 出租房的二手东\n文章截自：一文帮你梳理清楚「正向代理和反向代理的区别与联系」 - 知乎 (zhihu.com)\n","categories":["计网"],"tags":["代理","v2ray"]},{"title":"UML类图","url":"/2024/01/02/learnnote/ruan-jian-gong-cheng/uml-lei-tu/","content":"UML类图\n一、UML基础知识扫盲\n1、概念 ： UML这三个字母的全称是Unified Modeling Language，直接翻译就是统一建模语言，简单地说就是一种有特殊用途的语言。\n2、作用 ：UML可帮助我们做软件需求分析和软件设计的工作，是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。\n3、分类1） 静态图 ：主要描绘了类、对象和数据结构及其存在于他们之间的关系。 类图就是其中一种。2）动态图 : 主要描绘执行流程、实体改变状态的方式。例如 ： 流程图3）物理图 ： 描绘库文件、字节文件和数据文件等以及存在于他们之间的关系\n二、如何用类图表示一个类\n类图: 用于描述系统中所包含的类以及它们之间的相互关系，帮助人们简化对系统的理解，它是系统分析和设计阶段的重要产物，也是系统编码和测试的重要模型依据。\nclassDiagramclass PersonPerson: +age intPerson: -mobilePhone StringPerson: #sex charPerson: +speak() void\n\n对应Java如下代码：\npublic class Person {    public int age;    private String mobilePhone;    protected char sex;    public static void speak(){    }}\n\n1、- 是private 的意思，对应私有成员(变量、方法)\n2、+ 是public 的意思，公开给外部访问的成员(变量、方法)\n3、# 是protected的意思，只能在本类或子类访问成员(变量、方法)\n4、UML 规定的属性(Attribute)表达式\n\n   可见性 名称:类型 [ = 缺省值 ]\n其中 :\n1&gt; 可见性 :表示该属性对于类外的元素而言是否可见，         包括公有(public)、私有(private)和受保护(protected)三种，         在类图中分别用符号+、-和#表示\n2&gt; 名称  :表示属性名，用一个字符串表示\n3&gt; 类型  :表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型\n4&gt; 缺省值 :是一个可选项，即属性的初始值。\n\n5、UML方法(Operation)表达式\n\n可见性 名称(参数列表) [ : 返回类型]\n其中 :\n1&gt; 可见性   :  定义与属性的可见性定义相同\n2&gt; 名称     : 即方法名，用一个字符串表示\n3&gt; 参数列表 : 表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“，”隔开\n4&gt; 返回类型 : 是一个可选项，表示方法的返回值类型，             依赖于具体的编程语言，可以是基本数据类型，             也可以是用户自定义类型，还可以是空类型(void)，             如果是构造方法，则无返回类型。\n\n6、内部类的表示\n","categories":["软件工程"],"tags":["UML"]},{"title":"设计模式","url":"/2024/05/19/learnnote/ruan-jian-gong-cheng/she-ji-mo-shi/","content":"设计模式\n一、设计模式简介\n设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。\n二、什么是 GOF（四人帮，全拼 Gang of Four）？\n在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。\n四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n对接口编程而不是对实现编程。\n优先使用对象组合而不是继承。\n\n三、设计模式的使用\n设计模式在软件开发中的两个主要用途。\n开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。\n最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。\n四、设计模式的类型\n根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。\n\n\n\n序号\n模式 &amp; 描述\n包括\n\n\n\n1\n创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。\n工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）\n\n\n2\n结构型模式 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。\n适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）\n\n\n3\n行为型模式 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。\n责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）\n\n\n4\nJ2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。\nMVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）\n\n\n下面用一个图片来整体描述一下设计模式之间的关系：\n\n五、设计模式的优点\n\n提供了一种共享的设计词汇和概念，使开发人员能够更好地沟通和理解彼此的设计意图。\n提供了经过验证的解决方案，可以提高软件的可维护性、可复用性和灵活性。\n促进了代码的重用，避免了重复的设计和实现。\n通过遵循设计模式，可以减少系统中的错误和问题，提高代码质量。\n\n六、设计模式的六大原则\n1、开闭原则（Open Close Principle）\n开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。\n2、里氏代换原则（Liskov Substitution Principle）\n里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n3、依赖倒转原则（Dependence Inversion Principle）\n这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n4、接口隔离原则（Interface Segregation Principle）\n这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。\n5、迪米特法则，又称最少知道原则（Demeter Principle）\n最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n6、合成复用原则（Composite Reuse Principle）\n合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。\n","categories":["软件工程"],"tags":["设计模式"]},{"title":"一元积分","url":"/2024/01/24/learnnote/gao-deng-shu-xue/yi-yuan-wei-fen/","content":"一元微分\n常考题型\n导数和微分的概念\n微分法和导数的计算\n切线问题\n凹凸函数的性质与判断\n求函数在定义域上的单调区间与极值点，凹凸区间与拐点\n求渐进现金的问题。\n\n\n求极限时，当分子抽象为函数，考虑用导数定义求解试试\n导数的定义：设函数$y=f(x)在x_0 的某临域有定义，若极限\\lim\\limits_{△x \\to 0}{x_0+△x \\over △x}$\n==注：== 这里三个△x必须都要一样\n\n 曲线上任意一点处的切线斜率等于该点的横坐标的平方，且曲线过坐标的原点，求曲线的方程\n微分方程的定义：含有未知函数其导数或微分的方程，称之为微分方程\n微分方程通过积分来求解\n方程的阶：含有未知函数导数方程中其导数的最高阶数\n","categories":["数学"],"tags":["微分"]},{"title":"函数","url":"/2023/09/18/learnnote/gao-deng-shu-xue/han-shu/","content":"\n考试内容概要：（一）函数的概念及常见函数（二）函数的性质常考题型与典型例题题型一 函数的性质题型二复合函数\n单调函数一定有反函数，但反之则不然（充分但不必要条件）\n一元二次函数求根公式：\n$\\displaystyle x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$\n定义4\t将幂函数，指数，对数，三角，反三角统称为基本初等函数。了解它们的定义域，性质，图形。\n幂函数\n指数函数\n对数函数\n三角函数\n反三角函数\n定义5\t由常数和基本初等函数经过有限次的加、减乘、除和复合所得到且能用一个解析式表示的函数，称为初等函数。\n常见奇函数$\\sin x、\\tan x、\\arcsin x、\\ln\\frac{1-x}{1+x}、\\ln(x+\\sqrt{1+x^2})、\\frac{e^x-1}{e^x+1}、f(x)-f(-x)$\n常见偶函数\n$x^2、|x|、\\cos x、f(x)+f(-x)$\n相关定理\n奇+奇=奇；\n偶+偶=偶；\n奇x奇=偶\n偶x偶=偶\n奇x偶=奇\n","categories":["数学"],"tags":["函数"]},{"title":"函数、极限、连续","url":"/2023/10/21/learnnote/gao-deng-shu-xue/han-shu-ji-xian-lian-xu/","content":"第一章\t函数、极限、连续\n第一节\n第二节\n极限存在的准则：\n1）夹逼准则：\n\n常用在数列n项和\n\n2）单调有界准则\n\n单调有界数列必有极限。\n单调增、有上界的数列必有极限；\n单调减、有下界的数列必有极限；\n递推关系的数列极限往往可以使用；\n\n第三节\n","categories":["数学"],"tags":["函数","极限"]},{"title":"函数求极限","url":"/2023/09/18/learnnote/gao-deng-shu-xue/han-shu-qiu-ji-xian/","content":"函数求极限\n\n常用的求极限方法（8种）\n方法1 利用基本极限求极限\n方法2 利用等价无穷小代换求极限\n方法3 利用有理运算法则求极限\n方法4 利用洛必达法则求极限\n方法5 利用泰勒公式求极限\n方法6 利用夹逼原理求极限\n方法7 利用单调有界准则求极限\n方法8 利用定积分定义求极限\n\n方法1 利用基本极限求极限1）常用的基本极限   \n\n$\\lim\\limits_{x\\rarr0} \\frac{sin x}{x} = 1$\n$\\lim\\limits_{x\\rarr0}(1+x)^\\frac{1}{x} = e$ \n$\\lim\\limits_{x\\rarr\\infty}(1+\\frac{1}{x})^x=e$ （这里注意一下，比如$\\lim\\limits_{x\\to \\infty}(1+{(\\pm)a \\over x})^x = e^{(\\pm)a}$）\n$\\lim\\limits_{x\\rarr0}\\frac{a^x-1}{x} = \\ln a$\n$\\lim\\limits_{n\\to \\infty}{\\sqrt[n]{n}} = 1$\n$\\lim\\limits_{n\\to \\infty}\\sqrt[n]{a} =1,(a&gt;0)$\n$\\lim\\limits_{x\\to \\infty}{a_n x^n+a_{n-1} x^{n-1}+…+a_1x+a_0 \\over b_mx^m + b_{m-1} x^{m-1}+…+b_1x+b_0} = \\begin{cases}{a_n \\over b_m},n=m,\\ 0,n&lt;m,\\ \\infty, n&gt;m.\\end{cases}$\n$\\lim\\limits_{x \\to \\infty}x^n = \\begin{cases} 0,|x|&lt;1,\\ \\infty, |x|&gt;1, \\ 1,x=1, \\ 不存在, x=-1.\\end{cases}$\n$\\lim\\limits_{n\\to \\infty} e^{nx} = \\begin{cases} 0,x&lt;0,\\ +\\infty,x&gt;0, \\ 1, x=0.\\end{cases}$\n\n2）”$1^{\\infty}$” 型极限常用结论\n\n若$\\lim{\\alpha(x)}=0, \\lim{\\beta{(x)}=\\infty}，且\\lim{\\alpha(x)\\beta(x) = A}$\n则$\\lim{(1+\\alpha(x))^{\\beta(x)}}=e^A$\n可以归纳为以下三步： \n1）写标准形式\t原式=$\\lim{[1+\\alpha(x)]^{\\beta(x)}};$\n2）求极限\t$\\lim{\\alpha(x)\\beta(x)} =A;$\n3）写结果\t原式$=e^A.$\n\n方法2 利用等价无穷小代换求极限（1）代换原则：\n\na）乘除关系可以换\n$若{\\alpha}等价于\\alpha_1 , \\beta 等价于 \\beta_1,则$\n$\\lim{\\alpha \\over \\beta} = \\lim{\\alpha_1 \\over \\beta} = lim{\\alpha \\over \\beta_1}$\nb）加减关系在一定条件下可以换\n$若\\alpha \\sim \\alpha_1 , \\beta \\sim \\beta_1 , 且\\lim{\\alpha_1 \\over \\beta_1} = A  \\neq 1 则 \\alpha-\\beta \\sim \\alpha_1 - \\beta_1.$\n$若\\alpha \\sim \\alpha_1, \\beta \\sim \\beta_1,且 lim{\\alpha \\over \\beta_1} = A \\neq -1, \\alpha + \\beta \\sim \\alpha_1 + \\beta_1.$\n\n（2）常用的等价无穷小：当$x\\to 0$时\n\n$x \\sim sinx \\sim tanx \\sim arcsinx \\sim arctanx \\sim ln(1+x) \\sim e^x-1;$\n$a^x-1 \\sim xlna, ~~~~~~~~~~(1+x)^{\\alpha}-1 \\sim \\alpha x,~~~~~~~~~~ 1-cos^{\\alpha}x \\sim {\\alpha \\over 2}x^2$\n$x-sinx \\sim {1 \\over 6}x^3 ~~~~~~~~~~tanx-x \\sim {1 \\over 3}x^3$\n$arcsinx -x \\sim {1 \\over 6}x^3 ~~~~~~~~~~ x-arctanx \\sim {1 \\over 3}x^3$\n\n\n$x-ln(1+x) \\sim \\frac{1}{2}x^2$\n\n特殊例题注意：\n（2006年2）求极限$\\lim_\\limits{x \\to  0} {1 \\over x^3}[({2+cosx \\over 3})^x-1]$\n\n解2：原式=$\\lim_\\limits{x \\to  0} {1 \\over x^3}[(1+{cosx-1 \\over 3})^x-1]$\n==注：==当$x \\to 0 时,(1+x)^{\\alpha} -1 \\sim \\alpha x . 这个结论推广可得:$\n若$\\alpha(x) \\to 0 , \\alpha(x) \\beta(x) \\to 0,$\n则$(1+\\alpha(x))^{\\beta (x)}-1 \\sim \\alpha (x) \\beta (x)$\n\n方法3 利用有理运算法则求极限有理运算法则\n\n$若\\lim f(x)=A, \\lim g(x)=B,那么(注意两者都是存在极限的意思)：$\n$\\lim(f(x) \\pm g(x))= \\lim f(x) \\pm \\lim g(x)$\n$\\lim(f(x)·g(x)) = \\lim f(x) · \\lim g(x)$\n$\\lim({f(x) \\over g(x)}) = {\\lim f(x) \\over \\lim g(x)} (B \\neq 0)$\n==注：==\n1）$存在 \\pm 不存在 = 不存在；$\n2）$不存在 \\pm 不存在 = 不一定.$\n3）$存在 \\times \\div 不存在 =不一定；$\n4）$不存在 \\times \\div 不存在 = 不一定.$\n\n方法4 利用洛必达法则求极限洛必达法则\n\n若 1）$\\lim_\\limits{x \\to x_0}{f(x)} = \\lim_\\limits{x \\to x_0}{g(x)} = 0 (\\infty);$\n2）$f(x)和 g(x)在x_0的某去心领域内可导，且g’(x) \\neq 0;$\n3）$\\lim_\\limits{x \\to x_0}{f’(x) \\over g’(x)}存在(或 \\infty);$\n$则\\lim_\\limits{x \\to x_0}{f(x) \\over g(x)} = \\lim_\\limits{x \\to x_0}{f’(x) \\over g’(x)}.$\n==注:==$ln|x|求导仍然是{1 \\over x}$\n\n\n==注：==\n1）适用类型$~~~~~~~~~~{0 \\over 0};{\\infty \\over \\infty};0·\\infty;\\infty-\\infty; 1^{\\infty}; \\infty ^0 ; 0^0$\n2）解题思路$~~~~~~~~~~ {0\\over 0} ·{\\infty \\over \\infty} \\Larr {\\begin{cases}0·\\infty {\\Larr \\begin{cases} 1^{\\infty} \\ {\\infty}^0 \\ 0^0 \\end{cases}} \\ \\infty - \\infty \\end{cases}}$\n\n方法5 利用泰勒公式求极限\n$定义（泰勒公式）设f(x)在x=x_0处n阶可导，则$\n$f(x)=f(x_0)+f’(x_0)(x-x_0)+···+{f^{(x)}(x_0) \\over n!}(x-x_0)^n+o(x-x_0)^n$\n几个常用的泰勒公式\n$(1) e^x=1+x+{x^2 \\over 2!}+···+{x^n \\over n!}+ o(x^n)$\n$(2)sinx =x-{x^3 \\over 3!}+···+(-1)^{n-1}{x^{2n-1} \\over (2n-1)!} + o(x^{2n})$\n$(3) cosx= 1-{x^2 \\over 2!}+···+(-1)^n{x^{2n} \\over (2n)!}+ o(x^{2n})$\n$(4) ln(1+x)=x-{x^2 \\over 2}+···+(-1)^{n-1}{x^n \\over n}+o(x^n)$\n$(5) (1+x)^{\\alpha}=1+\\alpha x + {\\alpha (\\alpha -1) \\over 2!}x^2+··· + {\\alpha (\\alpha -1)···(\\alpha -n +1) \\over n!}x^n+o(x^n)$\n\n方法6 利用夹逼原理求极限方法7 利用单调有界准则求极限方法8 利用定积分定义求极限","categories":["数学"],"tags":["函数","极限"]},{"title":"函数的连续性","url":"/2023/12/16/learnnote/gao-deng-shu-xue/han-shu-de-lian-xu-xing/","content":"第三节 函数的连续性\n（一）连续性的概念\n\n\n（二）间断点及其分类1.间断点的定义\n\n\n\n2.间断点的分类\n\n\n\n什么叫做可去间断点：\n\n给定一个函数f (x)，如果x₀是函数f (x)的间断点，并且f (x)在x₀处的左极限和右极限均存在的点称为第一类间断点。 若f (x)在x₀处得到左、右极限均存在且相等的间断点，称为可去间断点。\n\n（三）连续性的运算与性质\n\n\n（四）闭区间上连续函数的性质\n\n\n\n","categories":["数学"],"tags":["函数"]},{"title":"各类函数求导","url":"/2024/01/24/learnnote/gao-deng-shu-xue/ge-lei-han-shu-qiu-dao/","content":"各类函数求导\n常见求导\n","categories":["数学"],"tags":["导数"]},{"title":"对数函数相关内容","url":"/2023/11/17/learnnote/gao-deng-shu-xue/dui-shu-han-shu-xiang-guan/","content":"对数函数相关内容\n基本知识：\n$log_a(1) = 0;$\n$log_a(a)=1;$\n$log_ab*log_ba =1;$\n\n对数运算法则1、两个正数的积的对数，等于同一底数的这两个数的对数的和，即：\n\n $log_a(mn)=log_am+log_an$\n\n2、两个正数商的对数，等于同一底数的被除数的对数减去除数对数的差，即：\n\n$log_a({m\\over n})=log_am-log_an$\n\n3、一个正数幂的对数，等于幂的底数的对数乘以幂的指数，即：\n\n$log_am^n = nlog_am$\n\n4、若式中幂指数则有以下的正数的算术根的对数运算法则:一个正数的算术根的对数，等于被开方数的对数除以根指数，即：\n\n$log_a{\\sqrt[n]{m}} = {1\\over n}log_am$\n\n5、推导\n\n$a^m\\cdot a^n =a^{m+n}(m,n\\in R)$\n${a^m \\over a^n} = a^{m-n}(m,n\\in R)$\n$(a^m)^n= a^{mn}(m,n\\in R)$\n$(ab)^n=a^b\\cdot b^n (n\\in R)$\n$log_aM + log_aN = ?$\n\n","categories":["数学"],"tags":["对数"]},{"title":"极限概念","url":"/2023/10/08/learnnote/gao-deng-shu-xue/ji-xian-de-gai-nian/","content":"$$||a|-|b||&lt;=|a-b|$$\n见到e无穷就注意分左右。\n见到arctan也要注意分左右。\n什么是等价无穷小：等价无穷小意味着：\n\n $$\\lim\\limits_{x\\rarr0}\\frac{a(x)}{b(x)}=1$$\n\n比如:\n\n$$a(x)=x^2 和 b(x)=3x^2$$\n这个都是二阶的，但是它们并非等价无穷小，因为等价无穷小意味着：\n$$\\lim\\limits_{x\\rarr0}\\frac{a(x)}{b(x)}=1$$\n而上面这个例子结果是$$3\\neq1$$\n这就叫同阶不等价无穷小，因为同阶无穷小包括等价无穷小\n\n无穷小的性质\n有限个无穷小的和仍是无穷小。\n有限个无穷小的积仍是无穷小。\n无穷小量与有界量的积仍是无穷小。\n\n无穷大量\n无穷大量的概念，若函数$$f(x)当x\\rarr x_0(或x\\rarr\\infty)时趋于无穷，则称f(x)为x\\rarr x_0(或x \\rarr \\infty)时的无穷大量。$$\n即:若对任意给的的M&gt;0，总存在$$\\delta$$ &gt;0，当\n$$0&lt;|x-x_0|&lt;\\delta时，横有|f(x)|&gt;M$$.\n\n常用的一些无穷大量的比较\n（1）当$$x\\rarr+\\infty时$$\n$$ln^\\alpha x &lt;&lt; x^\\beta &lt;&lt; a^x$$\n其中$$\\alpha&gt;0,\\beta &gt;0 ,a&gt;1$$\n(2)数列里面当$$n\\rarr \\infty时$$\n$$ln^\\alpha n&lt;&lt; n^\\beta &lt;&lt; n! &lt;&lt; n^n$$\n其中$$\\alpha&gt;0,\\beta&gt;0,a&gt;1$$\n\n无穷大量的性质\n（1）两个（有限个）无穷大量的积仍为无穷大量；\n（2）无穷大量与有界变量之和仍为无穷大量。\n\n无穷大量与无界变量的关系：\n1）数列$${x_n}$$是无穷大量：\n$$\\forall M&gt;0,\\exists N&gt;0,当n&gt;N时，恒有|x_n|&gt;M.$$\n2）数列$${x_n}$$是无界变量：\n$$\\forall M &gt;0,\\exists N&gt;0,使|x_N|&gt;M.$$\n$$无穷大量\\Rarr无界变量$$\n\n无穷大量与无穷小量的关系\n在同一极限过程中，如果$f(x)$是无穷大，则$\\frac{1}{f(x)}$是无穷小；反之，如果$f(x)$是无穷小，且$f(x)\\ne 0$，则$\\frac{1}{f(x)}$是无穷大；\n\n","categories":["数学"],"tags":["极限"]},{"title":"导数的定义","url":"/2024/01/24/learnnote/gao-deng-shu-xue/gao-shu-2-1-dao-shu-de-ding-yi/","content":"高数2-1 导数的定义\n常考题型与典型例题：\n1.导数定义；==难点==\n2.复合函数、隐函数、参数方程求导；\n3.高阶导数;==难点==\n4.导数应用;\n\n斜率和导数导数（Derivative），也叫导函数值。又名微商，是微积分学中重要的概念。导数其实就是函数在某一个点的斜率，或者可以说成是该点的瞬时变化率。\n（一）导数与微分的概念1.导数的概念\n定义1（导数）$f’(x_0)= \\lim_\\limits{△x \\to 0}{△y \\over △x} = \\lim_\\limits{△x \\to 0}{f(x_0 + △x)-f(x_0) \\over △x}$\n$f’(x_0) = \\lim_\\limits{x \\to x_0}{f(x)-f(x_0) \\over x-x_0}$\n定义2（左导数）$f’-(x_0)= \\lim\\limits{△x \\to 0^-}{△y \\over △x} = \\lim_\\limits{△x \\to 0^-}{f(x_0 + △x)-f(x_0) \\over △x}$\n定义3（右导数）$f’+(x_0) = \\lim\\limits{△x \\to 0^+}{△y \\over △x} = \\lim_\\limits{△x \\to 0^+}{f(x_0 + △x)-f(x_0) \\over △x}$\n定理1 可导的充要条件：左右导数都存在且相等。左右导数都存在且相等才能推出可导。\n\n即：$可导\\Lrarr 左右导数都存在且相等$\n\n定义4（区间上可导及导函数） \n\n给一个(a，b)区间上可导是指在这个区间内每个点都有导数，我们就称为在这个区间上可导。\n\n（一） 导数的定义例：(1994年3)已知$f’(x_0)=-1，则\\lim_\\limits{x \\to 0}{x \\over f(x_0-2x)-f(x_0 - x) }= ?.$\n==注==：如果只只需要答案的题目可以使用具体函数法来解这种题。但是具体函数法不能使用在解答题！！！\n\n\n\n\n例20注意，这题考的是导数定义的逆向推导，而是否可导必须要满足其全部条件才行，即：可以通过其导基本形式，其中可变项必须是趋于0并且不等于0，而且其中趋于0必须满足正负的趋于，不能是单边。\n\n微分的概念\n$定义5（微分）如果△y=f(x_0 +△x)- f(x_0)可以表示为$\n$△y=A△x+ o(△x)~~~~~~~~~~~~~(△x \\to 0)$\n==注：==这里$o(△x)$指的是$△x$的高阶无穷小\n$则称函数f(x)在点x_0 处可微，称 A△x为微分，记为$\n$dy=A△x$\n微分其实就是函数该变量的近似值\n\n","categories":["数学"],"tags":["导数"]},{"title":"BFS算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/bfs/","content":"BFS\n介绍：\nBFS中文叫做广度优先搜索，BFS算是暴力搜索的其中一种算法，这个算法主要还是可以解决一些最小路径的问题，以及搜索问题，比如迷宫问题等等，其主要思想就是通过穷举所有可能走的路并找到答案或者试出最优答案，不过他相对于DFS说其有点就在于广撒网，时间复杂度要比DFS低。\n\nJava代码模板：\n/** * @description: TODO * @author 长白崎 * @date 2023/3/25 17:42 * @version 1.0 */import java.util.LinkedList;import java.util.Queue;/** * BFS算法模板，BFS算法的模板写法主要分为这几步骤： * 1、选择BFS的实现方式，一般有两种，一种是基于队列，一种是基于栈。 * 2、判断是否到达要求条件 * 3、穷举所有可能走的方向 * 4、通过第2步穷举的方向然后去走，当然走之前还要过滤那些不合格的方向，比如这这个方向的下一步走过了，不能再走了，或者这个方向的下一步有墙也不能走等， *    实际的拦截条件根据题目要求添加。 * 5、最后将能走的入队或入栈。 * 因为BFS的算法的特性，基于队列的BFS第一次所搜索到的路径就是最短路径。 * 警告：如果你是想想通过BFS去查找最优步数以及最优路径推荐选择基于队列，基于栈可能出毛病。 */public class Main {    public static void main(String[] args) {        int map[][] = new int[20][20]; //这个数组就是地图        int state[][] = new int[map.length][map[0].length]; //这个数组充当标记走过的路的数组        int minStep = bfs(map,0,0,19,19); //这里返回的值是从起点到终点的最小步数    }    public static int bfs(int map[][]/*传入地图,0为可以走，1为墙*/,int nx/*起点x坐标*/,int ny/*起点的y坐标*/,int ex/*终点的x坐标*/,int ey/*终点的y坐标*/){        Queue&lt;int[]&gt; data = new LinkedList&lt;&gt;(); //用于BFS的队列，这里也可以改成栈        int state[][] = new int[map.length][map[0].length]; //用于记录走过状态的数组，0为未走过，1为走过        data.add(new int[]{nx,ny,0}); //将起点加入到队列        state[ny][nx]=1; //将起点标记为走过        int minStep =Integer.MAX_VALUE; //用于记录到达终点的最小步数        while(!data.isEmpty()){            int point[] = data.poll(); //出队(栈)            //判断是否到达终点            if(point[0]==ex &amp;&amp; point[1]==ey){                minStep = Math.min(point[2],minStep); //更新最小步数                break;            }            //穷举所有可能走的方向            int next[][] ={                    {point[0],point[1]-1},//上                    {point[0],point[1]+1},//下                    {point[0]-1,point[1]},//左                    {point[0]+1,point[1]},//右            };            for(int i= 0 ; i&lt; next.length ; ++i){                //过滤数组越界                if(next[i][0]&lt;0 || next[i][1]&lt;0 || next[i][1]&gt;=map.length || next[i][0]&gt;=map[0].length)                    continue;                //过滤障碍物，比如墙                if(map[next[i][1]][next[i][0]]==1)                    continue;                //过滤走过的格子                if(state[next[i][1]][next[i][0]]==1)                    continue;                //其他附加过滤条件可以根据题目要求做调整                //......                state[next[i][1]][next[i][0]]=1; //将即将要走的格子标记为走过                data.offer(new int[]{next[i][0],next[i][1],point[2]+1}); //将要走的格子加入到队列            }        }        return minStep;    }}\n","categories":["数据结构与算法","算法模板"],"tags":["算法","BFS"]},{"title":"BinarySearch","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/binarysearch/","content":"BinarySearch\n说明：\nBinarySearch中文又叫做二分查找，这是一种查找类的算法，但是其使用是有一定的限制的，那就是必须要区间类必须要满足相应的单调性，不然的话是无法使用的。\n\nJava代码模板：整形二分：\n//这是一个Java整数二分模板public static void binarySearch(){\t//l为二分的左值，r为二分的右值，mid为二分的中间值    int l=0,r=100,mid;    //这里的l&lt;=r为二分的结束条件    while(l&lt;=r){        //计算二分的mid        mid = (l+r)&gt;&gt;1;        //这里的check函数主要的作用就是通过已知的必要条件传入check进行综合分析然后判断应该之后的二分是右移还是左移        if(check(Object c))            l = mid+1; //这里是右移        else            r = mid-1; //这里是左移    }}//这个是check函数，check函数的书写需要结合实际来public static void check(Object c){    //......}\n高精度二分：\n//这个是Java的高精度二分public static void BianrySearch(){    //l为这里的左值，r为这里的右值，mid为中值    double l = 0,r=1e11,mid;    //这里不在是和之前整形二分一样的l&lt;r了，这里因为高精度的特性所以必须要写成右值-左值&gt;0.000001，这里的0.000001可以多添一些0别太少就行\twhile(r-l&gt;1e-5) {\t\tmid = (l+r)/2.0;\t\t//这里是check函数，负责根据必要条件镜进行判断是右移还是左移        if(check(Object o))\t\t\tl = mid;//右移\t\telse\t\t\tr =mid;//左移\t}}//check函数public static void check(){    }\nC++代码模板整形二分\n#include&lt;iostream&gt;using namespace std;int main(){    //l为二分的左值，r为二分的右值，mid为二分的中间值    int l = 0,r = 10000,mid=0;    while(l&lt;r){        mid = (r+l+1)&gt;&gt;1;     //计算二分的mid        //这里的check函数主要的作用就是通过已知的必要条件传入check进行综合分析然后判断应该之后的二分是右移还是左移        if(check(mid))            l = mid;//右移        else            r = mid-1; //左移    }        return 0;}//check函数bool check(int mid){    ...    return false;}\n","categories":["数据结构与算法","算法模板"],"tags":["算法","BinarySearch"]},{"title":"DFS算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/dfs/","content":"DFS\n介绍：\nDFS中文叫做深度优先搜索，DFS算是暴力搜索的其中一种算法，这个算法主要还是可以解决一些最小路径的问题，以及搜索问题，比如迷宫问题等等，其主要思想就是通过穷举所有可能走的路并找到答案或者试出最优答案。\n\nJava代码模板：\n/** * @description: TODO * @author 长白崎 * @date 2023/3/25 16:34 * @version 1.0 *//** * DFS算法模板，DFS算法的模板写法主要分为这几步骤： * 1、判断是否到达要求条件 * 2、穷举所有可能走的方向 * 3、通过第2步穷举的方向然后去走，当然走之前还要过滤那些不合格的方向，比如这这个方向的下一步走过了，不能再走了，或者这个方向的下一步有墙也不能走等， *    实际的拦截条件根据题目要求添加。 */public class Main {    static int minStep =Integer.MIN_VALUE; /*这个变量用于存储走到终点最少需要多少步*/    public static void main(String[] args) {        int map[][] = new int[20][20]; //这个数组就是地图        int state[][] = new int[map.length][map[0].length]; //这个数组充当标记走过的路的数组    }    public static void dfs(int map[][]/*传入地图,0为可以走，1为墙*/,int state[][]/*传入标记走过的状态数组，0为未走过，1为走过*/,int nx/*下一步要走的x坐标*/,int ny/*下一步要走的y坐标*/,int ex/*终点的x坐标*/,int ey/*终点的y坐标*/,int step/*当前步数*/){        if(nx==ex &amp;&amp; ny==ey){            minStep = Math.min(minStep,step);            return;        }        int next[][]={                {nx,ny-1},/*上*/                {nx,ny+1},/*下*/                {nx-1,ny},/*左*/                {nx+1,ny}/*右*/        };        for(int i= 0; i &lt; next.length ; ++i){            //过滤越界            if(next[i][0]&lt;0 || next[i][1]&lt;0 || next[i][1]&gt;=map.length || next[i][0] &gt;=map[0].length)                continue;            //过滤墙            if(map[next[i][1]][next[i][0]]==1)                continue;            //过滤走过的情况            if (state[next[i][1]][next[i][0]]==1)                continue;            //其他过滤条件根据题目要求可以持续添加或删减            //......            state[next[i][1]][next[i][0]] =1; //标记为走过            dfs(map,state,next[i][0],next[i][1],ex,ey,step+1);            state[next[i][1]][next[i][0]] =0;//取消标记        }    }}\n","categories":["数据结构与算法","算法模板"],"tags":["算法","DFS"]},{"title":"Dijkstra算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/dijkstra/","content":"Dijkstra\n说明：\nDijkstra算法是一种求图的单元最短路径的算法\n参考视屏：https://www.bilibili.com/video/BV1zz4y1m7Nq\n\nJava代码模板（基于链式向前星，Dijkstra算法时间复杂度O(nlogn)）：\nimport java.util.Arrays;import java.util.PriorityQueue;import java.util.Scanner;/** * Dijkstra模板 * @author 长白崎 * *//*6 91 5 41 6 12 4 62 5 52 6 43 4 23 5 34 5 24 6 71 */public class Dijkstra {\tstatic int cnt = 0;\tfinal static int inf = 0x3f3f3f3f;\tpublic static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tScanner sc = new Scanner(System.in);\t\tint n = sc.nextInt(); //n个点\t\tint m = sc.nextInt(); //m条边\t\t\t\tint head[] = new int[n+1]; //链式向前星头结点\t\tinit(head); //初始化头结点\t\tEdge e[] = new Edge[m*2+1];\t\twhile(m--&gt;0) {\t\t\tint u = sc.nextInt();\t\t\tint v = sc.nextInt();\t\t\tint w = sc.nextInt();\t\t\taddEdge(head, e, u, v, w);//添加边，增加一次代表有向图u-&gt;v;\t\t\taddEdge(head, e, v, u, w); //点对换再增加一次相当于无向图了\t\t}\t\t\t\tint start = sc.nextInt();\t\tint dis[] = dijkstra(head, e,start);\t\tfor(int i=1 ;i&lt;dis.length;++i) {\t\t\tSystem.out.printf(\"%d -&gt; %d 最短距离为： %d\\n\",start,i,dis[i]);\t\t}\t\t\t}\t\t/**\t * Dijkstra核心算法\t * @param head 链式向前的头结点数组\t * @param e 链式向前星的边寄存数组\t * @param start 起点\t * @return 返回start起点到所有其他点的最小距离数组\t */\tpublic static int[] dijkstra(int head[],Edge e[],int start) {\t\tint dis[]=new int[head.length]; Arrays.fill(dis, inf); //创建存储距离的数组并且全都初始化为无穷距离\t\tboolean st[] = new boolean[head.length]; //标记是否走过该点\t\t\t\t//优先队列并且按照权值从小到大排列\t\tPriorityQueue&lt;Node&gt; qu = new PriorityQueue&lt;Node&gt;((a,b)-&gt; a.w-b.w);\t\t\t\t//添加起点到优先队列，因为是起点，所以起点的总距离为0\t\tqu.offer(new Node(start,0));dis[start]=0;\t\twhile(!qu.isEmpty()) {\t\t\tNode u = qu.poll(); //出队，u.u代表是以u为起点，u.w代表以u.u为起点时从start起点到u.u点的最短距离（优先队列性质）\t\t\t\t\t\tif(st[u.u]) continue; //如果该点走过了那么就直接跳过\t\t\tst[u.u] = true; //表示没走过现在开始走，并且先标记为走过\t\t\t\t\t\t//循环遍历以u.u为起点的所有边\t\t\tfor(int i =head[u.u];i!=-1; i=e[i].next) {\t\t\t\tEdge v = e[i]; //下一步要走的终点\t\t\t\tif(u.w+v.w&gt;dis[v.to] || st[v.to])continue; //如果大于寄存在dis数组里面的最小距离或者选择的点已经走过了那么直接continue即可\t\t\t\tdis[v.to] = u.w+v.w;  //更新dis中的start起点到v.to点的最短距离\t\t\t\tqu.offer(new Node(v.to,dis[v.to])); //添加到优先队列里面\t\t\t}\t\t\t\t\t}\t\treturn dis;\t}\t/**\t * 初始化链式向前星的头结点,-1代表结尾\t * @param head 链式向前星头结点数组\t */\tstatic void init(int head[]) {Arrays.fill(head, -1);}\t/**\t * 链式向前星添加边\t * @param u 弧尾\t * @param v 弧头\t * @param w 权值\t */\tstatic void addEdge(int head[],Edge e[],int u,int v,int w) { e[cnt]=new Edge(v,head[u],w);head[u]=cnt++;}\t\tstatic class Edge{\t\tint to,next,w;\t\tpublic Edge(int to,int next,int w ) {\t\t\tthis.to = to; this.next = next;this.w = w;\t\t}\t}\t\tstatic class Node{\t\tint u,w;\t\tpublic Node(int u,int w) {this.u =u;this.w = w;}\t}}\n","categories":["数据结构与算法","算法模板"],"tags":["Dijkstra"]},{"title":"Java大数字运算使用技巧","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/java-da-shu-zi-yun-suan-shi-yong-ji-qiao/","content":"Java大数字运算使用技巧\n说明：\nJava大数字使用技巧,这里只演示BigInteger了，BigDecimal高精度大数字就不演示了(用法基本一样)。\n\nJava代码模板\nimport java.math.BigInteger;public class BigNumber {    public static void main(String[] args) {            }    /**     * 进制转换     */    public void testScale() {                //在构造将函数时，把radix进制的字符串转化为BigInteger        String str = \"1011100111\";        int radix = 2;        BigInteger interNum1 = new BigInteger(str,radix);\t//743        //我们通常不写，则是默认成10进制转换，如下：        BigInteger interNum2 = new BigInteger(str);\t\t\t//1011100111    }    /**     * 大数字的基本运算     * 基本运算:add(),subtract(),multiply(),divide(),mod(),remainder(),pow(),abs(),negate()     */    public void testBasic() {        BigInteger a = new BigInteger(\"13\");        BigInteger b = new BigInteger(\"4\");        int n = 3;        //1.加        BigInteger bigNum1 = a.add(b);\t\t\t//17        //2.减        BigInteger bigNum2 = a.subtract(b);\t\t//9        //3.乘        BigInteger bigNum3 = a.multiply(b);\t\t//52        //4.除        BigInteger bigNum4 = a.divide(b);\t\t//3        //5.取模(需 b &gt; 0，否则出现异常：ArithmeticException(\"BigInteger: modulus not positive\"))        BigInteger bigNum5 = a.mod(b);\t\t\t//1        //6.求余        BigInteger bigNum6 = a.remainder(b);\t//1        //7.平方(需 n &gt;= 0，否则出现异常：ArithmeticException(\"Negative exponent\"))        BigInteger bigNum7 = a.pow(n);\t\t\t//2197        //8.取绝对值        BigInteger bigNum8 = a.abs();\t\t\t//13        //9.取相反数        BigInteger bigNum9 = a.negate();\t\t//-13    }    /**     * 二进制运算(返回类型都为BigInteger，不常用，但有备无患)     */    public void testBinaryOperation() {        BigInteger a = new BigInteger(\"13\");        BigInteger b = new BigInteger(\"2\");        int n = 1;        //1.与：a&amp;b        BigInteger bigNum1 = a.and(b);\t\t\t//0        //2.或：a|b        BigInteger bigNum2 = a.or(b);\t\t\t//15        //3.异或：a^b        BigInteger bigNum3 = a.xor(b);\t\t\t//15        //4.取反：~a        BigInteger bigNum4 = a.not();\t\t\t//-14        //5.左移n位： (a &lt;&lt; n)        BigInteger bigNum5 = a.shiftLeft(n);\t//26        //6.右移n位： (a &gt;&gt; n)        BigInteger bigNum6 = a.shiftRight(n);\t//6    }    /**     * 毕竟大数字之间的大小     */    public void testCompare() {        BigInteger bigNum1 = new BigInteger(\"52\");        BigInteger bigNum2 = new BigInteger(\"27\");        //1.compareTo()：返回一个int型数据（1 大于； 0 等于； -1 小于）        int num = bigNum1.compareTo(bigNum2);\t\t\t//1        //2.max()：直接返回大的那个数，类型为BigInteger        //\t原理：return (compareTo(val) &gt; 0 ? this : val);        BigInteger compareMax = bigNum1.max(bigNum2);\t//52        //3.min()：直接返回小的那个数，类型为BigInteger        //\t原理：return (compareTo(val) &lt; 0 ? this : val);        BigInteger compareMin = bigNum1.min(bigNum2);\t//27    }}\n\n\n","categories":["Java","数据结构与算法"],"tags":["Java","算法","大数字运算"]},{"title":"Java日期类使用技巧","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/java-ri-qi-lei-shi-yong-ji-qiao/","content":"Java日期类使用技巧\n说明：\nJava特有的日期类的使用\n\nJava代码模板：\nimport java.time.Duration;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.temporal.ChronoUnit;public class DateJudge {    public static void main(String[] args) {        LocalDateTime nowDateTime = LocalDateTime.of(2022, 12, 6, 12, 36,25);        // 2.1 int getYear()：获取年份字段。        System.out.println(nowDateTime.getYear()); //2022        // 2.2 Month getMonth()/ int getMonthValue()：获取时间的月份。        System.out.println(nowDateTime.getMonth()); // DECEMBER        System.out.println(nowDateTime.getMonthValue()); //12        // 2.3 int getDayOfMonth()：获取日期在当月中的天数。        System.out.println(nowDateTime.getDayOfMonth()); //6        // 2.4 DayOfWeek getDayOfWeek()：获取日期属于当前周的第几天        System.out.println(nowDateTime.getDayOfWeek()); //TUESDAY        System.out.println(nowDateTime.getDayOfWeek().getValue()); //2        // 2.5  int getDayOfYear()：获取日期时间在当前年的天数。        System.out.println(nowDateTime.getDayOfYear()); //340        //字符串转LocalDateTime        LocalDateTime localDateTime = LocalDateTime.parse(\"2021-01-28 13:12:11\", DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"));        // 3.1 int getHour()：获取当前时间的小时数。        System.out.println(nowDateTime.getHour()); //12        // 3.2 int getMinute()：获取当前时间的分钟。        System.out.println(nowDateTime.getMinute()); //36        // 3.3  int getSecond()：获取当前时间秒数。        System.out.println(nowDateTime.getSecond()); //25        LocalDateTime tempTime = LocalDateTime.of(2021, 7, 6, 11, 36,25);        System.out.println(tempTime); //2021-07-06T11:36:25        System.out.println(\"x = 1年后的日期时间\"+tempTime.plusYears(1)); //x = 1年后的日期时间2022-07-06T11:36:25        System.out.println(\"x = 1月后的日期时间\"+tempTime.plusMonths(1)); //x = 1月后的日期时间2021-08-06T11:36:25        System.out.println(\"x = 1周后的日期时间\"+tempTime.plusWeeks(1)); //x = 1周后的日期时间2021-07-13T11:36:25        System.out.println(\"x = 1天后的日期时间\"+tempTime.plusDays(1)); //x = 1天后的日期时间2021-07-07T11:36:25        System.out.println(\"x = 1小时后的日期时间\"+tempTime.plusHours(1)); //x = 1小时后的日期时间2021-07-06T12:36:25        System.out.println(\"x = 1分钟后的日期时间\"+tempTime.plusMinutes(1)); //x = 1分钟后的日期时间2021-07-06T11:37:25        System.out.println(\"x = 1年前的日期时间\"+tempTime.minusYears(1)); //x = 1年前的日期时间2020-07-06T11:36:25        System.out.println(\"x = 1月前的日期时间\"+tempTime.minusMonths(1)); //x = 1月前的日期时间2021-06-06T11:36:25        System.out.println(\"x = 1周前的日期时间\"+tempTime.minusWeeks(1)); //x = 1周前的日期时间2021-06-29T11:36:25        System.out.println(\"x = 1天前的日期时间\"+tempTime.minusDays(1)); //x = 1天前的日期时间2021-07-05T11:36:25        System.out.println(\"x = 1小时前的日期时间\"+tempTime.minusHours(1)); //x = 1小时前的日期时间2021-07-06T10:36:25        System.out.println(\"x = 1分钟前的日期时间\"+tempTime.minusMinutes(1)); //x = 1分钟前的日期时间2021-07-06T11:35:25        LocalDateTime tempTime1 = LocalDateTime.of(2021, 7, 6, 11, 36,25);        LocalDateTime tempTime2 = LocalDateTime.of(2021, 8, 6, 12, 36,25);        // 5.1 判断tempTime1是否在tempTime2之后，是否比其更晚        boolean after = tempTime1.isAfter(tempTime2); // false        // 5.2 判断tempTime1是否在tempTime2之前，是否比其更早        boolean before = tempTime1.isBefore(tempTime2); //true        // 5.3 判断tempTime1是否与tempTime2相等        boolean equal = tempTime1.isEqual(tempTime2); // false        LocalDateTime changeBeforeTime = LocalDateTime.of(2021, 7, 6, 11, 36,25);        System.out.println(\"修改年份后的日期\" + changeBeforeTime.withYear(2022)); // 修改年份后的日期2022-07-06T11:36:25        System.out.println(\"修改月份后的日期\" + changeBeforeTime.withMonth(11)); // 修改月份后的日期2021-11-06T11:36:25        System.out.println(\"修改当月天数后的日期\" + changeBeforeTime.withDayOfMonth(11)); // 修改当月天数后的日期2021-07-11T11:36:25        System.out.println(\"修改当年天数后的日期\" + changeBeforeTime.withDayOfYear(11)); // 修改当年天数后的日期2021-01-11T11:36:25        System.out.println(\"修改小时后的日期\" + changeBeforeTime.withHour(10)); // 修改小时后的日期2021-07-06T10:36:25        System.out.println(\"修改分钟.秒后的日期\" + changeBeforeTime.withMinute(10).withSecond(10)); //修改分钟.秒后的日期2021-07-06T11:10:10        LocalDateTime beginTime = LocalDateTime.of(2021, 7, 6, 11, 36,25);        LocalDateTime endTime = LocalDateTime.of(2021, 9, 8, 01, 56,25);        // 相差的年份数        long betweenYears = ChronoUnit.YEARS.between(beginTime, endTime);        System.out.println(betweenYears);  // 0        // 相差的月份数        long betweenMonths = ChronoUnit.MONTHS.between(beginTime, endTime);        System.out.println(betweenMonths);  // 2        // 相差的天数        long betweenDays = ChronoUnit.DAYS.between(beginTime, endTime);        System.out.println(betweenDays);  // 63        // 相差的小时数        long betweenHours = ChronoUnit.HOURS.between(beginTime, endTime);        System.out.println(betweenHours); //1526        // 相差的分钟数        long betweenMinutes = ChronoUnit.MINUTES.between(beginTime, endTime);        System.out.println(betweenMinutes);//91580        // 相差的秒钟数        long betweenMillis = ChronoUnit.MILLIS.between(beginTime, endTime);        System.out.println(betweenMillis);//91580        Duration between1 = Duration.between(beginTime, endTime);        System.out.println(between1.toDays()); // 63        System.out.println(between1.toHours()); //1526 (63天*24小时+(24+1-11)不是整天的小时数)        System.out.println(between1.toMinutes()); // 91580 (1526小时*60分钟+（56-25）分钟外相差的秒数)        System.out.println(between1.toMillis()); // 5494800000    }}\n","categories":["Java","数据结构与算法"],"tags":["Java","算法","日期使用技巧"]},{"title":"KMP算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/kmp/","content":"KMP\n说明：\nKMP算法其实主要的作用就是匹配子字符串，就比如：\n父串：aabacdca\n子串：acd\n这里我们要查找父串中是否有子串，那么就可以用KMP算法。\n而KMP算法其实有点像一个状态机，或者说一个dp？\n其主要特点还是记录转态回溯。\nKMP主要难点在于其中next数组的计算。next数组的计算方式是“前缀和后缀公共部分的最大长度”。比如一个字符串ababa，他的前缀是可以是a，ab，aba，abab（不包含最后一位），后缀是a，ba，aba，baba（不包含第一位）。\n\nJava代码模板：\n/** * @description: KMP算法 * KMP是一种字符串匹配算法，他是一种时间复杂度低，比较优秀的一种字符串匹配算法，一般可以拿来做一下字符串匹配类的题目。他与一般的暴力匹配比较其有点就是 * 有记录和回溯子串的功能，相比普通的暴力匹配减少了很多没必要的匹配次数，其思想概念有点类似于dp，和简单状态机。 * @author 长白崎 * @date 2023/3/28 0:28 * @version 1.0 */import java.util.Arrays;import java.util.Scanner;public class KMP {\tpublic static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tScanner sc = new Scanner(System.in);\t\t\t\t//String s = sc.next();\t\tString pat = sc.next();\t\t\t\tint next[] = new int[pat.length()];\t\t\t\tbuildNext(pat.toCharArray(), next);\t\tSystem.out.println(Arrays.toString(next));\t\t//System.out.println(kmp(s.toCharArray(),pat.toCharArray(),next));\t\t\t}\t\t\t\tpublic static int kmp(char s[],char pat[],int next[]) {\t\t\t\t\t\tint j=0;\t\tfor(int i=0 ; i&lt;s.length ; ++i) {\t\t\twhile(j&gt;0 &amp;&amp; s[i]!=pat[j]) j =  next[j-1];\t\t\tif(s[i]==pat[j]) ++j;\t\t\tif(j==pat.length) return i-pat.length+1;\t\t}\t\treturn -1;\t}\t\tpublic static void buildNext(char pat[],int next[]) {\t\t\t\tint i = 0;\t\tfor(int j=1; j &lt; pat.length ; ++j) {\t\t\twhile(i&gt;0 &amp;&amp; pat[i]!=pat[j]) i = next[i-1];\t\t\tif(pat[i]==pat[j]) ++i;\t\t\tnext[j] = i;\t\t}\t\t\t}}\n","categories":["数据结构与算法"],"tags":["算法","KMP"]},{"title":"Java正则使用技巧","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/java-zheng-ze-shi-yong-ji-qiao/","content":"Java正则使用技巧\n说明：\nJava正则使用\n\nJava代码模板：\nimport java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches{    public static void main( String[] args ){       // 按指定模式在字符串查找      String line = \"This order was placed for QT3000! OK?\";      String pattern = \"(\\\\D*)(\\\\d+)(.*)\";       // 创建 Pattern 对象      Pattern r = Pattern.compile(pattern);       // 现在创建 matcher 对象      Matcher m = r.matcher(line);      if (m.find( )) {         System.out.println(\"Found value: \" + m.group(0) );         System.out.println(\"Found value: \" + m.group(1) );         System.out.println(\"Found value: \" + m.group(2) );         System.out.println(\"Found value: \" + m.group(3) );       } else {         System.out.println(\"NO MATCH\");      }   }}\n\n\n\n字符\n说明\n\n\n\n\\\n将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如， n匹配字符 n。\\n 匹配换行符。序列 \\\\ 匹配 \\ ，\\( 匹配 (。\n\n\n^\n匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\\n”或”\\r”之后的位置匹配。\n\n\n$\n匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\\n”或”\\r”之前的位置匹配。\n\n\n*\n零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。\n\n\n+\n一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。\n\n\n?\n零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。\n\n\n{n}\nn 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。\n\n\n{n,}\nn 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。\n\n\n{n,m}\nm 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。\n\n\n?\n当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。\n\n\n.\n匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。\n\n\n(pattern)\n匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。\n\n\n(?:pattern)\n匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。\n\n\n(?=pattern)\n执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n\n\n(?!pattern)\n执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。\n\n\nx|y\n匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。\n\n\n[xyz]\n字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。\n\n\n[^xyz]\n反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。\n\n\n[a-z]\n字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。\n\n\n[^a-z]\n反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。\n\n\n\\b\n匹配一个字边界，即字与空格间的位置。例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。\n\n\n\\B\n非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。\n\n\n\\cx\n匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。\n\n\n\\d\n数字字符匹配。等效于 [0-9]。\n\n\n\\D\n非数字字符匹配。等效于 [^0-9]。\n\n\n\\f\n换页符匹配。等效于 \\x0c 和 \\cL。\n\n\n\\n\n换行符匹配。等效于 \\x0a 和 \\cJ。\n\n\n\\r\n匹配一个回车符。等效于 \\x0d 和 \\cM。\n\n\n\\s\n匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。\n\n\n\\S\n匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。\n\n\n\\t\n制表符匹配。与 \\x09 和 \\cI 等效。\n\n\n\\v\n垂直制表符匹配。与 \\x0b 和 \\cK 等效。\n\n\n\\w\n匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。\n\n\n\\W\n与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。\n\n\n\\xn\n匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。\n\n\n*num*\n匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。\n\n\n*n*\n标识一个八进制转义码或反向引用。如果 *n* 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。\n\n\n*nm*\n标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 *nm* 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。\n\n\n\\nml\n当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。\n\n\n\\un\n匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。\n\n\n(?!)n\n匹配 n并且不区分大小写。\n\n\n\n根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\\b” 与单个退格字符匹配，而 “\\b” 与单词边界匹配。字符串字面值 “(hello)“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\\(hello\\)”。\n\nMatcher 类的方法索引方法索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：\n\n\n\n序号\n方法及说明\n\n\n\n1\npublic int start() 返回以前匹配的初始索引。\n\n\n2\npublic int start(int group)  返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引\n\n\n3\npublic int end() 返回最后匹配字符之后的偏移量。\n\n\n4\npublic int end(int group) 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。\n\n\n查找方法查找方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：\n\n\n\n序号\n方法及说明\n\n\n\n1\npublic boolean lookingAt()  尝试将从区域开头开始的输入序列与该模式匹配。\n\n\n2\npublic boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列。\n\n\n3\npublic boolean find(int start） 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。\n\n\n4\npublic boolean matches() 尝试将整个区域与模式匹配。\n\n\n替换方法替换方法是替换输入字符串里文本的方法：\n\n\n\n序号\n方法及说明\n\n\n\n1\npublic Matcher appendReplacement(StringBuffer sb, String replacement) 实现非终端添加和替换步骤。\n\n\n2\npublic StringBuffer appendTail(StringBuffer sb) 实现终端添加和替换步骤。\n\n\n3\npublic String replaceAll(String replacement)  替换模式与给定替换字符串相匹配的输入序列的每个子序列。\n\n\n4\npublic String replaceFirst(String replacement)  替换模式与给定替换字符串匹配的输入序列的第一个子序列。\n\n\n5\npublic static String quoteReplacement(String s) 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。\n\n\nstart 和 end 方法下面是一个对单词 “cat” 出现在输入字符串中出现次数进行计数的例子：\nRegexMatches.java 文件代码：import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {        private static final String REGEX = \"\\\\bcat\\\\b\";        private static final String INPUT = \"cat cat cat cattie cat\";         public static void main( String[] args ){               Pattern p = Pattern.compile(REGEX);               Matcher m = p.matcher(INPUT); // 获取 matcher 对象               int count = 0;                while(m.find()) {                     count++;                     System.out.println(\"Match number \"+count);                     System.out.println(\"start(): \"+m.start());                     System.out.println(\"end(): \"+m.end());              }       } }\n\n\n\n以上实例编译运行结果如下：\nMatch number 1start(): 0end(): 3Match number 2start(): 4end(): 7Match number 3start(): 8end(): 11Match number 4start(): 19end(): 22\n\n可以看到这个例子是使用单词边界，以确保字母 “c” “a” “t” 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。\nStart 方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end 方法最后一个匹配字符的索引加 1。\nmatches 和 lookingAt 方法matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。\nlookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。\n这两个方法经常在输入字符串的开始使用。\n我们通过下面这个例子，来解释这个功能：\nRegexMatches.java 文件代码：import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {        private static final String REGEX = \"foo\";        private static final String INPUT = \"fooooooooooooooooo\";        private static final String INPUT2 = \"ooooofoooooooooooo\";        private static Pattern pattern;        private static Matcher matcher;        private static Matcher matcher2;             public static void main( String[] args ){               pattern = Pattern.compile(REGEX);               matcher = pattern.matcher(INPUT);               matcher2 = pattern.matcher(INPUT2);                System.out.println(\"Current REGEX is: \"+REGEX);               System.out.println(\"Current INPUT is: \"+INPUT);               System.out.println(\"Current INPUT2 is: \"+INPUT2);                 System.out.println(\"lookingAt(): \"+matcher.lookingAt());               System.out.println(\"matches(): \"+matcher.matches());               System.out.println(\"lookingAt(): \"+matcher2.lookingAt());       } }\n\n\n\n以上实例编译运行结果如下：\nCurrent REGEX is: fooCurrent INPUT is: foooooooooooooooooCurrent INPUT2 is: ooooofoooooooooooolookingAt(): truematches(): falselookingAt(): false\n\nreplaceFirst 和 replaceAll 方法replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。\n下面的例子来解释这个功能：\nRegexMatches.java 文件代码：import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {        private static String REGEX = \"dog\";        private static String INPUT = \"The dog says meow. \" +\"All dogs say meow.\";        private static String REPLACE = \"cat\";            public static void main(String[] args) {               Pattern p = Pattern.compile(REGEX);               // get a matcher object               Matcher m = p.matcher(INPUT);                INPUT = m.replaceAll(REPLACE);               System.out.println(INPUT);       } }\n\n\n\n以上实例编译运行结果如下：\nThe cat says meow. All cats say meow.\n\nappendReplacement 和 appendTail 方法Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换：\n看下面的例子来解释这个功能：\nRegexMatches.java 文件代码：import java.util.regex.Matcher; import java.util.regex.Pattern;  public class RegexMatches {       private static String REGEX = \"a*b\";       private static String INPUT = \"aabfooaabfooabfoobkkk\";       private static String REPLACE = \"-\";       public static void main(String[] args) {              Pattern p = Pattern.compile(REGEX);              // 获取 matcher 对象              Matcher m = p.matcher(INPUT);              StringBuffer sb = new StringBuffer();              while(m.find()){                     m.appendReplacement(sb,REPLACE);              }              m.appendTail(sb);              System.out.println(sb.toString());       } }\n\n\n\n以上实例编译运行结果如下：\n-foo-foo-foo-kkk\n\nPatternSyntaxException 类的方法PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。\nPatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。\n\n\n\n序号\n方法及说明\n\n\n\n1\npublic String getDescription() 获取错误的描述。\n\n\n2\npublic int getIndex()  获取错误的索引。\n\n\n3\npublic String getPattern() 获取错误的正则表达式模式。\n\n\n4\npublic String getMessage() 返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。\n\n\n","categories":["Java","数据结构与算法"],"tags":["Java","算法"]},{"title":"Manacher算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/manacher/","content":"Manacher\n说明：\nManacher算法主要是用于字符串查找最长回文子串，其原理就是在原本的字符串插入其他特殊符号达到把我们所有需要所有需要匹配的回文都变成了奇回文，并且以其奇回文的中点向左右扩散计算其回文长度。\n\nJava代码模板（时间复杂度O(n)）：\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.StringTokenizer;/** *  * @author 长白崎 * */public class ManacherStudy {\tfinal static PrintWriter out = new PrintWriter(System.out);\t\tpublic static void main(String[] args) throws IOException {\t\t// TODO Auto-generated method stub\t\tchar str[] = R.next().toCharArray();\t\t\t\tout.println(manacher(str));\t\tout.flush();\t\tout.close();\t}\t\t/**\t * Manacher核心算法\t * @param str 需要进行判断的字符串\t * @return 返回最长回文子串的长度\t */\tpublic static long manacher(char str[]) {\t\tchar s[] = new char[str.length*2+2];//Manacher处理过后的字符串\t\tint m = 0; s[++m]='#';\t\t\t\tfor(int i=0;i&lt;str.length;++i) {s[++m]=str[i]; s[++m]='#';};\t\t\t\tint p[] = new int[s.length]; //用于寄存p[i]点的回文串长度\t\t\t\t//M为最右回文中间值\t\t//M最长回文中间值,R为右边界，max长回文子串\t\tint M = 0,R=0,max=0;\t\tfor(int i =1;i&lt;=m;++i) {\t\t\t\t\t\tif(i&gt;R) p[i]=1; else p[i]=Math.min(p[2*M-i], R-i+1);\t\t\t\t\t\t//(i-p[i])和(i+p[i])是为了防止越界\t\t\twhile(i-p[i]&gt;=1 &amp;&amp; i+p[i]&lt;=m &amp;&amp; s[i+p[i]]==s[i-p[i]])++p[i];\t\t\tif(p[i]+i-1&gt;R) {M=i;R=i+p[i]-1;} //如果当前回文串的长度超过之前的最大覆盖回文串的长度那么久替换M和R\t\t\tmax= Math.max(max, p[i]);\t\t}\t\t\t\t\t\treturn max-1;\t}\t\tstatic class R{\t\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tstatic StringTokenizer tk = new StringTokenizer(\"\");\t\tpublic static String next() throws IOException {\t\t\twhile(!tk.hasMoreTokens()) {\t\t\t\ttk = new StringTokenizer(br.readLine());\t\t\t}\t\t\treturn tk.nextToken();\t\t}\t}}\nC++模板(时间复杂度O(n)):#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int N = 2.2e7+5;string n;char s[N];int p[N];int manacher(){    int m =0;s[++m]='#';    for(int i=0;i&lt;n.length();++i){s[++m]=n[i];s[++m]='#';}    int M=0,R=0,mx=0;    for(int i =1;i&lt;=m;++i){        if(i&gt;R)p[i]=1;else p[i]= min(p[2*M-i],R-i+1);        while(i-p[i]&gt;=1 &amp;&amp; i+p[i]&lt;=m &amp;&amp; s[i-p[i]]==s[i+p[i]]) ++p[i];        if(i+p[i]-1&gt;R) M=i,R=i+p[i]-1;        mx=max(mx,p[i]);    }    return mx-1;}int main(){    cin &gt;&gt; n;    cout &lt;&lt; manacher()&lt;&lt;endl;    return 0;}\n\n\n\n","categories":["数据结构与算法"],"tags":["算法","Manacher"]},{"title":"Kruskal算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/kruskal/","content":"Kruskal\n介绍：\nKruskal算法是一种基于图的算法，他的主要作用就是找出图中的最小生成树，这个算法会在一些比如铺设电网最小开销等问题上有相应的应用。\n\nJava代码模板：\n/** * @description: TODO * @author 长白崎 * @date 2023/3/25 18:00 * @version 1.0 */import java.util.ArrayList;import java.util.Arrays;import java.util.Random;/** * Kruskal算法的思想其实很简单，但是了其核心难点在于如何查出闭环，而查闭环这一步骤需要用到一个算法，那就是并查集算法，如果还没有了解过并查集算法的同学可以先去了解一下 * 以下是Kruskal算法的主要步骤： * 1、首先就是先整理好所有的结点，这里的话比如把所有结点都加入到一个数组或者一个集合里面,但是这里一定要注意，那就是数组或集合对应的下标一定要对应相应的Point类里面的table标签值，不然会出问题。 * 2、用一个集合存所有边，也就是题目里面输入的所有点到点的边 * (这里一定要特别注意！！！！！边的起点和结束点标签一定要有规律，比如你要么起始结点的标签比结束标签的结点大，要么小，千万别搞混了) * 3、对所有的边基于他的长度或者说成本进行从小到达排序 * 4、基于第三步拿到排序后的边的集合后逐一遍历选取边进行连接。当然，这里要主要在进行连接的同时要先检验所选边是否会形成回路，这里就要用到并查集算法了 */public class Main {    public static void main(String[] args) {        //以下为测试集，不用理睬。。。。。。        Point point[] = new Point[10];        point[0] = new Point(1,3,0);        point[1] = new Point(4,7,1);        point[2] = new Point(3,10,2);        point[3] = new Point(9,4,3);        point[4] = new Point(12,2,4);        point[5] = new Point(11,2,5);        point[6] = new Point(12,5,6);        point[7] = new Point(23,7,7);        point[8] = new Point(1,2,8);        point[9] = new Point(6,8,9);        E e[] = new E[9+8+7+6+5+4+3+2+1];        for(int y= 0,i=0; y &lt; point.length ; ++y){            for(int x = y+1; x &lt; point.length ; ++x,++i){                e[i] = new E(point[y],point[x], (int) (Math.random()*100+1));            }        }        kruskal(point,e);    }    public static void kruskal(Point point[]/*所有的点*/,E e[]/*所有的边*/){        //定制化排序对存边的数组基于他的长度进行从小到大排序。        Arrays.sort(e,(a,b)-&gt; a.getLen()-b.getLen());        //并查集用的数组，下标代表子结点，对应下标存的内容代表父结点        int parent[] = new int[point.length];        for(int i = 0 ; i&lt; parent.length ; ++i) parent[i] =i; //初始化并查集的数组        ArrayList&lt;E&gt; selectE = new ArrayList&lt;&gt;(); //这个用来存选的边        for(int i= 0 ; i&lt; e.length ; ++i){            E ne = e[i];            int startRoot = find(parent,ne.getStartPoint().getTable()); //查询起始结点的根结点            int endRoot = find(parent,ne.getEndPoint().getTable()); //查询结束结点的根结点            //如果其实结点和结束的结点的根结点是同一个，那么说明会形成闭环，那就不选这条边            if(startRoot == endRoot)                continue;            //选择该边            parent[startRoot] = endRoot; // 更新并查集父子结点关系            selectE.add(ne); //将边加入到选择的集合当中        }        int ans = 0;        for(int i =0 ; i &lt; selectE.size(); ++i){            System.out.println(selectE.get(i).getStartPoint().getTable()+\"——\"+selectE.get(i).getEndPoint().getTable());            ans+= selectE.get(i).getLen();        }        System.out.println(\"最小生成树的边总长度大小：\"+ans);    }    /**     * 并查集核心算法     * @param parent 代表的是并查集用的数组     * @param point 代表的是需要查的结点的根结点     * @return     */    public static int find(int parent[],int point){        while(parent[point]!=point)            point = parent[point];        return point;    }}/** * 这个类代表的是一个结点，一个节点里面所包含的信息有这个点的x坐标和y坐标 */class Point{    private int x; //代表点的x坐标    private int y; //代表点的y坐标    private int table; //代表结点的标签，比如结点第一个那这里就是1，第二个结点那么就是2    public Point(int x, int y,int table) {        this.x = x;        this.y = y;        this.table = table;    }    public int getX() {        return x;    }    public void setX(int x) {        this.x = x;    }    public int getY() {        return y;    }    public void setY(int y) {        this.y = y;    }    public int getTable() {        return table;    }    public void setTable(int table) {        this.table = table;    }}/** * 这个类代表的是边，也就是两节点之间的一条连接的边 */class E{    Point startPoint; //边的起始结点    Point endPoint; //边的结束结点    int len; //边的长度    public E(Point startPoint, Point endPoint, int len) {        this.startPoint = startPoint;        this.endPoint = endPoint;        this.len = len;    }    public Point getStartPoint() {        return startPoint;    }    public void setStartPoint(Point startPoint) {        this.startPoint = startPoint;    }    public Point getEndPoint() {        return endPoint;    }    public void setEndPoint(Point endPoint) {        this.endPoint = endPoint;    }    public int getLen() {        return len;    }    public void setLen(int len) {        this.len = len;    }}\n","categories":["数据结构与算法","算法模板"],"tags":["算法","Kruskal"]},{"title":"Prim算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/prim/","content":"","categories":["数据结构与算法"],"tags":["算法","Prim"]},{"title":"线段树算法模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/segmenttree-xian-duan-shu/","content":"线段树\n说明：\n线段树模板\n推荐视屏：\n【喵的算法课】线段树 数据结构【6期】_哔哩哔哩_bilibili\n推荐文章：\n《算法竞赛》上册 罗勇军 第175页\n\nJava代码模板：import java.util.Scanner;/** * @author 长白崎 * @version 1.0 * @description: 线段树 * 这个模板主要展示了基本的构建，以及一些基本的使用，详细的使用需要通过题目要求动态修改。 * @date 2023/5/2 1:54 */public class SegmentTree {    public static void main(String[] args) {        //测试数据        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入数组长度：\");        int n = sc.nextInt();        int data[] = new int[n + 1]; //用于寄存值的数组        int tree[] = new int[(n + 1) * 4]; //线段树的数组        int lazyTag[] = new int[(n + 1) * 4]; //懒标记数组        //寄存数组的值输入        System.out.println(\"请输入数组内的值：\");        for (int i = 1; i &lt;= n; ++i) {            data[i] = sc.nextInt();        }        //构建线段树        build(tree, data, 1, 1, n);        //通过线段树查询区间总和        System.out.println(\"请输入需要查询的区间：\");        int start = sc.nextInt();        int end = sc.nextInt();        System.out.println(query(tree, lazyTag, start, end, 1, 1, n));        //更新线段树        System.out.println(\"请输入需要更新的区间以及更新的值为多少：\");        start = sc.nextInt();        end = sc.nextInt();        int v = sc.nextInt();        update(tree,lazyTag,start,end,1,n,1,v);        //通过线段树查询区间总和        System.out.println(\"请输入需要查询的区间：\");        start = sc.nextInt();        end = sc.nextInt();        System.out.println(query(tree, lazyTag, start, end, 1, 1, n));    }    /**     * 获取当前节点编号的左儿子结点编号     *     * @param p 代表当前结点的标签序号     * @return 返回其左子节点的标签号     */    public static int ls(int p) {        return p &lt;&lt; 1;    }    /**     * 获取当前结点编号的右儿子结点编号     *     * @param p 代表当前结点的标签序号     * @return 代表其右子结点的标签号     */    public static int rs(int p) {        return p &lt;&lt; 1 | 1;    }    /**     * 用于计算当前结点所对应的左右子结点的总和     *     * @param tree 所构建的线段树     * @param p    表示我们需要计算的结点的标签     */    public static void pushUp(int tree[], int p) {        tree[p] = tree[ls(p)] + tree[rs(p)]; //区间和    }    /**     * 构建线段树     *     * @param tree     * @param left     * @param right     */    public static void build(int tree[], int data[], int p, int left, int right) {        if (left == right) {            tree[p] = data[left];            return;        }        int mid = (left + right) &gt;&gt; 1;        build(tree, data, ls(p), left, mid);        build(tree, data, rs(p), mid + 1, right);        pushUp(tree, p);    }    /**     * 区间和查询     *     * @param tree 构建的线段树     * @param L    代表我们需要查询的数组对应的区间左标     * @param R    代表我们需要查询的数组对应的区间右标     * @param p    代表的是我们当前的所查询基于的父节点的结点标签     * @param ls   代表当前父结点的范围左标     * @param rs   代表当前父结点的范围右标     * @return 返回最终的区间总和值     */    public static int query(int tree[], int lazyTag[], int L, int R, int p, int ls, int rs) {        //完全覆盖        if (L &lt;= ls &amp;&amp; R &gt;= rs) return tree[p];        pushDown(tree, lazyTag, ls, rs, p);        int res = 0;        int mid = (ls + rs) &gt;&gt; 1;        if (L &lt;= mid) res += query(tree, lazyTag, L, R, ls(p), ls, mid);        if (R &gt; mid) res += query(tree, lazyTag, L, R, rs(p), mid + 1, rs);        return res;    }    /**     * 懒标记更新函数     *     * @param tree    线段树的数组     * @param lazyTag 懒标记数组     * @param ls      需要修改的区域的左边界     * @param rs      需要修改区域的右边界     * @param p       当前修改区域结点的标签序号     * @param v       需要修改的值     */    public static void addTag(int tree[], int lazyTag[], int ls, int rs, int p, int v) {        lazyTag[p] += v;        tree[p] += v * (rs - ls + 1);    }    /**     * 懒标记向下传递     *     * @param tree    线段树的数组     * @param lazyTag 懒标记数组     * @param ls      区间的左边界     * @param rs      区间的右边界     * @param p       对应区间的标签     */    public static void pushDown(int tree[], int lazyTag[], int ls, int rs, int p) {        //拦截不需要向下传递的懒标记        if (lazyTag[p] == 0)            return;        //开始懒标记传递        int mid = (ls + rs) &gt;&gt; 1;        addTag(tree, lazyTag, ls, mid, ls(p), lazyTag[p]);        addTag(tree, lazyTag, mid + 1, rs, rs(p), lazyTag[p]);        lazyTag[p] = 0;    }    public static void update(int tree[], int lazyTag[], int L, int R, int ls, int rs, int p, int v) {        if (L &lt;= ls &amp;&amp; R &gt;= rs) {            addTag(tree, lazyTag, ls, rs, p, v);            return;        }        //向下传递        pushDown(tree,lazyTag,ls,rs,p);        int mid = (ls+rs)&gt;&gt;1;        //如果左子结点符合要求那么递归进左子结点继续        if (L&lt;=mid) update(tree,lazyTag,L,R,ls,mid,ls(p),v);        //如果右子结点符合要求那么递归进右子结点继续        if(R &gt; mid) update(tree,lazyTag,L,R,mid+1,rs,rs(p),v);        //更新当前结点的值        pushUp(tree,p);    }}\n\n","categories":["数据结构与算法"],"tags":["算法","SegmentTree","线段树"]},{"title":"二叉树","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/er-cha-shu/","content":"二叉树思路模板C++模板/*数组模拟二叉树如果以存储起点为1那么：如果2^i&lt;n那么说明有左节点,如果2^i+1&lt;n那么说明有右节点,i代表的是度，n代表总体的长度,该度的最后一位计算就是2^(i+1)-1;比如说你现在的度是1那么度为2的最后一位就是在数组2^(1+1)-1=3当中如果以存储起点为0那么：如果2^i-1&lt;n那么说明有左节点,如果2^i&lt;n那么说明有右节点,i代表的是度,n代表总体的长度，该度的最后一位计算就是2*(i+1)-2;比如说你现在的度是1，那么度为2的最后一位就是在数组2^(1+1)-2=2当中&lt;和&lt;=的问题要看你是怎么存储的如果是从1开始存储那么就要取&lt;=n如果是从0开始存储那么就要取&lt;度必须从1开始因为如果没有二叉树必须要有一个为起点*/#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int N = 1e5 + 10;int a[N];/// @brief 寻找完全二叉树的总共的度/// @param n 总体的长度/// @param dept 度/// @return 是完全二叉树的总共的度int find(int n, int dept){    for (int i = 2; i &lt;= n; i++)    {        // 找到了最后一位那么递增一位度        if (pow(2, dept + 1) - 1 == i)            dept++;    }    return dept;}/// @brief 输出树里面的数/// @param n 总体的长度/// @param dept 度void findTree(int n, int dept){    if (a[dept])        cout &lt;&lt; a[dept] &lt;&lt; \" \";    if (a[dept * 2] &amp;&amp; 2 * dept &lt;= n)        findTree(n, 2 * dept);    if (a[dept * 2 + 1] &amp;&amp; 2 * dept + 1 &lt;= n)        findTree(n, 2 * dept + 1);}int main(){    //以下是测试集    int n;    cin &gt;&gt; n;    a[1] = 1;    for (int i = 2; i &lt;= n; i++)        a[i] = i;    findTree(n, 1);    find(n, 1);}\n","categories":["数据结构与算法","算法模板"],"tags":["算法"]},{"title":"二项式","url":"/2024/05/27/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/er-xiang-shi/","content":"二项式\n公式：\n$(x+y)^n=\\sum^n_{k=0}C^{k}_nx^{n-k}y^k$\n","categories":["算法模板"],"tags":["二项式"]},{"title":"互质","url":"/2024/03/23/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/hu-zhi/","content":"互质\n什么是互质：\n互质是公约数只有1的两个整数，叫做互质整数。公约数只有1的两个自然数，叫做互质自然数，后者是前者的特殊情形。\n\n在考虑两个区间互质的情况之前我们先考虑它的一个子问题，一个数x与一个区间[l,r]的互质问题。\n处理这个问题，最简单的方法肯定是遍历区间，复杂度为O(n)，n为区间长度，显然太慢。\n这时我们可以逆向思维，转换问题，我们可以考虑求不互质的个数，然后再用全部个数减去不互质的个数。\n不互质也就是说，有公共的因子，如果把问题转换成求同有某个因子的数量，那就好处理， 比如如果计算都有因子2，设区间为[l,r]，那我们只要计算1r的个数减去1l-1的个数，也非常好算，只要r/2-(l-1)/2 就可以计算出区间[l,r]中有因子2的数字的数量(这里的除法若无特殊说明都为整数除法，即向下取整)。\n这样我们就可以把数x进行因数分解，然后对每一个因数去计算区间中有几个数同时有这个因数，累加到sum[i](i为当前这个因数中有几个质因子)，这样我们就把区间中的数分类到了，几个集合中，数sun[i]，就表示区间中与x共有i个质因子的数的数量，当然这些集合并不是区间的一个划分，因为这几个集合是有共有部分的，这时我们就用到我们上面推出的公式了。\n假设区间中一个数y与x的共有质因子数量为1，那在sum[1]中会对他算一次，sum[2]中会对它算0次.\n如果共有质因子的数量为2，那sun[1]中会对它算2次（比如y有质因子(2,3),x有质因子（2，3，5）,这时取2，计算了一次，取3又计算了一次，所以是两次），sum[2]对他计算1次。\n同样，如果共有质因子的数量为2，那sun[1]中会对它算3次，sum[2]对他计算3次(3个中选2个)，sum[3]是一次，sum[4]零次。\n欧拉函数\n其中p1,p2…pi…pn为x的所有质因数，x是一个正整数\n互质和质因数的关系\n互质（也称为互素）和质因数是数论中两个相关但不同的概念。\n\n互质（互素）：两个或多个整数中，如果它们的最大公因数（最大公约数）为1，则称这些整数是互质的。换句话说，两个数互质意味着它们之间没有共同的因数（除了1以外）。例如，3和8是互质的，因为它们的最大公因数是1，而6和9不是互质的，因为它们有公因数3。\n\n质因数：一个数的质因数是指能整除该数且是质数的因数。质数是只能被1和自身整除的正整数。例如，12的质因数包括2和3，因为12能被2和3整除，并且2和3都是质数。\n\n\n这两个概念之间的关系在于，如果两个整数是互质的，那么它们之间没有共同的因数，也就是说，它们的质因数集合没有交集。因此，两个数互质的充分必要条件是它们的质因数集合没有共同的元素。\n\n","categories":["数据结构与算法","算法模板"],"tags":["互质"]},{"title":"全排列","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/quan-pai-lie/","content":"全排列\n介绍：\n此算法的主要目的就是例举出我们的数据不重复排列的方式有多少种并且知道具体的排列方式，其实如果只是想要知道排列方式有多少种直接用数学排列组合公式直接运算就行\n就比如我们需要知道5个物品有多少个不重复的排列方式：\n$$A^5_5=\\frac{5!}{(5-5)!}=\\frac{5\\times4\\times3\\times2\\times1}{1}=120$$\n$$A^n_m=\\frac{m!}{(m-n)!}$$\n如果我们需要计算5个物品如果两两组合有多少种不重复的组合，那么：\n$$C^{2}_{5}=\\frac{5!}{2!(5-2)!}=10$$\n$$C^{n}_{m}=\\frac{A^n_m}{A^n_n}$$\n\nJava代码模板：\n\nimport java.util.Scanner;/** * @description: 全排列Java通用模板 * 全排列的主要作用就是将我们所有的例举的东西进行排列组合运算（这里高中都学过，我就不细讲了），并且例举出所有的不重复排列组合方式。 * @author 长白崎 * @date 2023/3/27 1:38 * @version 1.0 */public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner sc = new Scanner(System.in);        int num = sc.nextInt();        int data[] = new int[num]; //这个数组的作用是用来存我们需要排列的数字        int state[] = new int[num]; //这里的数组是标记数组，是用来标记我们是否有选过这个数字（标记为1代表选过，0为未选过）        int printArra[] = new int[num];//这个数组用来寄存每一次全排列后的数字，用作最后输出        //这里是测试集的输入，可以不用管----------------        for(int i=0 ; i &lt; num; ++i) {            data[i] = sc.nextInt();        }        //开始全排列        fullPer(data,state,printArra,0);    }    /**     *     * @param data 这个数组的作用是用来存我们需要排列的数字     * @param state 这里的数组是标记数组，是用来标记我们是否有选过这个数字（标记为1代表选过，0为未选过）     * @param printArra 这个数组用来寄存每一次全排列后的数字，用作最后输出     * @param step 这个int变量是用来存当前选了几个数字，当选择的数字达到我们输出排列的要求时候那就输出并且代表我们成功排列了一次     */    public static void fullPer(int data[],int state[],int printArra[],int step) {        //判断是否排列好了一次        if(step==state.length) {            //输出            for(int i= 0 ; i &lt; printArra.length ; ++i) {                System.out.print(\"\t\"+printArra[i]);            }            System.out.println();            return;        }        //全排列选择数字        for(int i= 0 ; i &lt;data.length ; ++i) {            //如果当前遍历的数字已经选择那么就直接continue跳过（1代表选择了，0代表未选择）            if(state[i]==1)                continue;            state[i] = 1; //标记数字已经选择            printArra[step] = data[i]; //并将数字寄存            fullPer(data,state,printArra,step+1); //全排列的以当前数字为基准进行下一个递归选择。            state[i] =0; //取消标记        }    }}\n\n\n","categories":["数据结构与算法","算法模板"],"tags":["算法","全排列"]},{"title":"分解质因数","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/fen-jie-zhi-yin-shu/","content":"分解质因数\n定义：\n若一个正整数无法被除了 1 和它自身之外的任何自然数整除，则称该数为质数（或者素数），否则称该自然数为合数。\n\n说明：\n分解质因数的主要作用就是将数字分解成多个质数因数，这些因数相乘等于这个数。\n推荐文章：\n(158条消息) 分解质因数_质因数分解_晴空๓的博客-CSDN博客\nACM——常见的几种分解质因子的方法 - 知乎 (zhihu.com)\n\n题目推荐\n4658. 质因数个数 - AcWing题库\n\nJava代码模板：/** * @description: 分解质因数 * @author 长白崎 * @date 2023/5/6 10:33 * @version 1.0 */public class 分解质因数 {    public static void main(String[] args) {        //测试条例，可以忽略        System.out.println(slove(10));    }\t /**     * 分解质因数核心算法     * @param n 需要分解的数字     * @return 返回可以分解多少个质因数,其中输出的i就是对应的质因数     */    public static long solve(long n){        long ans =0;        for(int i =2 ; i &lt;= Math.sqrt(n) ; ++i){        \tif(n%i==0) {        \t\t++ans;        \t\tSystem.out.println(i);        \t\twhile(n%i==0) n/=i;        \t}        }        if(n&gt;1) { ++ans; System.out.println(n);}        return ans;    }\t}\n","categories":["数据结构与算法","算法模板"],"tags":["算法"]},{"title":"前缀和","url":"/2024/03/26/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/qian-zhui-he/","content":"前缀和\n","categories":["数据结构与算法","算法模板"],"tags":["算法","数论"]},{"title":"判断是否为素数（质数）","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/pan-duan-shi-fou-wei-su-shu-zhi-shu/","content":"判断是否为素数（质数）\n说明：\n质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。(0，1不是素数)\n\nJava代码模板(试除法，时间复杂度为$O(\\sqrt{n})$)\n/** * @description: 质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。 * @author 长白崎 * @date 2023/3/30 12:29 * @version 1.0 */public class PrimeNumber {    public static void main(String[] args) {        //测试集，这里是判断100是否为素数        System.out.println( primeNumber(100) );    }    /**     * 判断素数模板     * @param num 需要判断的数字     * @return 如果为素数那么就返回true，否则就返回false     */    public static boolean primeNumber(int num){        for(int i =2; i &lt;= Math.sqrt(num); ++i){            if (num%i==0)                return false;        }        return true;    }}\n","categories":["数据结构与算法","算法模板"],"tags":["算法","数论"]},{"title":"单调栈","url":"/2025/04/25/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/dan-diao-zhan/","content":"单调栈\n说明：\n题目推荐：131. 直方图中最大的矩形 - AcWing题库\n\nJava简单单调栈实现public class 单调栈 {\tpublic static void main(String[] args) {\t\tScanner sc=new Scanner(System.in);\t\tint n=sc.nextInt();\t\t\t\t\tStack&lt;Integer&gt;s=new Stack&lt;Integer&gt;();\t\t\t\tfor(int i=0;i&lt;n;i++) {\t\t\tint x=sc.nextInt();\t\t\t\t\t\t\t\twhile(!s.isEmpty() &amp;&amp; s.peek() &gt;= x) \t\t\t\ts.pop();\t\t\t\t\t\tif(s.isEmpty())\t\t\t\tSystem.out.print(\"-1 \");\t\t\telse \t\t\t\tSystem.out.print(s.peek()+\" \");\t\t\t\t\t\ts.push(x);\t\t}//\t\t5//\t\t3 4 2 7 5//\t\t大于x的数出栈 小于x的数输出//\t\t输出  -1 3 -1 2 2 \t}}\n\n"},{"title":"均值不等式","url":"/2024/03/24/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/jun-zhi-bu-deng-shi/","content":"均值不等式（1）对实数a,b有$a^2+b^2&gt;=2ab(当且仅当a=b时取“=”号)，a^2+b^2&gt;=-2ab(当且仅当a=-b时取“=”号)$\n（2）对于非负实数a,b,有$a+b&gt;=2\\sqrt{ab},即{a+b \\over 2}&gt;=\\sqrt{ab} $\n（3）对非负实数a,b有$a(a-b)&gt;=2 \\sqrt{ab} &gt;= 0$\n（4）对实数a,b有$a(a-b)&gt;=b(a-b)$\n（5）对非负实数a,b,有$a^2+b^2&gt;=2ab&gt;=0$\n（6）对非负实数a,b,有$a^2+b^2&gt;={(a+b)^2 \\over 2} &gt;= 2ab$\n","categories":["数据结构与算法","算法模板"],"tags":["均值不等式"]},{"title":"并查集","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/bing-cha-ji/","content":"并查集\n介绍：\n此算法主要是用于查找树中的一结点的根结点，通常会用作查找匹配两个节点的根节点是否是同一个。\n\nJava代码模板：\n/** * @description: TODO * @author 长白崎 * @date 2023/3/25 16:34 * @version 1.0 *//** * 并查集主要作用就是搜索两棵树的父节点是否是同一个节点。 */public class Main {    public static void main(String[] args) {        //并查集中用于记录每个结点的父节点的数组，数组下标代表的就是对应节点，对应下标数组元素的内容代表的是其父结点。        int parent[] = new int[100];        //这一步是必不可少的，这一步是为了初始化并查集的数组，初始状态下每个结点的父结点就是他本身。        for(int i =0 ; i&lt; parent.length ; ++i) parent[i] =i;        int point = find(parent,1); //比如这里是查找1的根节点    }    //并查集核心查找算法    public static int find(int parent[],int point){        while(parent[point]!=point)            point = parent[point];        return point;    }        //带有路径压缩    public static int find(int parent[],int point){        if(parent[point]!=point) parent[point] = find(parent[point]);        return parent[point];    }}\n","categories":["数据结构与算法","算法模板"],"tags":["算法","并查集"]},{"title":"差分","url":"/2023/10/22/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/chai-fen/","content":"差分\n什么是差分：\n差分一一种处理数据的巧妙而简单的方法，它应用于区间的修改和询问问题。把给定的数据集A分成多个区间，对这些区间做多次操作，每次操作是对某个区间内的所有元素做相同的加减操作，若一个个地修改区间内的元素，非常耗时。引入差分数组D，当修改某个区间时，只需要修改这个区间的断点，就能记录整个区间的修改，而对端点的修改非常容易，复杂度为O(1)。当所有修改操作结束后，再利用差分数组计算出新的A。\n数据A可以是一维线性数组a[]、二维矩阵a[][]、三维立体a[][][]。相应地，定义一维差分数组D[]、二维差分数组D[][]、三维差分数组D[][][]。一维差分容易理解，二维和三维差分需要一点空间想象力。\n类似于数学中的求导和积分，差分可以看成前缀和的逆运算。前缀和就是积分、差分就是微分。\n\n差分在写题时候作用：\n一般的，差分主要用于让一个序列某一特定范围内的所有值都加上或减去一个常数。\n所以差分往往应用于线性的场合，即一维数组的环境，但是除此之外，差分还可以用于二维数组，甚至三维！！！\n但是相比一维数组，应用的少。\n差分可以简单的看成序列中每个元素与其前一个元素的差。\n\n一维差分\n\n\nJava模板\n\n\n\nC++模板\n\n\n\n二维差分\n前缀和\n在一维差分中，原数组a[]是从第1个D[1]开始的差分数组D[]的前缀和，a[k]=D[1]+D[2]+…+D[k]。\n在二维差分中，a[][]是差分数组D[][]的前缀和，即由原点坐标(1,1)和坐标(i,j)围成的矩阵中，所有D[][]。\n\n推荐例题：\n\nP3397 地毯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n","categories":["数据结构与算法","算法模板"],"tags":["算法"]},{"title":"快读快输模板","url":"/2023/11/16/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/kuai-du-kuai-shu/","content":"快读快输\nJava快输模板：static class Reader{\tstatic BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\tstatic StringTokenizer tokenizer = new StringTokenizer(\"\");\t\tpublic static String next() throws IOException {\t\twhile(!tokenizer.hasMoreTokens()) {\t\t\ttokenizer = new StringTokenizer(reader.readLine());\t\t}\t\treturn tokenizer.nextToken();\t}\t\tpublic static int nextInt() throws NumberFormatException, IOException {\t\treturn Integer.parseInt(next());\t}}\n\n\n\nJava快读模板：static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));public static void main(String[] args){    out.println(\"快速输出\");    out.flush();}\n\n","categories":["数据结构与算法","算法模板"],"tags":["快读快输"]},{"title":"快速幂","url":"/2024/03/15/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/kuai-su-mi/","content":"快速幂\n说明：\n\n快速幂（Exponentiation by squaring，平方求幂）是一种简单而有效的小算法，它可以以$$O(logn)$$的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。\n让我们先来思考一个问题：7的10次方，怎样算比较快？\n方法1：最朴素的想法，7*7=49，49*7=343，… 一步一步算，共进行了9次乘法。\n这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。\n方法2：先算7的5次方，即7*7*7*7*7，再算它的平方，共进行了5次乘法。\n但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。\n方法3：先算7*7得49，则7的5次方为49*49*7，再算它的平方，共进行了4次乘法。\n模仿这样的过程，我们得到一个在$$O(logn)$$时间内计算出幂的算法，也就是快速幂。\n\nJava模板(迭代法)static long qpow(long a,int n){    long sum =1;    while(n!=0){        if((n&amp;1)!=0)            sum=sum*a;        a=a*a;        n&gt;&gt;=1;    }    return sum;}\n\n\n\nC++模板(迭代法)//非递归快速幂int qpow(int a, int n){    int ans = 1;    while(n){        if(n&amp;1)        //如果n的当前末位为1            ans *= a;  //ans乘上当前的a        a *= a;        //a自乘        n &gt;&gt;= 1;       //n往右移一位    }    return ans;}\n\n\n\nC++模板(递归法)int qpow(int a, int n){    if (n == 0)        return 1;    else if (n % 2 == 1)        return qpow(a, n - 1) * a;    else    {        int temp = qpow(a, n / 2);        return temp * temp;    }}\n\n","categories":["数据结构与算法","算法模板"],"tags":["快速幂"]},{"title":"排列组合","url":"/2024/03/15/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/pai-lie-zu-he/","content":"排列组合\nJava模板```## C++模板```c++int arrange(int m,int n){    if(m==n) return n;    return m*arrange(m-1,n);}void dfs(int x){    if(x==n){        for(int i =1;i&lt;=n;++i)            printf(\"%d\",a[i]);        for(int i=1;i&lt;=n;++i){            if(!mark[i]){                a[x]=i;++mark[i];            }            dfs(x+1);            mark[i]=0; //回溯        }    }}\n\n","categories":["数据结构与算法","算法模板"],"tags":["排列组合"]},{"title":"排列组合数","url":"/2023/06/04/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/pai-lie-zu-he-shu/","content":"排列组合数\n说明：\n\n&gt; 排列数：\n&gt;\n&gt; 从n个物品中不放回地依次选m个物品，考虑顺序，有多少种方案，记作$A^m_n$\n&gt;\n&gt; $A^m_n={{n!}\\over{n-m}!}$\n&gt;\n&gt; 组合数:\n&gt;\n&gt; 从n个物品中不放回地依次选m个物品，不考虑顺序，有多少种方案，记作$C^m_n$\n&gt;\n&gt; $C^m_n={{n!}\\over{m!\\times(n-m)!}}$\n&gt;\n&gt; 求组合数常用公式：\n&gt;\n&gt; 定义式\n&gt;\n&gt; $C^m_n={{n!}\\over{m!\\times(n-m)!}}$\n&gt;\n&gt; 当n,m很大时，预处理阶乘和逆元，预处理O(n),求组合数O(1)\n&gt;\n&gt; \n&gt;\n&gt; 递推式：\n&gt;\n&gt; $C^m_n={{n!}\\over{m!\\times(n-m)!}}={{n!}\\over{(m-1)!\\times(n-m+1)!}}\\times{{n-m+1}\\over{m}}=C^{m-1}_n\\times{{n-m+1}\\over{m}}$\n&gt;\n&gt; \n&gt;\n&gt; 杨辉三角：\n&gt;\n&gt; $C^m_n={{n!}\\over{m!\\times(n-m)!}}={{(n-1)!\\times(n-m+m)}\\over{m!\\times(n-m)!}}={{(n-1)!\\times(n-m)}\\over{m!\\times(n-m)!}}+{{(n-1)!\\times m}\\over{m!\\times(n-m)!}}={{(n-1)!}\\over{m! \\times(n-m-1)!}}+{{(n-1)!}\\over{(m-1)!\\times(n-m)!}}=C^m_{n-1}+C^{m-1}_{n-1}$\n&gt;\n&gt; 当模数不是质数的时候，预处理$O(n^2)$，求组合数$O(1)$\n&gt;\n&gt; 性质一\n&gt;\n&gt; $C^m_n=C^{n-m}_n$\n&gt;\n&gt; 性质二\n&gt;\n&gt; $C^m_{n+m+1}=\\sum^m_{i=0}C^i_{n+i}$\n&gt;\n&gt; \n&gt;\n&gt; 用C(n,m)表示。在Java中，可以使用递归或动态规划的方法来计算组合数。\n\n\n\nJava代码模板：/*递归实现版*/public static int C(int n, int m) {    if (n == m || m == 0) {        return 1;    } else {        return C(n-1, m-1) + C(n-1, m);    }}/*动态规划实现版*/public static int C(int n, int m) {    int[][] dp = new int[n+1][m+1];    for (int i = 0; i &lt;= n; i++) {        dp[i][0] = 1;    }    for (int i = 1; i &lt;= n; i++) {        for (int j = 1; j &lt;= m &amp;&amp; j &lt;= i; j++) {            dp[i][j] = dp[i-1][j-1] + dp[i-1][j];        }    }    return dp[n][m];}\n\n","categories":["数据结构与算法","算法模板"],"tags":["数论"]},{"title":"数位DP模板","url":"/2023/05/22/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/shu-wei-dp/","content":"数位DP\n说明：\n数位DP是为了解决某些数字匹配上面的问题，其中经典的写法是套用DFS算法实现数位DP。\n视屏教学：\n数位DPE37 数位DP Windy数_哔哩哔哩_bilibili\n这里说一下，前导零的意思，就是这个数字的前面都是零，比如说我们要dp的数字的最数字的位数为123。但是我们在进行dfs的DP的时候会从1开始，那么一开始我们从1开始dfs的时候那么就是001。也就是前面占位的都是零，也就叫做前导零。\n\nimport java.util.Arrays;import java.util.Scanner;/** * @description: 数位DP * 这个是一个数位DP的模板，这里的数位DP主要是利用DFS来实现的。 * @author 长白崎 * @date 2023/6/4 1:05 * @version 1.0 */public class NumBitDP {    public static void main(String[] args) {        //测试数据        Scanner sc = new Scanner(System.in);        int a = sc.nextInt();        System.out.println(a);    }    public static long slove(int num){        int bit[] = new int[13];        int i =0;        while(num!=0){            bit[++i] = num%10;            num/=10;        }        long dp[][] = new long[i+1][10];        //初始化dp数组里面的值都为-1        for(int y = 0 ; y&lt;=i ; ++y)            Arrays.fill(dp[i],-1);        return dfs(dp,bit,i,0,true,true);    }    /**     * 这个函数是数位DP的核心算法     * @param dp DP的数组     * @param bit 这个数组主要用来存每一位的数字，数字存储的位置为从最高位开始，比如说我们存123这个数字，那么在数组里面应该是[][3][2][1]     * @param index 这个用于标记当前dfs的是对应数组的哪一个位置，dfs是从最高位先递归到最低位（个位）然后从低位逐渐递归到最高位     * @param preNum 这个变量主要的作用是用于记录前面dfs所选的数字     * @param limit 这个变量主要用于标记是否当前递归到的dfs是否有最高位限制，这个最高位限制与之前递归的dfs有关     * @param zero 这个变量主要是用于记录是否含有前导零，这个前导零的意思指的是除这一位以外所有比当前dfs的这一位高的位数都是零，比如：     *             123这个数字，我们利用数位dp的时候相当于记录1~123这个区域的数字有多少符合要求的，那么从最低位开始001、002、...、024     *             这里的0代表的就是前导零     * @return 返回当前位所能取到的合法数字的全部数量     */    public static long dfs(long dp[][],int bit[],int index,int preNum,boolean limit ,boolean zero){        //如果搜到了最后一位那么就直接退出就得        if(index==0)            return 1;        //如果不是前导零，并且没有最高位限制，而且有当前位数index为基准的前导数为preNum的搜索状态值那么就直接返回        if(!zero &amp;&amp; !limit &amp;&amp; dp[index][preNum]!=-1)            return dp[index][preNum];        int maxNum = limit?bit[index]:9;        long ans = 0;        for(int i = 0 ; i &lt;=maxNum ; ++i){            //这里开始添加过滤条件。。。。。            //这里开始正常的搜索            if(zero &amp;&amp; i==0)                ans +=dfs(dp,bit,index-1,i,limit &amp;&amp; i==bit[index] ? true:false,true);            else                ans+=dfs(dp,bit,index-1,i,limit &amp;&amp; i==bit[index] ? true:false,false);        }        if(!zero &amp;&amp; !limit)            dp[index][preNum] = ans;        return ans;    }}\n\n","categories":["数据结构与算法","算法模板"],"tags":["DP"]},{"title":"将数字N拆分为K个不同的数字","url":"/2023/06/06/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/shu-zi-n-chai-fen-wei-k-ge-bu-tong-shu-zi/","content":"将数字N拆分为K个不同的数字\n说明：\n将数字N拆分为K个不同的数字一共有多少种不同的方法？\n\nJava代码模板：public class 数字拆分 {    public static void main(String[] args) {        System.out.println(slove(2022,10));    }    /**     * 将数字N拆分为K个不相同的正整数之和，一共有多少种不同的方法？     * @param num 需要拆分的数字     * @param k 需要拆分为多少个     * @return     */    public static long slove(int num,int k){        long bp[][] = new long[num+1][k+1];        bp[0][0]=1;        for(int i =1 ; i &lt;= num ; ++i){            for(int j =1; j &lt;=k ; ++j){                if(i&gt;=j)                    bp[i][j] = bp[i-j][j] + bp[i-j][j-1];            }        }        return bp[num][k];    }}\n\n","categories":["数据结构与算法","算法模板"],"tags":["算法","数论"]},{"title":"日期合格及平年闰年判断","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/ri-qi-he-ge-ji-ping-nian-run-nian-pan-duan/","content":"日期合格及平年闰年判断\n说明：\n主要用于判断日期是否合格以及判断日期是否为平年或闰年\n\nJava代码模板：\nimport java.time.LocalDate;import java.time.LocalDateTime;public class DateJudge { public static void main(String[] args) { } /**     * 常规判断输入的日期是否合格     * @param year     * @param month     * @param day     * @param hour     * @param minute     * @param seconds     * @return 如果日期输入合格那么就返回true，不合格那么返回false     */    public static boolean dateQua(int year,int month,int day,int hour,int minute,int seconds) {        int days[] = {-1,31,28,31,30,31,30,31,31,30,31,30,31};        if(!(month==0) || month&gt;12)            return false;        if(!(day==0))return false;        if(month!=2){            if(day&gt; days[month])                return false;        }else {            boolean leap = (year%400==0) || (year%4==0 &amp;&amp; year%100!=0);            if(day &gt; 28 + (leap?1:0))                return false;        }        return true;    }    /**     * 判断年月日的输入是否合格，这个是Java特有的简便方式     * @param year 年     * @param month 月     * @param day 日     * @param hour 时     * @param minute 分     * @param seconds 秒     * @return 如果日期输入合格那么就返回true，不合格那么返回false     */    public static boolean dateQuaFun(int year,int month,int day,int hour,int minute,int seconds){        try{            LocalDateTime.of(year,month,day,hour,minute,seconds);        }catch (Exception e){            return false;        }        return true;    }    /**     * 判断闰年还是平年，普通方法     * @param year     * @return 果返回true则代表闰年，false代表平年     */    public static boolean dateRandP(int year){        if(year%4==0){            if(year%100 !=0)                return true;            else if(year%400 ==0)                return true;        }        return false;    }    /**     * Java特有的判断是否闰年还是平年     * @param year     * @return 如果返回true则代表闰年，false代表平年     */    public static boolean dateRandPFun(int year){        LocalDate date = LocalDate.of(year,1,1);        if(date.isLeapYear())            return true; //润        else            return false; //平    }}\n","categories":["数据结构与算法","算法模板"],"tags":["算法"]},{"title":"最大公约数","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/zui-da-gong-yue-shu/","content":"最大公约数\n说明：\n计算最大公约数,这里只展示通过递归实现。\n其方法使用的是数学上的==辗转相除法==\ngcd相关的概念还有裴蜀定理 ，即任意两个数的组合必定是他们gcd的倍数。同样可以推广到更多数：如果这些数的gcd是d，那么他们的组合是d的倍数，如果d不是1，那么必然有无限个数无法被组合出来。\n\nJava代码模板：\nimport java.math.BigInteger;/** * @description: 求最大公约数 * @author 长白崎 * @date 2023/3/30 12:33 * @version 1.0 */public class GCD {    public static void main(String[] args) {        //测试集        System.out.println(gcd(24,60));        System.out.println(gcdFun(24,60));    }    /**     * 计算最大公约数方式1     * @param a 数字1     * @param b 数字2     * @return 返回最大公约数     */    public static  int gcd(int a, int b){ return (b==0) ? a : gcd(b, a%b); }    /**     * Java特有的一种最大公约数计算方式     * @param a 数字1     * @param b 数字2     * @return 返回最大公约数     */    public static  int gcdFun(int a,int b){        BigInteger a1 = BigInteger.valueOf(a);        BigInteger a2 = BigInteger.valueOf(b);        return  Integer.parseInt(a1.gcd(a2).toString());    }}\nC++代码模板：int gcd(int a,int b){    return b?a:gcd(b,a%b);}\n\n","categories":["数据结构与算法","算法模板"],"tags":["数论"]},{"title":"期望","url":"/2024/05/24/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/qi-wang/","content":"期望\n前言：\n数学期望当前在OI中是一个类似于数论方面门槛的知识，在竞赛中有考察。本文将详细的讲解此内容，但也不是只纠缠于简单的概念，而会解决一些题目.可能这样介绍的知识对于大佬来说还是比较基础，但对像我这样的萌新来说通俗易懂，所以请各位口下留情。\n什么是期望\n日常生活中，我们每做一件事，都有对它的期望，这里的期望不仅仅只结果的胜负之类，也可以与状态有关。但在OI中，一般指的就是达到结果的期望，最朴素的计算是每次可能结果的概率乘以其结果的总和\n这是最基本的数学特征。\n广义下的定义：一次随机抽样中所期望的某随机变量的取值。\n数学定义：\n\n2、期望的小性质：\n设X是随机变量，C是常数，则 𝐸(𝐶𝑋)=𝐶×𝐸(𝑋)\n\n简单证明一下：\n设x 的多个随机变量为\n$𝐶𝑎_1,𝐶𝑎_2,𝐶𝑎_3…𝐶𝑎_𝑛$\n对应的出现概率为\n$𝑝_1,𝑝_2,𝑝_3…𝑝_𝑛$\n那么对应的求期望的式子\n$𝐸(𝐶𝑋)=𝐶\\sum^n_{i=1}=(a_i×p_i)$\n(C提出来)\n由于：\n$𝐸(𝑋)=\\sum^n_{i=1}=(a_i×p_i)$\n所以\n$E(CX)=C\\times E(X)$\n另一些简单的性质：\n设X，Y是任意两个随机变量，则有 $𝐸(𝑋+𝑌)=𝐸(𝑋)+𝐸(𝑌) $。\n设X，Y是相互独立的随机变量，则有$ 𝐸(𝑋𝑌)=𝐸(𝑋)×𝐸(𝑌)$ 。\n设C为常数，则$ 𝐸(𝐶)=𝐶 $。\n\n3.期望与均值？期望与均值是两个十分相近的概念，但又可以说是截然不同。\n\n均值往往是在实验中简单的对数据进行平均。\n而期望就好像在上帝视角的人。\n\n举个掷骰子的例子：\n我们的均值怎么算呢？\n显然要掷上一定多的次数来求平均数。\n比如，掷了6次，分别为$ 1,5,5,6,3,3 $，那么均值为 ${1+5+5+6+3+3 \\over 6} =3.8333333…$\n可是期望呢？\n我们不用掷骰子就能计算出来：\n\n可以看出，两个值是有明显差别的，而且还时刻不同。\n但是为什么容易弄混呢？\n因为在将多个均值求均值后，两者就无限接近了。\n定义\n设$P(x)$是一个离散概率分布函数，自变量的取值范围为${x_1,x_2,…,x_n}$。其期望呗定义为：\n$E(x)=\\sum_{k=1}^nx_kP(x_k)$\n设p(x)是一个连续概率密度函数。其期望为：\n$E(x)=\\int^{+\\infty}_{-\\infty}xp(x)dx$\n性质1、线性运算规则\n期望服从线性性质（可以很容易从期望的定义公式中导出）。因此线性运算的期望等于期望的线性运算\n$E(ax+by+c)=aE(x)+bE(y)=c$\n这个性质可以推广到任意一般情况：\n$E(\\sum^n_{k=1}a_ix_i+c)=\\sum^n_{k=1}a_iE(x_i)+c$\n2、函数的期望\n设$f(x)$为x的函数，则$f( x )$的期望为：\n离散：\n$E(f(x))=\\sum^n_{k=1}f(x_k)P(x_k)$\n连续：\n$E(f(x))=\\int^{+\\infty}_{-\\infty}f(x)p(x)dx$\n一定要注意，函数的期望不等于期望的函数，即$E(f(x))/=f(E(x))!$。\n3、乘积的期望\n一般来说，乘积的期望不等于期望的乘积，除非变量相互独立。因此，如果x和y相互独立，则$E(xy)=E(x)E(y)$。\n期望的运算构成了统计量的运算基础，因为方差、协方差等统计量本质上是一种特殊的期望。\n","categories":["数据结构与算法","算法模板"],"tags":["算法","期望"]},{"title":"树状数组模板","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/shu-zhuang-shu-zu/","content":"树状数组\n说明：\n核心点：lowbit()函数\n\n该函数是用来求二进制数（从右往左数）第一个1以及后面的0组成的值。\n例如：lowbit(10100)=100。（都是二进制数）\nlowbit(x)=x&amp;(-x),x为二进制数。\n（对于一个二进制数x，-x相当于按位取反再加1，即求其补码。&amp;就是将其补码的x按位做与运算。）\n\n\n讲解视屏：\n五分钟丝滑动画讲解 | 树状数组_哔哩哔哩_bilibili\n相应文章：\n树状数组详解 - Xenny - 博客园 (cnblogs.com)\n《算法竞赛》上册 罗勇军 第160页\n\n题目推荐：\n敌兵布阵 - HDU 1166 - Virtual Judge (vjudge.net)\n\nJava代码模板：import java.util.Scanner;/** * @description: 树状数组 * @author 长白崎 * @date 2023/5/2 1:27 * @version 1.0 */public class BinaryIndexedTrees {    public static void main(String[] args) {        //测试条例        Scanner sc = new Scanner(System.in);        //数组长度        System.out.println(\"输入数组长度：\");        int num = sc.nextInt();        int data[] = new int[num+1];        int tree[] = new int[(num+1)*4];        System.out.println(\"输入数组每个元素的值\");        for(int i=1 ; i &lt;= num ; ++i){            data[i] = sc.nextInt();            update(tree,i,data[i]);        }        //输出数组前i个之和        System.out.println(\"输出n个的和：\");        int n = sc.nextInt();        System.out.println(countSum(tree,n));        //输出start -&gt; end 的和        System.out.println(\"输出start -&gt; end 的和\");        int start = sc.nextInt();        int end = sc.nextInt();        System.out.println(countSum(tree,end)-countSum(tree,start-1));    }    /**     * lowBit函数,用于通过原data存储数组中对应的下标计算出树状数组中对应的位置下标。     * @param i     * @return     */    public static int lowBit(int i){        return i&amp;(-i);    }    /**     * update函数，用于更新树状数组的值     * @param tree 树状数组     * @param i 表示更新第i个数组的下标的值     * @param v 更新的值（即在原值的基础上做加法或其他）     */    public static void update(int tree[],int i,int v){        while(i&lt;tree.length){            tree[i] += v;            i += lowBit(i);        }    }    /**     * countSum，用于计算数组中前i个之和     * @param tree 树状数组     * @param i 这表示前i个之和     * @return 返回和值     */    public static long countSum(int tree[],int i){        long ans = 0;        while(i&gt;0){            ans+= tree[i];            i -= lowBit(i);        }        return ans;    }}\n\n","categories":["数据结构与算法","算法模板"],"tags":["算法","树状数组"]},{"title":"欧拉函数","url":"/2024/04/08/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/ou-la-han-shu/","content":"欧拉函数\n1 欧拉函数的定义\n欧拉函数（Euler’s totient function），通常记为φ(n)，是一个与正整数n相关的数论函数。它表示小于或等于n的正整数中与n互质的数的个数。互质的意思是这些数的最大公约数（最大公因数）为1。\n欧拉函数的计算公式是$φ(n) = n \\times \\left(1 - \\frac{1}{p_1}\\right) \\times \\left(1 - \\frac{1}{p_2}\\right) \\times \\ldots \\times \\left(1 - \\frac{1}{p_k}\\right)$其中，n可以分解为素数因子的乘积：$n = p_1^{a_1} \\times p_2^{a_2} \\times \\ldots \\times p_k^{a_k}$其中，p1、p2、…、pk是不同的素数，$a1、a2、…、ak$是它们的幂次。\n举个例子，如果n = 12，那么它可以分解为2^2 * 3^1。因此，φ(12) = 12 * (1 - 1/2) * (1 - 1/3) = 4。\n欧拉函数在数论和密码学中有广泛的应用，例如在RSA算法中，欧拉函数的计算用于生成加密密钥和解密密钥。\n\nJava代码模板import java.util.Scanner;public class 欧拉函数 {\tpublic static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tScanner sc= new Scanner(System.in);\t\tint n = sc.nextInt();\t\tSystem.out.println(phi(n));\t\tSystem.out.println(phii(n));\t}\t\tpublic static int phi(int x) {\t\tint res=x;\t\tfor(int i = 2;i&lt;=x/i;++i) {\t\t\tif(x%i==0) {\t\t\t\tres = res/i*(i-1); //欧拉公式，推导见下文说明\t\t\t\twhile(x%i==0) x/=i;\t\t\t}\t\t}\t\tif(x&gt;1) res = res/x*(x-1);\t\treturn res;\t}\t\t\tpublic static long phii(long x) {\t\tlong res =x;\t\tfor(long i = 2;i&lt;=Math.sqrt(x);++i) {\t\t\tif(x%i==0) {\t\t\t\tres=res/i*(i-1);\t\t\t\twhile(x%i==0)x/=i;\t\t\t}\t\t\t\t\t}\t\tif(x&gt;1)res=res/x*(x-1);\t\treturn res;\t}}\n\n\n\n欧拉代码公式推导已知欧拉函数的计算公式是$φ(n) = n \\times \\left(1 - \\frac{1}{p_1}\\right) \\times \\left(1 - \\frac{1}{p_2}\\right) \\times \\ldots \\times \\left(1 - \\frac{1}{p_k}\\right)$\n因为代码使用的迭代法一直循环进行相乘，所以我们用公式中$n\\times (1-\\frac{1}{p_1})$部分代说明。\n代码中res相当于n,i相当于$p_1$，所以可得$res \\times (1- \\frac{1}{i})$\n即:\n$res \\times(1-\\frac{1}{i})$\n$=res\\times \\frac{1}{i}(i-1)$\n$=\\frac{res}{i}\\times(i-1)$\n即代码部分res=res/i*(i-1)\n","categories":["数据结构与算法","算法模板"],"tags":["欧拉函数"]},{"title":"求最小公倍数","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/qiu-zui-xiao-gong-bei-shu/","content":"求最小公倍数\n说明：\n求最小公倍数可以在求最大公因数的基础上进行，这样就可以极大提高效率,这里需要明白一个点：\n$$\\frac{a\\times b}{gcd(a,b)}$$\n上面公式中gcd指的是求最大公因数，意思就是说a与b的最小公倍数就是a和b相乘再除以他们两的最大公因数。\n\nJava模板：\n/** * @description: 求最小公倍数 * 这里的最小公倍数做了比较大优化(时间复杂度大大降低)，是通过最小公因数来求最小公倍数 * @author 长白崎 * @date 2023/4/5 21:00 * @version 1.0 */public class LCD {    public static void main(String[] args) {        //测试实例        System.out.println(lcd(3,4));    }    /**     * 求最小公倍数     * @param a 数字1     * @param b 数字2     * @return 返回最小公倍数     */    public static int lcm(int a, int b){        return a/gcd(a,b)*b; //这里先除法再乘法，避免溢出    }    /**     * 计算最大公因数     * @param a 数字1     * @param b 数字2     * @return 返回最大公因数     */    public static int gcd(int a,int b){        return b==0?a:gcd(b,a%b);    }}\n","categories":["数据结构与算法","算法模板"],"tags":["数论"]},{"title":"直线相关","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/zhi-xian/","content":"直线相关\n说明：\n直线的一般式是：\n$$Ax+By+C=0$$(A、B不同时为0【适用于所有直线】)\n如果两直线平行：\n$$\\frac{A_1}{A_2}=\\frac{B_1}{B_2}\\not=\\frac{C_1}{C_2}\\leftrightarrow两直线平行$$\n$$\\frac{A_1}{A_2}=\\frac{B_1}{B_2}=\\frac{C_1}{C_2}\\leftrightarrow两直线重合$$\n横截距$$a=-\\frac{C}{A}$$\n纵截距$$b=-\\frac{C}{B}$$\n2：点斜式:$$y-y_0=k(x-x_0) $$【适用于不垂直于x轴的直线】\n表示斜率为k，且过$$（x_0,y_0）$$的直线\n3：截距式:$$\\frac{x}{a}+\\frac{y}{b}=1$$【适用于不过原点或不垂直于x轴、y轴的直线】\n表示与x轴、y轴相交，且x轴截距为a，y轴截距为b的直线\n4：斜截式:$$y=kx+b$$【适用于不垂直于x轴的直线】\n表示斜率为k且y轴截距为b的直线\n5：两点式:【适用于不垂直于x轴、y轴的直线】\n表示过$$（x_1,y_1）$$和$$(x_2,y_2)$$的直线　\n$$\\frac{(y-y_1)}{(y_2-y_1)}=\\frac{(x-x_1)}{(x_2-x_1)} (x_1\\not=x_2，y_1\\not=y_2)$$\n6：交点式:$$f_1(x,y)\\times m+f_2(x,y)=0$$ 【适用于任何直线】\n表示过直线$$f_1(x,y)=0$$与直线$$f_2(x,y)=0$$的交点的直线\n7：点平式:$$f(x,y) -f(x_0,y_0)=0$$【适用于任何直线】\n表示过点$$（x_0,y_0）$$且与直线$$f（x,y）=0$$平行的直线\n8：法线式：$$x·cosα+ysinα-p=0$$【适用于不平行于坐标轴的直线】\n过原点向直线做一条的垂线段，该垂线段所在直线的倾斜角为α，p是该线段的长度\n9：点向式：$$\\frac{(x-x0)}{u}=\\frac{(y-y0)}{v} (u≠0,v≠0)$$【适用于任何直线】\n表示过点$$(x_0,y_0)$$且方向向量为$$（u,v ）$$的直线\n10：法向式：$$a（x-x_0）+b（y-y_0）=0$$【适用于任何直线】\n表示过点$$（x_0，y_0）$$且与向量$$（a，b）$$垂直的直线。\n\n","categories":["数据结构与算法","算法模板"],"tags":["数论"]},{"title":"求阶乘的约数","url":"/2023/05/26/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/qiu-jie-cheng-de-yue-shu/","content":"求阶乘的约数\n说明：\n用于求阶乘有多少个约数~\n\nJava代码：import java.util.Scanner;/** * @description: 求阶乘约数 * 这个算法的模板的主要作用是用于求指定阶乘有多少个约数，其实这里是套用了能分解成多少个质数的模板。。。 * @author 长白崎 * @date 2023/5/26 16:39 * @version 1.0 */public class 阶乘约数 {    public static void main(String[] args) {        //一下为测试条例        Scanner sc  = new Scanner(System.in);        //输入需要测试的的阶乘数字        int num = sc.nextInt();        System.out.println(slove(num));    }    //这个也是算法的一部分    public  static  long slove(int num){        //这里用我们将传过来的数字作为我们需要开的数组大小，其实这里的数组开的大小就是我们需要阶乘的对应的数字的        int data[] = new int[num+1];        //这一步的作用用于将1~num所有需要阶乘的数字的数字进行        for(int i = 1 ; i &lt;=num ; ++i){            slove2(i,data);        }        long ans =1;        for(int i =1 ; i &lt;=num ; ++i){            if(data[i]==0) //这里过滤掉相应乘数不能约的数（也就是能 约的数字的数量为0的数）                continue;            ans*=(data[i]+1); //这里一定要注意+1        }        return ans;    }    //这个是主要的求当前阶乘的数字能分解出多少个数字    public static void slove2(int num,int data[]){        //这里的循环用于求是否是质数的那个模板，详细可以看看判断是否是质数的模板        for(int i= 2 ; i &lt;=Math.sqrt(num) ; ++i){            //这里是判断是否不为质数，如果不是质数那么就进行分解            if(num%i==0){                while(num%i==0){                    num/=i;                    ++data[i]; //这一步的作用就是用于统计能分解成多少个数                }            }        }        //这里判断最后分解完之后最好分解剩下的是否还能凑成一个质数，如果能那么也能算作可约数字        if(num&gt;1){            ++data[num];        }    }}\n\n","categories":["数据结构与算法","算法模板"],"tags":["数论"]},{"title":"约数","url":"/2024/04/08/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/yue-shu/","content":"约数试除法找约数\n说明：\n\nJava代码模板（统计有多少个约数）：static long solve(int a) {\t\tlong ans = 0;\t\tfor(int i = 1;i&lt;=Math.sqrt(a);++i) {\t\t\tif(a%i==0) {\t\t\t\t++ans;\t\t\t\tif(a/i!=i) ++ans;\t\t\t}\t\t}\t\treturn ans;}\n\nJava代码模板（统计质约数的个数）：import java.util.Scanner;/** * https://www.acwing.com/problem/content/4661/ * @author 长白崎 * @class[\"质因数\", \"数论\"] * */public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner sc = new Scanner(System.in);        long n = sc.nextLong();        System.out.println(solve(n));    }    static long solve(long n) {        long ans = 0;        for(long i=2;i&lt;=Math.sqrt(n);++i) {            if(n%i==0) {                ++ans;                while(n%i==0) {                    n/=i;                }            }        }        if(n&gt;1) ++ans;        return ans;    }}\n\n\n\n\n\n最大公约数\n说明：\n计算最大公约数,这里只展示通过递归实现。\n其方法使用的是数学上的==辗转相除法==\ngcd相关的概念还有裴蜀定理 ，即任意两个数的组合必定是他们gcd的倍数。同样可以推广到更多数：如果这些数的gcd是d，那么他们的组合是d的倍数，如果d不是1，那么必然有无限个数无法被组合出来。\n\nJava代码模板：\nimport java.math.BigInteger;/** * @description: 求最大公约数 * @author 长白崎 * @date 2023/3/30 12:33 * @version 1.0 */public class GCD {    public static void main(String[] args) {        //测试集        System.out.println(gcd(24,60));        System.out.println(gcdFun(24,60));    }    /**     * 计算最大公约数方式1     * @param a 数字1     * @param b 数字2     * @return 返回最大公约数     */    public static  int gcd(int a, int b){ return (b==0) ? a : gcd(b, a%b); }    /**     * Java特有的一种最大公约数计算方式     * @param a 数字1     * @param b 数字2     * @return 返回最大公约数     */    public static  int gcdFun(int a,int b){        BigInteger a1 = BigInteger.valueOf(a);        BigInteger a2 = BigInteger.valueOf(b);        return  Integer.parseInt(a1.gcd(a2).toString());    }}\nC++代码模板：int gcd(int a,int b){    return b?a:gcd(b,a%b);}\n\n","categories":["数据结构与算法","算法模板"],"tags":["数论"]},{"title":"质数筛选","url":"/2024/03/24/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/zhi-shu-shai-xuan/","content":"常见方法有：\n试除法：\n朴素筛法$O(nlogn)$：\n埃氏筛法$O(nloglogn)$：\n线性筛法$O(n)$：\n\nJava代码模板(朴素筛时间复杂度$O(nlogn)$import java.util.Scanner;public class Main {\t\t\t\tpublic static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tScanner sc = new Scanner(System.in);\t\tint n = sc.nextInt();\t\t\t\tSystem.out.println(primes(n));\t}\t    /**     * 朴素筛法     */\tstatic int primes(int n) {\t\tboolean st[] =  new boolean[n+1]; //用于标记是否不为质数的数字\t\tint prime[] = new int[n+1]; //用于记录当质数一共有prime[i]个的时候数字为多少\t\tint ans =0; //记录一共有多少质数\t\tfor(int i=2;i&lt;=n;++i) {\t\t\tif(!st[i]) prime[ans++] = i;\t\t\tfor(int j  = i*2;j&lt;=n;j+=i) {\t\t\t\tst[j] = true;\t\t\t}\t\t}\t\treturn ans;\t}\t\t}\n\n\n\n\n\nJavad代码模板(埃氏筛法时间复杂度$O(nloglogn)$，几乎与$O(n)持平$)import java.util.Scanner;public class Main {\t\t\t\tpublic static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tScanner sc = new Scanner(System.in);\t\tint n = sc.nextInt();\t\t\t\tSystem.out.println(primes(n));\t}\t\t/**\t * 埃氏筛\t * @param n\t * @return\t */\tstatic int primes(int n) {\t\tboolean st[] = new boolean[n+1];\t\tint prime[] = new int[n+1];\t\tint ans =0;\t\tfor(int i=2;i&lt;=n;++i) {\t\t\tif(!st[i]) {\t\t\t\tprime[ans++] = i;\t\t\t\tfor(int j = 2*i;j &lt;=n;j+=i) {\t\t\t\t\tst[j] = true;\t\t\t\t}\t\t\t}\t\t}\t\treturn ans;\t}}\n\n\n\nJava代码模板(线性筛法时间复杂度$O(n)$)import java.util.Scanner;public class Main {\t\t\tpublic static void main(String[] args) {\t\t// TODO Auto-generated method stub\t\tScanner sc = new Scanner(System.in);\t\tint n = sc.nextInt();\t\t\t\tSystem.out.println(primes(n));\t}\t\t\t/**\t * 线性筛\t * @param n\t * @return\t */\tstatic int primes(int n) {\t\tboolean st[] = new boolean[n+1]; //标记数字是否为质数的倍数\t\tint prime[] = new int[n+1]; //用于存储一共prime[i]个质数时候是数字几\t\t\t\tint ans =0;\t\tfor(int i= 2;i&lt;=n;++i) {\t\t\tif(!st[i]) prime[ans++] = i;\t\t\tfor(int j =0;prime[j]&lt;=n/i;++j) {\t\t\t\tst[prime[j]*i] = true;\t\t\t\tif(i%prime[j]==0) break;\t\t\t}\t\t}\t\treturn ans;\t}}\n\n注意点：\nprime[cnt++]=i;这行代码的意思是：如果发现i是素数，那么就把它放进prime数组里，同时把计数器加一。prime[j]&lt;=n/i;和之前的用法一样，如果pj乘以i的值大于n也没有意义了。内层for循环要做两件事情，分为两个条件判断：1.如果i除以prime[j]（简称pj）不等于0，说明pj不是i的最小质因子，并且可以说明pj比i的最小质因子小。这样，pji的最小值因子就一定是pj，我们不管三七二十一，先把pji这个数筛掉。2.如果i除以pj等于0，说明pj是i的最小质因子，而我们如果继续把j++的话，那么下一个pj就一定不是当前i的最小质因子了，为了避免后面重复计算造成错误，所以这里要break。综上所述，无论pj能否整除i，pj*i一定是合数，一定要筛掉。\n\n","categories":["数据结构与算法","算法模板"],"tags":["质数筛选"]},{"title":"逆元","url":"/2024/03/23/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/ni-yuan/","content":"逆元\n≡符号的意思\n在数学中，符号≡表示模同余的关系。当我们写$a \\equiv b \\pmod{m}$时，意思是a与b在模m下同余，也就是说它们除以m后得到相同的余数。换句话说，a和b的差是m的倍数。例如，$17 \\equiv 3 \\pmod{7}$表示17和3在模7下同余，因为它们相减得到的结果是7的倍数，即$17 - 3 = 14 = 2 \\times 7$。\n\n逆元的本质：\n逆元的定义： 假设 a 除b，且a和b都是整数，非浮点数，那么我们希望不做除法，因为取余数的话除法很麻烦，所以我们希望把除法变成乘法，希望找到一个数，使得a/b的余数 == ax%m。 即对于某一个b，我们能够找到一个数x，使得a/b和ax模m的余数相同的话， 则把x记作b的模m的逆元，记作b的-1次方； 即b的逆元， b的-1次方，是一个整数，是一个标记。即我们可以把所有a/b的情况转化为a*b的逆元的情况下 % M；即把除法变成了整数。\n\n\nC++模板：#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;int quick_power(int a, int b, int p){    int res = 1;    while (b)    {        if (b&amp;1) res = (LL)res * a % p;        a = (LL)a*a % p;        b &gt;&gt;= 1;    }    return res % p;}int main(){    int n;    cin &gt;&gt; n;        while (n -- )    {        int a, p;        cin &gt;&gt; a &gt;&gt; p;                int x = quick_power(a, p-2, p); //直接求出逆元的值！        if (a%p) cout &lt;&lt; x &lt;&lt; endl;        else puts(\"impossible\");    }    return 0;}\n\n","categories":["数据结构与算法","算法模板"],"tags":["逆元"]},{"title":"链式向前星","url":"/2023/11/05/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-mo-ban/lian-shi-xiang-qian-xing/","content":"链式向前星\n说明：\n如果说邻接表是不好写但效率好，邻接矩阵是好写但效率低的话，前向星就是一个相对中庸的数据结构。前向星固然好写，但效率并不高。而在优化为链式前向星后，效率也得到了较大的提升。虽然说，世界上对链式前向星的使用并不是很广泛，但在不愿意写复杂的邻接表的情况下，链式前向星也是一个很优秀的数据结构。 \n我们先展示代码再做具体讲解，链式向前星的结构模板代码如下：\nstruct Edge{    //表示边    int w;int to;    int next;}edge[10005];  int cnt=0;      //用以控制并统计边的数量  int head[10005];    //表示来源的边序号\n\n具体的解释为：\n\nEdge表示边，这个结构体数组将逐步记录边信息，其中包含有三个元素\n\nw为权重即边之间的权值，下图中为默认的1，不演示\n\nto表示为第i条边指向哪一个结点\n\nedge[i].next表示第i条边的下一条边的序号\n\ncnt表示边的数量，在输入时利用他逐个+1\n\nhead表示第x个结点所需要访问的边\n\n\n同样的我们以这个结构的图为例，链式向前星中需要存储如下内容：\n\n上图可以得到一个这样的运算表格（不唯一）\n\n\n\nEdge[0].to\n2\nEdge[0].next\n-1\nHead[1]\n0\n\n\n\nEdge[1].to\n3\nEdge[1].next\n0\nHead[1]\n1\n\n\nEdge[2].to\n4\nEdge[2].next\n-1\nHead[2]\n2\n\n\nEdge[3].to\n5\nEdge[3].next\n2\nHead[2]\n3\n\n\nEdge[4].to\n4\nEdge[4].next\n-1\nHead[3]\n4\n\n\nEdge[5].to\n5\nEdge[5].next\n-1\nHead[4]\n5\n\n\n可以见的，比如我们访问与1相互联通的所有结点，我们首先访问head[1]的内容，head的下标表示1结点，其内容表示我们应该访问边的标号，此时我们得到了数据1，表明我们需要访问边1，此时我们找到edge[1]并获取第一个to的内容，表示1结点与3结点相连通，接下来访问next的内容，在edge[1].next中获得了下一条边的标号0，因此接下来访问edge[0]的内容，得到了新得信息，edge[0].to=2，表示1结点与2结点相互联通，在访问next的内容为-1时表示没有下一条了，结束向下访问，自此，我们获得了与1相互联通的所有结点的信息。\n因此可以得到如下的信息表：\n\n\n\n结点1\n-1\n2\n3\n\n\n\n结点2\n1\n4\n5\n\n\n结点3\n-1\n4\n\n\n\n结点4\n-1\n5\n\n\n\n结点5\n-1\n\n\n\n\n添加边信息时使用以下代码:\nvoid add_edge(int from, int to, int w) {    edge[cnt].to = to;    edge[cnt].w = w;    edge[cnt].next = head[from];    head[from] = cnt++;}\n\n注意，我们需要对全体数组进行赋-1的初值，这对于出错和检验错误都是很有帮助的，因为-1正是本算法的判定边界点，当然，这个边界点也可以由自己定位任意一个负数。\n\n\nC++模板：#include&lt;iostream&gt;#define MAX 5using namespace std;int n,m,cnt;//点数量，边数量，cntstruct Edge{    int to;    int w;    int next;} edge[MAX];int head[MAX];/** * 初始化 */void init(){    for(int i =0;i&lt;=n;++i) head[i]=-1;    cnt=0;}/** * 添加边 * @param u 边起点 * @param v 边终点 * @param w 边权值 */void add_Edge(int u,int v,int w){    edge[cnt].to=v; //设置终点值    edge[cnt].w=w; //设置权值    edge[cnt].next=head[u]; //设置以u为起点的上一条边的编号    head[u]=cnt++; //更新以u为起点的上一条边的编号}int main(){    setbuf(stdout,0);    cin &gt;&gt;n&gt;&gt;m;//n个点，m条边    init(); //初始化    int u,v,w;    for(int i =0 ;i &lt;m;++i){//输入m条边        cin &gt;&gt; u&gt;&gt;v&gt;&gt;w;        add_Edge(u,v,w);    }    for(int i=1;i&lt;=n;++i){//n个起点        cout&lt;&lt;\"以\"&lt;&lt;i&lt;&lt;\"为起点的边:\"&lt;&lt;endl;        for(int j = head[i]; j!=-1;j=edge[j].next){            cout&lt;&lt;i&lt;&lt;\"--&gt;\"&lt;&lt;edge[j].to&lt;&lt;endl;        }        cout &lt;&lt;endl;    }    return 0;}\n\n\n\nJava模板：import java.util.Arrays;import java.util.Scanner;public class 链式向前星 {\tpublic static void main(String[] args) {\t\tScanner sc = new Scanner(System.in);\t\tint n = sc.nextInt(); //有多少个点\t\tint m = sc.nextInt(); //有多少条边\t\t\t\tEdge[] edge = new Edge[m]; //存储边\t\tint head[] = new int[n+1]; //以i为开头的最近填加的边的编号\t\tArrays.fill(head, -1);//初始化，-1代表没有\t\t\t\tfor(int i=0 ;i&lt; m;++i) {\t\t\tint u = sc.nextInt();\t\t\tint v = sc.nextInt();\t\t\tint w = sc.nextInt();\t\t\taddEdge(edge, head, i, u, v, w);\t\t}\t\t\t\tfor(int i= 1; i&lt;= n;++i) {\t\t\tSystem.out.println(\"以\"+i+\"为开头的边：\");\t\t\tfor(int j = head[i];j!=-1;j=edge[j].next) {\t\t\t\tSystem.out.println(i+\"--&gt;\"+edge[j].to);\t\t\t}\t\t}\t\t\t}\t\t/**\t * 添加边\t * @param edge 存储边的数组\t * @param head 存储以i为起点，其内容为结束点的最近一个录入边\t * @param ei 边的编号\t * @param u 起点\t * @param v 终点\t * @param w 权值\t */\tstatic void addEdge(Edge[] edge,int head[],int ei,int u,int v,int w) {\t\tEdge e = new Edge();\t\te.to=v;e.w=w;e.next=head[u];head[u]=ei;\t\tedge[ei]=e;\t}\t\tstatic class Edge{\t\tint to;\t\tint w;\t\tint next;\t}}\n\n","categories":["数据结构与算法","算法模板"],"tags":["链式向前星"]},{"title":"个人算法学习进度表","url":"/2024/03/08/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-bi-ji/ge-ren-suan-fa-xue-xi-jin-du-biao/","content":"个人算法学习进度表\n\n\n\n算法名称\n是否已学\n算法名称称\n是否已学\n算法名称\n是否已学\n算法名称称\n是否已学\n\n\n\nDFS\n✅\nBFS\n✅\n二分\n✅\n全排列\n✅\n\n\n差分\n✅\n前缀和\n✅\n二维差分\n✅\n二维前缀和\n✅\n\n\n树状数组\n✅\n并查集\n✅\n贪心\n✅\n线性筛\n✅\n\n\n杜教筛\n✅\nDijkstra\n✅\nKruskal\n✅\nManacher\n✅\n\n\n逆元\n✅\n快速幂\n✅\n质因数分解\n✅\nPrim\n✅\n\n\nSegment Tree(线段树)\n✅\n背包DP\n✅\n线性DP\n✅\n状态压缩DP\n✅\n\n\n树形DP\n✅\n数位DP\n✅\n互质\n✅\nKMP\n✅\n\n\n链式向前星\n✅\n模拟退火\n✅\nST表\n✅\n\n\n\n\n","categories":["数据结构与算法"],"tags":["数据结构与算法"]},{"title":"数位DP题目的讨论","url":"/2023/06/09/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-bi-ji/shu-wei-dp-de-tao-lun/","content":"数位DP题目的讨论\n说明：\n就目前来说，所遇见的数位DP的题目类型主要可以分为以下几种类型：\n1、各个位之间数字的差异统计\n典型的题目有：Classy Numbers - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n2、数字的符合要求统计\n典型的题目有：[P2657 SCOI2009] windy 数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n","categories":["数据结构与算法"],"tags":["DP"]},{"title":"竞赛算法使用分析","url":"/2024/03/08/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-bi-ji/jing-sai-suan-fa-shi-yong-fen-xi/","content":"竞赛算法使用分析\n\n说明：\n\n\n关于算法分析本人全凭经验之谈，具体还是要根据自身和题目情况而定\n\n针对有序性数据（单调增、或者减）可以联想到二分或者双指针等算法\n针对时序性数据可以联想使用优先队列。\n带有状态绑定的可以联想DP\n数字或者字符特征统计的可以尝试联想数位DP或者Manacher或者KMP\n数据区间操作类可以联想差分、前缀和、树状数组、线段树\n矩阵类可以试着联想纬度压缩后进行双指针，或者使用二分差分或者二维前缀和\n关于线性平均类题型可以思考一下方差相关的数学定理和平均相关的数学定理\n前缀和的问题开数组最好是从1开始比较好\n","categories":["数据结构与算法"],"tags":["数据结构与算法"]},{"title":"树形DP的讨论","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-bi-ji/shu-xing-dp-de-tao-lun/","content":"树形DP的讨论\n讨论：\n关于树形DP。树形DP比较适合解决一些有相互关系和依赖的的题型，比较典型的有没有上司的舞会、金明的预算方案、这一类题目。\n首先我先说一下关于树形DP，顾名思义其含义就是在树这种数据结构上进行DP算法的运算。\n\n树上背包DP\n讨论：\n树上背包DP这类是比较典型的树形DP题目。其中主要写题步骤为这几点：\n首先找到我们需要DP的容量。也就是我们常说的背包容积大小，然后就是找到我们的需要DP的物品，常规的树上DP题主要关键数据就这两个。这里我就拿比较典型的一道题来说一下。\n(以下题目为蓝桥官方的VIP题，我看比较典型就把它截下来了)\n\n\n由图可知，我们的背包容量为V。商场一共有N件物品。第i件物品的体积为$$w_i$$，价值为$$v_i$$，其中依赖的主物件为$$s_i$$。\n这里我们定义从第二行输入的数据作为下标为1的物品，以此类推。在构建树的时候我们就以0作为根节点，1意思为第一件物品，2为第二件物品依次类推。\n从这我们就可以下手，我们从测试数据作为例子进行引入。以下为我依据 测试数据画的树形DP的树形图：\n\n这里圈里面的数字代表的是物品的编号，编号为0可以忽略他只作为根节点。其附近的w、v、s分别代表对应编号物品的体积、价值、依赖的父物品。\n","categories":["数据结构与算法"],"tags":["DP"]},{"title":"算法题型分析","url":"/2024/03/18/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-bi-ji/suan-fa-ti-xing-fen-xi/","content":"算法题型分析\nDFS算法：\n数据类模拟类算法题\n地图模拟类算法题\n","categories":["数据结构与算法"],"tags":["算法题型分析"]},{"title":"考研数据结构与算法","url":"/2024/01/24/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-bi-ji/kao-yan-shu-ju-jie-gou-yu-suan-fa/","content":"考研数据结构与算法\n常见四类基本结构\n集合\n线性结构\n树形结构\n网状结构\n\ngraph TB;  A[数据得逻辑结构]--&gt;B[线性结构];  A--&gt;C[非线性结构];  B--&gt;D[一般线性结构];  B--&gt;E[受限线性表];  B--&gt;F[线性表推广];  E--&gt;G[栈和队列];  E--&gt;H[串];  F--&gt;I[数组];  C--&gt;J[集合];  C--&gt;K[树形结构];  C--&gt;L[图状结构];  K--&gt;M[一般树];  K--&gt;N[二叉树];  L--&gt;O[有向图];  L--&gt;P[无向图];\n\n\n\n树\n二叉树二叉树的常见遍历方式：\n先根序遍历\n中根序遍历\n后根序遍历\n==注:==这里的根指的是相对子树的根\n\n先根序遍历巧妙方法：\n技巧：从每个结点引出一条线来，画的方式为从左画线再向下画线。让从左往右数出相应的结果即可。\n==注:==所画线条不能交叉。\n\n\n中根序遍历巧妙方法：\n技巧：从每个结点引出一条线来，画的方式为直接画斜直线，数出相应的结果即可。\n==注:==所画线条不能交叉。\n\n\n后根序遍历巧妙方法：\n技巧：从每个结点引出一条线来，画的方式为从右画线再向下画线。让从左往右数出相应的结果即可。\n==注:==所画线条不能交叉。\n\n\n哈夫曼树哈夫曼实际用途：\n压缩，其中压缩分为有损压缩和无损压缩，其中哈夫曼为无损压缩\n\n如何构建哈夫曼树：1、把所有节点看成一棵树\n2、找权值最小的两个树的节点，组成一颗新的树\n例如以下：\n\n假如有权集w={5,7,2,3,6,8,9}。\n对应字符     A,B,C,D,E,F,G\n\n从一到七这几个步骤可以得知，其实就是对于其元素进行优先队列的出队和入队，然后对所出队的元素组成一棵树，其树根为其权值总和，如此往复，直至合并成一棵树。\n\nWPL：带权路径长度。\n","categories":["数据结构与算法"],"tags":["数据结构与算法"]},{"title":"费马小定理","url":"/2024/04/10/learnnote/shu-ju-jie-gou-yu-suan-fa/suan-fa-bi-ji/fei-ma-xiao-ding-li/","content":"费马小定理\n说明：\n费马小定理是数论中的一个重要定理，它描述了质数的一种性质。费马小定理由17世纪法国数学家皮埃尔·德·费马提出，是他在给予数论的贡献之一。\n费马小定理陈述如下：\n如果p是一个质数，而a是一个不是p的倍数的整数，则$a^{p-1} \\equiv 1 \\pmod{p}$\n其中，a是任意整数，p是一个质数。\n简单来说，费马小定理表明，如果我们有一个质数p，那么对于任意不是p的倍数的整数a，a的p-1次幂除以p的余数等于1。这意味着在模p下，a的p-1次幂与1同余。\n费马小定理的推论包括：\n\n在模p下，如果a不是p的倍数，则$a^p \\equiv a \\pmod{p}$。\n在模p下，如果a不是p的倍数，则$a^{p-2} \\equiv \\frac{1}{a} \\pmod{p}$，这说明了求模质数的逆元的一种方法。\n\n费马小定理在密码学、计算机科学和数学中有广泛的应用，特别是在素数测试和建立加密算法的安全性证明方面。\n\n","categories":["数据结构与算法"],"tags":["费马小定理"]},{"title":"蓝桥直通题单","url":"/2023/05/19/learnnote/shu-ju-jie-gou-yu-suan-fa/lan-qiao-zhi-tong-ti-dan/lan-qiao-zhi-tong-ti-dan/","content":"蓝桥直通题单\n贪心\n4168. 种树 - AcWing题库\n[P1031 NOIP2002 提高组] 均分纸牌 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P2512 HAOI2008] 糖果传递 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n前缀和：\n562. 壁画 - AcWing题库\n1230. K倍区间 - AcWing题库\n1236. 递增三元组 - AcWing题库\n4405. 统计子矩阵 - AcWing题库\n\n差分\n4262. 空调 - AcWing题库\n5396. 棋盘 - AcWing题库\n4655. 重新排序 - AcWing题库\n\n双指针\n3745. 牛的学术圈 I - AcWing题库\n1238. 日志统计 - AcWing题库\n4405. 统计子矩阵 - AcWing题库\n\n递归\n1225. 正则问题 - AcWing题库\n\n快速幂\n504. 转圈游戏 - AcWing题库\n4968. 互质数的个数 - AcWing题库\n\n二分\n1227. 分巧克力 - AcWing题库\n4199. 公约数 - AcWing题库\n5407. 管道 - AcWing题库\n102. 最佳牛围栏 - AcWing题库\n\n树状数组\n敌兵布阵 - HDU 1166 - Virtual Judge (vjudge.net)\n1265. 数星星 - AcWing题库\n1264. 动态求连续区间和 - AcWing题库\n1215. 小朋友排队 - AcWing题库\n\nDFS\n16.机器人塔 - 蓝桥云课 (lanqiao.cn)\n1.BlueAI【算法赛】 - 蓝桥云课\n\nBFS\nP1364 医院设置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n1355. 母亲的牛奶 - AcWing题库\n1233. 全球变暖 - AcWing题库\n\n区间合并\n[P1204 USACO1.2] 挤牛奶Milking Cows - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n单调栈\n131. 直方图中最大的矩形 - AcWing题库\n1413. 矩形牛棚 - AcWing题库\n\n回文串\nP3805 【模板】manacher - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n哈希\n1402. 星空之夜 - AcWing题库\n4407. 扫雷 - AcWing题库\n1221. 四平方和 - AcWing题库\n\n背包DP\n2. 01背包问题 - AcWing题库(01背包)\n1371. 货币系统 - AcWing题库（完全背包）\n3417. 砝码称重 - AcWing题库\n0调手表 - 蓝桥云课 (lanqiao.cn)\n\n线性DP\n312. 乌龟棋 - AcWing题库\n198. 打家劫舍 - 力扣（LeetCode）\n5406. 松散子序列 - AcWing题库\n[P1095 NOIP2007 普及组] 守望者的逃离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P1077 NOIP2012 普及组] 摆花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nST表\nP3865 【模板】ST 表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P2880 USACO07JAN] Balanced Lineup G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P3295 SCOI2016] 萌萌哒 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n区间DP\nP1775 石子合并（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nString painter - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n数位DP\n[P2657 SCOI2009] windy 数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n338. 计数问题 - AcWing题库\nP4999 烦人的数学作业 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P4124 CQOI2016] 手机号码 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P4798 CEOI2015 Day1] 卡尔文球锦标赛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P3281 SCOI2013] 数数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P2518 HAOI2010] 计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P3286 SCOI2014] 方伯伯的商场之旅 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n树形DP\nP2015 二叉苹果树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P2014 CTSC1997] 选课 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)（树上背包）\nP1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n3465. 病毒溯源 - AcWing题库\n1220. 生命之树 - AcWing题库\n\n状态压缩DP\n91. 最短Hamilton路径 - AcWing题库\n731. 毕业旅行问题 - AcWing题库\n\n线段树\nP3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P3870 TJOI2009] 开关 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP6242 【模板】线段树 3（区间最值操作、区间历史最值） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nKruskal\n1.修建公路1 - 蓝桥云课 (lanqiao.cn)\n4.城市规划大师 - 蓝桥云课 (lanqiao.cn)\n\nDijkstra\n1.蓝桥王国 - 蓝桥云课 (lanqiao.cn)\n528. 奶酪 - AcWing题库\n1375. 奶牛回家 - AcWing题库\n3305. 作物杂交 - AcWing题库\n14.星际旅行 - 蓝桥云课\n\n并查集\n528. 奶酪 - AcWing题库（其实可以使用Dijkstra来做）\n\n数论\n4658. 质因数个数 - AcWing题库（分解质因数）\n0阶乘的和 - 蓝桥云课 (lanqiao.cn)\nP1592 互质 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n4199. 公约数 - AcWing题库\n3377. 约数的个数 - AcWing题库（分解质因数）\n1246. 等差数列 - AcWing题库\n3418. 杨辉三角形 - AcWing题库（组合计数）\n\n欧拉函数（数论）\n3999. 最大公约数 - AcWing题库\n4968. 互质数的个数 - AcWing题库\n\n最大公约数\n1246. 等差数列 - AcWing题库\n\n数学期望\n4009. 收集卡牌 - AcWing题库\n4646. 爬树的甲壳虫 - AcWing题库\n217. 绿豆蛙的归宿 - AcWing题库\n14.星际旅行 - 蓝桥云课\n1.最优分组 - 蓝桥云课\n\n日期类问题\n3498. 日期差值 - AcWing题库\n1229. 日期问题 - AcWing题库\n466. 回文日期 - AcWing题库\n2867. 回文日期 - AcWing题库\n3218. 日期计算 - AcWing题库\n\n贡献法\n4261. 孤独的照片 - AcWing题库\n2868. 子串分值 - AcWing题库\n5154. 牛的基因学 - AcWing题库\n2104. 子数组范围和 - 力扣（LeetCode）\n\nManacher\nP3805 【模板】manacher - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n组合计数\n211. 计算系数 - AcWing题库\n\n","categories":["算法","蓝桥"],"tags":["算法"]}]